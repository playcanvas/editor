/* array.js */
Object.defineProperty(Array.prototype, 'equals', {
    enumerable: false,
    value: function(array) {
        if (! array)
            return false;

        if (this.length !== array.length)
            return false;

        for (var i = 0, l = this.length; i < l; i++) {
            if (this[i] instanceof Array && array[i] instanceof Array) {
                if (! this[i].equals(array[i]))
                    return false;
            } else if (this[i] !== array[i]) {
                return false;
            }
        }
        return true;
    }
});

Object.defineProperty(Array.prototype, 'match', {
    enumerable: false,
    value: function(pattern) {
        if (this.length !== pattern.length)
            return;

        for(var i = 0, l = this.length; i < l; i++) {
            if (pattern[i] !== '*' && pattern[i] !== this[i])
                return false;
        }

        return true;
    }
});


Array.prototype.binaryIndexOf = function(b) {
    var min = 0;
    var max = this.length - 1;
    var cur;
    var a;

    while (min <= max) {
        cur = Math.floor((min + max) / 2);
        a = this[cur];

        if (a < b) {
            min = cur + 1;
        } else if (a > b) {
            max = cur - 1;
        } else {
            return cur;
        }
    }

    return -1;
};


/* utils.js */
var utils = { };


// utils.deepCopy
utils.deepCopy = function deepCopy(data) {
    if (data == null || typeof(data) !== 'object')
        return data;

    if (data instanceof Array) {
        var arr = [ ];
        for(var i = 0; i < data.length; i++) {
            arr[i] = deepCopy(data[i]);
        }
        return arr;
    } else {
        var obj = { };
        for(var key in data) {
            if (data.hasOwnProperty(key))
                obj[key] = deepCopy(data[key]);
        }
        return obj;
    }
};


// String.startsWith
if (! String.prototype.startsWith) {
    Object.defineProperty(String.prototype, 'startsWith', {
        enumerable: false,
        configurable: false,
        writable: false,
        value: function(str) {
            var that = this;
            var ceil = str.length;
            for(var i = 0; i < ceil; i++)
                if(that[i] !== str[i]) return false;
            return true;
        }
    });
}

// String.endsWith polyfill
if (! String.prototype.endsWith) {
    Object.defineProperty(String.prototype, 'endsWith', {
        enumerable: false,
        configurable: false,
        writable: false,
        value: function(str) {
            var that = this;
            for(var i = 0, ceil = str.length; i < ceil; i++)
                if (that[i + that.length - ceil] !== str[i])
                    return false;
            return true;
        }
    });
}

/* color.js */
var rgb2hsv = function(rgb) {
    var rr, gg, bb,
        r = rgb[0] / 255,
        g = rgb[1] / 255,
        b = rgb[2] / 255,
        h, s,
        v = Math.max(r, g, b),
        diff = v - Math.min(r, g, b),
        diffc = function(c) {
            return (v - c) / 6 / diff + 1 / 2;
        };

    if (diff == 0) {
        h = s = 0;
    } else {
        s = diff / v;
        rr = diffc(r);
        gg = diffc(g);
        bb = diffc(b);

        if (r === v) {
            h = bb - gg;
        } else if (g === v) {
            h = (1 / 3) + rr - bb;
        } else if (b === v) {
            h = (2 / 3) + gg - rr;
        }
        if (h < 0) {
            h += 1;
        } else if (h > 1) {
            h -= 1;
        }
    }
    return [ h, s, v ];
};


var hsv2rgb = function(hsv) {
    var h = hsv[0];
    var s = hsv[1];
    var v = hsv[2];
    var r, g, b, i, f, p, q, t;
    if (h && s === undefined && v === undefined) {
        s = h.s, v = h.v, h = h.h;
    }
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: r = v, g = t, b = p; break;
        case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break;
        case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break;
        case 5: r = v, g = p, b = q; break;
    }
    return [ Math.round(r * 255), Math.round(g * 255), Math.round(b * 255) ];
};


/* ajax.js */
function Ajax(args) {
    if (typeof(args) === 'string')
        args = { url: args };

    return new AjaxRequest(args);
};

Ajax.get = function(url) {
    return new AjaxRequest({
        url: url
    });
};

Ajax.post = function(url, data) {
    return new AjaxRequest({
        method: 'POST',
        url: url,
        data: data
    });
};

Ajax.put = function(url, data) {
    return new AjaxRequest({
        method: 'PUT',
        url: url,
        data: data
    });
};

Ajax.delete = function(url) {
    return new AjaxRequest({
        method: 'DELETE',
        url: url
    });
};

Ajax.params = { };

Ajax.param = function(name, value) {
    Ajax.params[name] = value;
};



function AjaxRequest(args) {
    if (! args)
        throw new Error('no arguments provided');

    Events.call(this);

    // progress
    this._progress = 0.0;
    this.emit('progress', this._progress);

    // xhr
    this._xhr = new XMLHttpRequest();

    // events
    this._xhr.addEventListener('load', this._onLoad.bind(this), false);
    // this._xhr.addEventListener('progress', this._onProgress.bind(this), false);
    this._xhr.upload.addEventListener('progress', this._onProgress.bind(this), false);
    this._xhr.addEventListener('error', this._onError.bind(this), false);
    this._xhr.addEventListener('abort', this._onAbort.bind(this), false);

    // url
    var url = args.url;

    // query
    if (args.query && Object.keys(args.query).length) {
        if (url.indexOf('?') === -1) {
            url += '?';
        }

        var query = [ ];
        for(var key in args.query) {
            query.push(key + '=' + args.query[key]);
        }

        url += query.join('&');
    }

    // templating
    var parts = url.split('{{');
    if (parts.length > 1) {
        for(var i = 1; i < parts.length; i++) {
            var ends = parts[i].indexOf('}}');
            var key = parts[i].slice(0, ends);

            if (Ajax.params[key] === undefined)
                continue;

            // replace
            parts[i] = Ajax.params[key] + parts[i].slice(ends + 2);
        }

        url = parts.join('');
    }

    // open request
    this._xhr.open(args.method || 'GET', url, true);

    this.notJson = args.notJson || false;

    // header for PUT/POST
    if (! args.ignoreContentType && (args.method === 'PUT' || args.method === 'POST' || args.method === 'DELETE'))
        this._xhr.setRequestHeader('Content-Type', 'application/json');

    if (args.headers) {
        for (var key in args.headers)
            this._xhr.setRequestHeader(key, args.headers[key]);
    }

    // stringify data if needed
    if (args.data && typeof(args.data) !== 'string' && ! (args.data instanceof FormData)) {
        args.data = JSON.stringify(args.data);
    }

    // make request
    this._xhr.send(args.data || null);
};
AjaxRequest.prototype = Object.create(Events.prototype);


AjaxRequest.prototype._onLoad = function() {
    this._progress = 1.0;
    this.emit('progress', 1.0);

    if (this._xhr.status === 200 || this._xhr.status === 201) {
        if (this.notJson) {
            this.emit('load', this._xhr.status, this._xhr.responseText);
        } else {
            try {
                var json = JSON.parse(this._xhr.responseText);
            } catch(ex) {
                this.emit('error', this._xhr.status || 0, new Error('invalid json'));
                return;
            }
            this.emit('load', this._xhr.status, json);
        }
    } else {
        try {
            var json = JSON.parse(this._xhr.responseText);
            var msg = json.message;
            if (! msg) {
                if (json.response && json.response.error && json.response.error.length)
                    msg = json.response.error[0];
            }

            if (! msg) {
                msg = this._xhr.responseText;
            }

            this.emit('error', this._xhr.status, msg);
        } catch (ex) {
            this.emit('error', this._xhr.status);
        }
    }
};


AjaxRequest.prototype._onError = function(evt) {
    this.emit('error', 0, evt);
};


AjaxRequest.prototype._onAbort = function(evt) {
    this.emit('error', 0, evt);
};


AjaxRequest.prototype._onProgress = function(evt) {
    if (! evt.lengthComputable)
        return;

    var progress = evt.loaded / evt.total;

    if (progress !== this._progress) {
        this._progress = progress;
        this.emit('progress', this._progress);
    }
};


AjaxRequest.prototype.abort = function() {
    this._xhr.abort();
};


/* observer.js */
"use strict";

function Observer(data, options) {
    Events.call(this);
    options = options || { };

    this._destroyed = false;
    this._path = '';
    this._keys = [ ];
    this._data = { };

    this.patch(data);

    this._parent = options.parent || null;
    this._parentPath = options.parentPath || '';
    this._parentField = options.parentField || null;
    this._parentKey = options.parentKey || null;

    this._silent = false;

    var propagate = function(evt) {
        return function(path, arg1, arg2, arg3) {
            if (! this._parent)
                return;

            var key = this._parentKey;
            if (! key && (this._parentField instanceof Array)) {
                key = this._parentField.indexOf(this);

                if (key === -1)
                    return;
            }

            path = this._parentPath + '.' + key + '.' + path;

            var state;
            if (this._silent)
                state = this._parent.silence();

            this._parent.emit(path + ':' + evt, arg1, arg2, arg3);
            this._parent.emit('*:' + evt, path, arg1, arg2, arg3);

            if (this._silent)
                this._parent.silenceRestore(state);
        }
    };

    // propagate set
    this.on('*:set', propagate('set'));
    this.on('*:unset', propagate('unset'));
    this.on('*:insert', propagate('insert'));
    this.on('*:remove', propagate('remove'));
    this.on('*:move', propagate('move'));
}
Observer.prototype = Object.create(Events.prototype);


Observer.prototype.silence = function() {
    this._silent = true;

    // history hook to prevent array values to be recorded
    var historyState = this.history && this.history.enabled;
    if (historyState)
        this.history.enabled = false;

    // sync hook to prevent array values to be recorded as array root already did
    var syncState = this.sync && this.sync.enabled;
    if (syncState)
        this.sync.enabled = false;

    return [ historyState, syncState ];
};


Observer.prototype.silenceRestore = function(state) {
    this._silent = false;

    if (state[0])
        this.history.enabled = true;

    if (state[1])
        this.sync.enabled = true;
};


Observer.prototype._prepare = function(target, key, value, silent) {
    var self = this;
    var state;
    var path = (target._path ? (target._path + '.') : '') + key;
    var type = typeof(value);

    target._keys.push(key);

    if (type === 'object' && (value instanceof Array)) {
        target._data[key] = value.slice(0);

        for(var i = 0; i < target._data[key].length; i++) {
            if (typeof(target._data[key][i]) === 'object' && target._data[key][i] !== null) {
                if (target._data[key][i] instanceof Array) {
                    target._data[key][i].slice(0);
                } else {
                    target._data[key][i] = new Observer(target._data[key][i], {
                        parent: this,
                        parentPath: path,
                        parentField: target._data[key],
                        parentKey: null
                    });
                }
            } else {
                state = this.silence();
                this.emit(path + '.' + i + ':set', target._data[key][i], null);
                this.emit('*:set', path + '.' + i, target._data[key][i], null);
                this.silenceRestore(state);
            }
        }

        if (silent)
            state = this.silence();

        this.emit(path + ':set', target._data[key], null);
        this.emit('*:set', path, target._data[key], null);

        if (silent)
            this.silenceRestore(state);
    } else if (type === 'object' && (value instanceof Object)) {
        if (typeof(target._data[key]) !== 'object') {
            target._data[key] = {
                _path: path,
                _keys: [ ],
                _data: { }
            };
        }

        for(var i in value) {
            if (typeof(value[i]) === 'object') {
                this._prepare(target._data[key], i, value[i], true);
            } else {
                state = this.silence();

                target._data[key]._data[i] = value[i];
                target._data[key]._keys.push(i);

                this.emit(path + '.' + i + ':set', value[i], null);
                this.emit('*:set', path + '.' + i, value[i], null);

                this.silenceRestore(state);
            }
        }

        if (silent)
            state = this.silence();

        this.emit(path + ':set', value);
        this.emit('*:set', path, value);

        if (silent)
            this.silenceRestore(state);
    } else {
        if (silent)
            state = this.silence();

        target._data[key] = value;

        this.emit(path + ':set', value);
        this.emit('*:set', path, value);

        if (silent)
            this.silenceRestore(state);
    }

    return true;
};


Observer.prototype.set = function(path, value, silent) {
    var keys = path.split('.');
    var key = keys[keys.length - 1];
    var node = this;
    var nodePath = '';
    var obj = this;
    var state;

    for(var i = 0; i < keys.length - 1; i++) {
        if (node instanceof Array) {
            node = node[keys[i]];

            if (node instanceof Observer) {
                path = keys.slice(i + 1).join('.');
                obj = node;
            }
        } else {
            if (i < keys.length && typeof(node._data[keys[i]]) !== 'object') {
                if (node._data[keys[i]])
                    obj.unset((node.__path ? node.__path + '.' : '') + keys[i]);

                node._data[keys[i]] = {
                    _path: path,
                    _keys: [ ],
                    _data: { }
                };
                node._keys.push(keys[i]);
            }

            if (i === keys.length - 1 && node.__path)
                nodePath = node.__path + '.' + keys[i];

            node = node._data[keys[i]];
        }
    }

    if (node instanceof Array) {
        var ind = parseInt(key, 10);
        if (node[ind] === value)
            return;

        var valueOld = node[ind];
        if (! (valueOld instanceof Observer))
            valueOld = obj.json(valueOld);

        node[ind] = value;

        if (value instanceof Observer) {
            value._parent = obj;
            value._parentPath = nodePath;
            value._parentField = node;
            value._parentKey = null;
        }

        if (silent)
            state = obj.silence();

        obj.emit(path + ':set', value, valueOld);
        obj.emit('*:set', path, value, valueOld);

        if (silent)
            obj.silenceRestore(state);

        return true;
    } else if (node._data && ! node._data.hasOwnProperty(key)) {
        if (typeof(value) === 'object') {
            return obj._prepare(node, key, value);
        } else {
            node._data[key] = value;
            node._keys.push(key);

            if (silent)
                state = obj.silence();

            obj.emit(path + ':set', value, null);
            obj.emit('*:set', path, value, null);

            if (silent)
                obj.silenceRestore(state);

            return true;
        }
    } else {
        if (typeof(value) === 'object' && (value instanceof Array)) {
            if (value.equals(node._data[key]))
                return false;

            var valueOld = node._data[key];
            if (! (valueOld instanceof Observer))
                valueOld = obj.json(valueOld);

            if (node._data[key] && node._data[key].length === value.length) {
                state = obj.silence();

                for(var i = 0; i < node._data[key].length; i++) {
                    if (node._data[key][i] instanceof Observer) {
                        node._data[key][i].patch(value[i]);
                    } else if (node._data[key][i] !== value[i]) {
                        node._data[key][i] = value[i];
                        obj.emit(path + '.' + i + ':set', node._data[key][i], valueOld[i] || null);
                        obj.emit('*:set', path + '.' + i, node._data[key][i], valueOld[i] || null);
                    }
                }

                obj.silenceRestore(state);
            } else {
                node._data[key] = value;

                state = obj.silence();
                for(var i = 0; i < node._data[key].length; i++) {
                    obj.emit(path + '.' + i + ':set', node._data[key][i], valueOld[i] || null);
                    obj.emit('*:set', path + '.' + i, node._data[key][i], valueOld[i] || null);
                }
                obj.silenceRestore(state);
            }

            if (silent)
                state = obj.silence();

            obj.emit(path + ':set', value, valueOld);
            obj.emit('*:set', path, value, valueOld);

            if (silent)
                obj.silenceRestore(state);

            return true;
        } else if (typeof(value) === 'object' && (value instanceof Object)) {
            var changed = false;
            var valueOld = node._data[key];
            if (! (valueOld instanceof Observer))
                valueOld = obj.json(valueOld);

            var keys = Object.keys(value);

            if (! node._data[key] || ! node._data[key]._data) {
                if (node._data[key])
                    obj.unset((node.__path ? node.__path + '.' : '') + key);

                node._data[key] = {
                    _path: path,
                    _keys: [ ],
                    _data: { }
                };
            }

            for(var n in node._data[key]._data) {
                if (! value.hasOwnProperty(n)) {
                    var c = obj.unset(path + '.' + n, true);
                    if (c) changed = true;
                } else if (node._data[key]._data.hasOwnProperty(n)) {
                    if (! obj._equals(node._data[key]._data[n], value[n])) {
                        var c = obj.set(path + '.' + n, value[n], true);
                        if (c) changed = true;
                    }
                } else {
                    var c = obj._prepare(node._data[key], n, value[n], true);
                    if (c) changed = true;
                }
            }

            for(var i = 0; i < keys.length; i++) {
                if (value[keys[i]] === undefined && node._data[key]._data.hasOwnProperty(keys[i])) {
                    var c = obj.unset(path + '.' + keys[i], true);
                    if (c) changed = true;
                } else if (typeof(value[keys[i]]) === 'object') {
                    if (node._data[key]._data.hasOwnProperty(keys[i])) {
                        var c = obj.set(path + '.' + keys[i], value[keys[i]], true);
                        if (c) changed = true;
                    } else {
                        var c = obj._prepare(node._data[key], keys[i], value[keys[i]], true);
                        if (c) changed = true;
                    }
                } else if (! obj._equals(node._data[key]._data[keys[i]], value[keys[i]])) {
                    if (typeof(value[keys[i]]) === 'object') {
                        var c = obj.set(node._data[key]._path + '.' + keys[i], value[keys[i]], true);
                        if (c) changed = true;
                    } else if (node._data[key]._data[keys[i]] !== value[keys[i]]) {
                        changed = true;

                        if (node._data[key]._keys.indexOf(keys[i]) === -1)
                            node._data[key]._keys.push(keys[i]);

                        node._data[key]._data[keys[i]] = value[keys[i]];

                        state = obj.silence();
                        obj.emit(node._data[key]._path + '.' + keys[i] + ':set', node._data[key]._data[keys[i]], null);
                        obj.emit('*:set', node._data[key]._path + '.' + keys[i], node._data[key]._data[keys[i]], null);
                        obj.silenceRestore(state);
                    }
                }
            }

            if (changed) {
                if (silent)
                    state = obj.silence();

                var val = obj.json(node._data[key]);

                obj.emit(node._data[key]._path + ':set', val, valueOld);
                obj.emit('*:set', node._data[key]._path, val, valueOld);

                if (silent)
                    obj.silenceRestore(state);

                return true;
            } else {
                return false;
            }
        } else {
            var data;
            if (! node.hasOwnProperty('_data') && node.hasOwnProperty(key)) {
                data = node;
            } else {
                data = node._data;
            }

            if (data[key] === value)
                return false;

            if (silent)
                state = obj.silence();

            var valueOld = data[key];
            if (! (valueOld instanceof Observer))
                valueOld = obj.json(valueOld);

            data[key] = value;

            obj.emit(path + ':set', value, valueOld);
            obj.emit('*:set', path, value, valueOld);

            if (silent)
                obj.silenceRestore(state);

            return true;
        }
    }

    return false;
};


Observer.prototype.has = function(path) {
    var keys = path.split('.');
    var node = this;
    for (var i = 0; i < keys.length; i++) {
        if (node == undefined)
            return undefined;

        if (node._data) {
            node = node._data[keys[i]];
        } else {
            node = node[keys[i]];
        }
    }

    return node !== undefined;
};


Observer.prototype.get = function(path, raw) {
    var keys = path.split('.');
    var node = this;
    for (var i = 0; i < keys.length; i++) {
        if (node == undefined)
            return undefined;

        if (node._data) {
            node = node._data[keys[i]];
        } else {
            node = node[keys[i]];
        }
    }

    if (raw)
        return node;

    if (node == null) {
        return null;
    } else {
        return this.json(node);
    }
};


Observer.prototype.getRaw = function(path) {
    return this.get(path, true);
};


Observer.prototype._equals = function(a, b) {
    if (a === b) {
        return true;
    } else if (a instanceof Array && b instanceof Array && a.equals(b)) {
        return true;
    } else {
        return false;
    }
};


Observer.prototype.unset = function(path, silent) {
    var keys = path.split('.');
    var key = keys[keys.length - 1];
    var node = this;
    var obj = this;

    for(var i = 0; i < keys.length - 1; i++) {
        if (node instanceof Array) {
            node = node[keys[i]];
            if (node instanceof Observer) {
                path = keys.slice(i + 1).join('.');
                obj = node;
            }
        } else {
            node = node._data[keys[i]];
        }
    }

    if (! node._data || ! node._data.hasOwnProperty(key))
        return false;

    var valueOld = node._data[key];
    if (! (valueOld instanceof Observer))
        valueOld = obj.json(valueOld);

    // recursive
    if (node._data[key] && node._data[key]._data) {
        for(var i = 0; i < node._data[key]._keys.length; i++) {
            obj.unset(path + '.' + node._data[key]._keys[i], true);
        }
    }

    node._keys.splice(node._keys.indexOf(key), 1);
    delete node._data[key];

    var state;
    if (silent)
        state = obj.silence();

    obj.emit(path + ':unset', valueOld);
    obj.emit('*:unset', path, valueOld);

    if (silent)
        obj.silenceRestore(state);

    return true;
};


Observer.prototype.remove = function(path, ind, silent) {
    var keys = path.split('.');
    var key = keys[keys.length - 1];
    var node = this;
    var obj = this;

    for(var i = 0; i < keys.length - 1; i++) {
        if (node instanceof Array) {
            node = node[parseInt(keys[i], 10)];
            if (node instanceof Observer) {
                path = keys.slice(i + 1).join('.');
                obj = node;
            }
        } else if (node._data && node._data.hasOwnProperty(keys[i])) {
            node = node._data[keys[i]];
        } else {
            return;
        }
    }

    if (! node._data || ! node._data.hasOwnProperty(key) || ! (node._data[key] instanceof Array))
        return;

    var arr = node._data[key];
    if (arr.length < ind)
        return;

    var value = arr[ind];
    if (value instanceof Observer) {
        value._parent = null;
    } else {
        value = obj.json(value);
    }

    arr.splice(ind, 1);

    var state;
    if (silent)
        state = obj.silence();

    obj.emit(path + ':remove', value, ind);
    obj.emit('*:remove', path, value, ind);

    if (silent)
        obj.silenceRestore(state);

    return true;
};


Observer.prototype.removeValue = function(path, value, silent) {
    var keys = path.split('.');
    var key = keys[keys.length - 1];
    var node = this;
    var obj = this;

    for(var i = 0; i < keys.length - 1; i++) {
        if (node instanceof Array) {
            node = node[parseInt(keys[i], 10)];
            if (node instanceof Observer) {
                path = keys.slice(i + 1).join('.');
                obj = node;
            }
        } else if (node._data && node._data.hasOwnProperty(keys[i])) {
            node = node._data[keys[i]];
        } else {
            return;
        }
    }

    if (! node._data || ! node._data.hasOwnProperty(key) || ! (node._data[key] instanceof Array))
        return;

    var arr = node._data[key];

    var ind = arr.indexOf(value);
    if (ind === -1)
        return;

    if (arr.length < ind)
        return;

    var value = arr[ind];
    if (value instanceof Observer) {
        value._parent = null;
    } else {
        value = obj.json(value);
    }

    arr.splice(ind, 1);

    var state;
    if (silent)
        state = obj.silence();

    obj.emit(path + ':remove', value, ind);
    obj.emit('*:remove', path, value, ind);

    if (silent)
        obj.silenceRestore(state);

    return true;
};


Observer.prototype.insert = function(path, value, ind, silent) {
    var keys = path.split('.');
    var key = keys[keys.length - 1];
    var node = this;
    var obj = this;

    for(var i = 0; i < keys.length - 1; i++) {
        if (node instanceof Array) {
            node = node[parseInt(keys[i], 10)];
            if (node instanceof Observer) {
                path = keys.slice(i + 1).join('.');
                obj = node;
            }
        } else if (node._data && node._data.hasOwnProperty(keys[i])) {
            node = node._data[keys[i]];
        } else {
            return;
        }
    }

    if (! node._data || ! node._data.hasOwnProperty(key) || ! (node._data[key] instanceof Array))
        return;

    var arr = node._data[key];

    if (typeof(value) === 'object' && ! (value instanceof Observer)) {
        if (value instanceof Array) {
            value = value.slice(0);
        } else {
            value = new Observer(value);
        }
    }

    if (arr.indexOf(value) !== -1)
        return;

    if (ind === undefined) {
        arr.push(value);
        ind = arr.length - 1;
    } else {
        arr.splice(ind, 0, value);
    }

    if (value instanceof Observer) {
        value._parent = obj;
        value._parentPath = node._path + '.' + key;
        value._parentField = arr;
        value._parentKey = null;
    } else {
        value = obj.json(value);
    }

    var state;
    if (silent)
        state = obj.silence();

    obj.emit(path + ':insert', value, ind);
    obj.emit('*:insert', path, value, ind);

    if (silent)
        obj.silenceRestore(state);

    return true;
};


Observer.prototype.move = function(path, indOld, indNew, silent) {
    var keys = path.split('.');
    var key = keys[keys.length - 1];
    var node = this;
    var obj = this;

    for(var i = 0; i < keys.length - 1; i++) {
        if (node instanceof Array) {
            node = node[parseInt(keys[i], 10)];
            if (node instanceof Observer) {
                path = keys.slice(i + 1).join('.');
                obj = node;
            }
        } else if (node._data && node._data.hasOwnProperty(keys[i])) {
            node = node._data[keys[i]];
        } else {
            return;
        }
    }

    if (! node._data || ! node._data.hasOwnProperty(key) || ! (node._data[key] instanceof Array))
        return;

    var arr = node._data[key];

    if (arr.length < indOld || arr.length < indNew || indOld === indNew)
        return;

    var value = arr[indOld];

    arr.splice(indOld, 1);

    if (indNew === -1)
        indNew = arr.length;

    arr.splice(indNew, 0, value);

    if (! (value instanceof Observer))
        value = obj.json(value);

    var state;
    if (silent)
        state = obj.silence();

    obj.emit(path + ':move', value, indNew, indOld);
    obj.emit('*:move', path, value, indNew, indOld);

    if (silent)
        obj.silenceRestore(state);

    return true;
};


Observer.prototype.patch = function(data) {
    if (typeof(data) !== 'object')
        return;

    for(var key in data) {
        if (typeof(data[key]) === 'object' && ! this._data.hasOwnProperty(key)) {
            this._prepare(this, key, data[key]);
        } else if (this._data[key] !== data[key]) {
            this.set(key, data[key]);
        }
    }
};


Observer.prototype.json = function(target) {
    var obj = { };
    var node = target === undefined ? this : target;

    if (node instanceof Object && node._keys) {
        for (var i = 0; i < node._keys.length; i++) {
            var key = node._keys[i];
            var value = node._data[key];
            var type = typeof(value);

            if (type === 'object' && (value instanceof Array)) {
                obj[key] = value.slice(0);

                for(var n = 0; n < obj[key].length; n++) {
                    if (typeof(obj[key][n]) === 'object')
                        obj[key][n] = this.json(obj[key][n]);
                }
            } else if (type === 'object' && (value instanceof Object)) {
                obj[key] = this.json(value);
            } else {
                obj[key] = value;
            }
        }
    } else {
        if (node === null) {
            return null;
        } else if (typeof(node) === 'object' && (node instanceof Array)) {
            obj = node.slice(0);

            for(var n = 0; n < obj.length; n++) {
                obj[n] = this.json(obj[n]);
            }
        } else if (typeof(node) === 'object') {
            for(var key in node) {
                if (node.hasOwnProperty(key))
                    obj[key] = node[key];
            }
        } else {
            obj = node;
        }
    }
    return obj;
};


Observer.prototype.forEach = function(fn, target, path) {
    var node = target || this;
    path = path || '';

    for (var i = 0; i < node._keys.length; i++) {
        var key = node._keys[i];
        var value = node._data[key];
        var type = (this.schema && this.schema.has(path + key) && this.schema.get(path + key).type.name.toLowerCase()) || typeof(value);

        if (type === 'object' && (value instanceof Array)) {
            fn(path + key, 'array', value, key);
        } else if (type === 'object' && (value instanceof Object)) {
            fn(path + key, 'object', value, key);
            this.forEach(fn, value, path + key + '.');
        } else {
            fn(path + key, type, value, key);
        }
    }
};


Observer.prototype.destroy = function() {
    if (this._destroyed) return;
    this._destroyed = true;
    this.emit('destroy');
    this.unbind();
};


/* observer-list.js */
"use strict";

function ObserverList(options) {
    Events.call(this);
    options = options || { };

    this.data = [ ];
    this._indexed = { };
    this.sorted = options.sorted || null;
    this.index = options.index || null;
}

ObserverList.prototype = Object.create(Events.prototype);


Object.defineProperty(ObserverList.prototype, 'length', {
    get: function() {
        return this.data.length;
    }
});


ObserverList.prototype.get = function(index) {
    if (this.index) {
        return this._indexed[index] || null;
    } else {
        return this.data[index] || null;
    }
};


ObserverList.prototype.set = function(index, value) {
    if (this.index) {
        this._indexed[index] = value;
    } else {
        this.data[index] = value;
    }
};


ObserverList.prototype.indexOf = function(item) {
    if (this.index) {
        var index = (item instanceof Observer && item.get(this.index)) || item[this.index]
        return (this._indexed[index] && index) || null;
    } else {
        var ind = this.data.indexOf(item);
        return ind !== -1 ? ind : null;
    }
};


ObserverList.prototype.position = function(b, fn) {
    var l = this.data;
    var min = 0;
    var max = l.length - 1;
    var cur;
    var a, i;
    fn = fn || this.sorted;

    while (min <= max) {
        cur = Math.floor((min + max) / 2);
        a = l[cur];

        i = fn(a, b);

        if (i === 1) {
            max = cur - 1;
        } else if (i === -1) {
            min = cur + 1;
        } else {
            return cur;
        }
    }

    return -1;
};


ObserverList.prototype.positionNextClosest = function(b, fn) {
    var l = this.data;
    var min = 0;
    var max = l.length - 1;
    var cur;
    var a, i;
    fn = fn || this.sorted;

    if (l.length === 0)
        return -1;

    if (fn(l[0], b) === 0)
        return 0;

    while (min <= max) {
        cur = Math.floor((min + max) / 2);
        a = l[cur];

        i = fn(a, b);

        if (i === 1) {
            max = cur - 1;
        } else if (i === -1) {
            min = cur + 1;
        } else {
            return cur;
        }
    }

    if (fn(a, b) === 1)
        return cur;

    if ((cur + 1) === l.length)
        return -1;

    return cur + 1;
};


ObserverList.prototype.has = function(item) {
    if (this.index) {
        var index = (item instanceof Observer && item.get(this.index)) || item[this.index]
        return !! this._indexed[index];
    } else {
        return this.data.indexOf(item) !== -1;
    }
};


ObserverList.prototype.add = function(item) {
    if (this.has(item))
        return null;

    var index = this.data.length;
    if (this.index) {
        index = (item instanceof Observer && item.get(this.index)) || item[this.index];
        this._indexed[index] = item;
    }

    var pos = 0;

    if (this.sorted) {
        pos = this.positionNextClosest(item);
        if (pos !== -1) {
            this.data.splice(pos, 0, item);
        } else {
            this.data.push(item);
        }
    } else {
        this.data.push(item);
        pos = this.data.length - 1;
    }

    this.emit('add', item, index);

    return pos;
};


ObserverList.prototype.move = function(item, pos) {
    var ind = this.data.indexOf(item);
    this.data.splice(ind, 1);
    if (pos === -1) {
        this.data.push(item);
    } else {
        this.data.splice(pos, 0, item);
    }
};


ObserverList.prototype.remove = function(item) {
    if (! this.has(item))
        return;

    var ind = this.data.indexOf(item);

    var index = ind;
    if (this.index) {
        index = (item instanceof Observer && item.get(this.index)) || item[this.index];
        delete this._indexed[index];
    }

    this.data.splice(ind, 1);

    this.emit('remove', item, index);
};


ObserverList.prototype.removeByKey = function(index) {
    if (this.index) {
        var item = this._indexed[index];

        if (! item)
            return;

        var ind = this.data.indexOf(item);
        this.data.splice(ind, 1);

        delete this._indexed[index];

        this.emit('remove', item, ind);
    } else {
        if (this.data.length < index)
            return;

        var item = this.data[index];

        this.data.splice(index, 1);

        this.emit('remove', item, index);
    }
};


ObserverList.prototype.removeBy = function(fn) {
    var i = this.data.length;
    while(i--) {
        if (! fn(this.data[i]))
            continue;

        if (this.index) {
            delete this._indexed[this.data[i][this.index]];
        }
        this.data.splice(i, 1);

        this.emit('remove', this.data[i], i);
    }
};


ObserverList.prototype.clear = function() {
    var items = this.data.slice(0);

    this.data = [ ];
    this._indexed = { };

    var i = items.length;
    while(i--) {
        this.emit('remove', items[i], i);
    }
};


ObserverList.prototype.forEach = function(fn) {
    for(var i = 0; i < this.data.length; i++) {
        fn(this.data[i], (this.index && this.data[i][this.index]) || i);
    }
};


ObserverList.prototype.find = function(fn) {
    var items = [ ];
    for(var i = 0; i < this.data.length; i++) {
        if (! fn(this.data[i]))
            continue;

        var index = i;
        if (this.index)
            index = this.data[i][this.index];

        items.push([ index, this.data[i] ]);
    }
    return items;
};


ObserverList.prototype.findOne = function(fn) {
    for(var i = 0; i < this.data.length; i++) {
        if (! fn(this.data[i]))
            continue;

        var index = i;
        if (this.index)
            index = this.data[i][this.index];

        return [ index, this.data[i] ];
    }
    return null;
};


ObserverList.prototype.map = function(fn) {
    return this.data.map(fn);
};


ObserverList.prototype.sort = function(fn) {
    this.data.sort(fn);
};


ObserverList.prototype.array = function() {
    return this.data.slice(0);
};


ObserverList.prototype.json = function() {
    var items = this.array();
    for(var i = 0; i < items.length; i++) {
        if (items[i] instanceof Observer) {
            items[i] = items[i].json();
        }
    }
    return items;
};


/* observer-sync.js */
function ObserverSync(args) {
    Events.call(this);
    args = args || { };

    this.item = args.item;
    this._enabled = args.enabled || true;
    this._prefix = args.prefix || [ ];
    this._paths = args.paths || null;
    this._sync = args.sync || true;

    this._initialize();
}
ObserverSync.prototype = Object.create(Events.prototype);


ObserverSync.prototype._initialize = function() {
    var self = this;
    var item = this.item;

    // object/array set
    item.on('*:set', function(path, value, valueOld) {
        if (! self._enabled) return;

        // check if path is allowed
        if (self._paths) {
            var allowedPath = false;
            for(var i = 0; i < self._paths.length; i++) {
                if (path.indexOf(self._paths[i]) !== -1) {
                    allowedPath = true;
                    break;
                }
            }

            // path is not allowed
            if (! allowedPath)
                return;
        }

        // full path
        var p = self._prefix.concat(path.split('.'));

        // need jsonify
        if (value instanceof Observer || value instanceof ObserverList)
            value = value.json();

        // can be array value
        var ind = path.lastIndexOf('.');
        if (ind !== -1 && (this.get(path.slice(0, ind)) instanceof Array)) {
            // array index should be int
            p[p.length - 1] = parseInt(p[p.length - 1], 10);

            // emit operation: list item set
            self.emit('op', {
                p: p,
                li: value,
                ld: valueOld
            });
        } else {
            // emit operation: object item set
            var obj = {
                p: p,
                oi: value
            };

            if (valueOld !== undefined) {
                obj.od = valueOld;
            }

            self.emit('op', obj);
        }
    });

    // unset
    item.on('*:unset', function(path, value) {
        if (! self._enabled) return;

        self.emit('op', {
            p: self._prefix.concat(path.split('.')),
            od: null
        });
    });

    // list move
    item.on('*:move', function(path, value, ind, indOld) {
        if (! self._enabled) return;
        self.emit('op', {
            p: self._prefix.concat(path.split('.')).concat([ indOld ]),
            lm: ind
        });
    });

    // list remove
    item.on('*:remove', function(path, value, ind) {
        if (! self._enabled) return;

        // need jsonify
        if (value instanceof Observer || value instanceof ObserverList)
            value = value.json();

        self.emit('op', {
            p: self._prefix.concat(path.split('.')).concat([ ind ]),
            ld: value
        });
    });

    // list insert
    item.on('*:insert', function(path, value, ind) {
        if (! self._enabled) return;

        // need jsonify
        if (value instanceof Observer || value instanceof ObserverList)
            value = value.json();

        self.emit('op', {
            p: self._prefix.concat(path.split('.')).concat([ ind ]),
            li: value
        });
    });
};


ObserverSync.prototype.write = function(op) {
    // disable history if available
    var historyReEnable = false;
    if (this.item.history && this.item.history.enabled) {
        historyReEnable = true;
        this.item.history.enabled = false;
    }

    if (op.hasOwnProperty('oi')) {
        // set key value
        var path = op.p.slice(this._prefix.length).join('.');

        this._enabled = false;
        this.item.set(path, op.oi);
        this._enabled = true;


    } else if (op.hasOwnProperty('ld') && op.hasOwnProperty('li')) {
        // set array value
        var path = op.p.slice(this._prefix.length).join('.');

        this._enabled = false;
        this.item.set(path, op.li);
        this._enabled = true;


    } else if (op.hasOwnProperty('ld')) {
        // delete item
        var path = op.p.slice(this._prefix.length, -1).join('.');

        this._enabled = false;
        this.item.remove(path, op.p[op.p.length - 1]);
        this._enabled = true;


    } else if (op.hasOwnProperty('li')) {
        // add item
        var path = op.p.slice(this._prefix.length, -1).join('.');
        var ind = op.p[op.p.length - 1];

        this._enabled = false;
        this.item.insert(path, op.li, ind);
        this._enabled = true;


    } else if (op.hasOwnProperty('lm')) {
        // item moved
        var path = op.p.slice(this._prefix.length, -1).join('.');
        var indOld = op.p[op.p.length - 1];
        var ind = op.lm;

        this._enabled = false;
        this.item.move(path, indOld, ind);
        this._enabled = true;


    } else if (op.hasOwnProperty('od')) {
        // unset key value
        var path = op.p.slice(this._prefix.length).join('.');
        this._enabled = false;
        this.item.unset(path);
        this._enabled = true;


    } else {
        console.log('unknown operation', op);
    }

    // reenable history
    if (historyReEnable)
        this.item.history.enabled = true;

    this.emit('sync', op);
};

Object.defineProperty(ObserverSync.prototype, 'enabled', {
    get: function() {
        return this._enabled;
    },
    set: function(value) {
        this._enabled = !! value;
    }
});

Object.defineProperty(ObserverSync.prototype, 'prefix', {
    get: function() {
        return this._prefix;
    },
    set: function(value) {
        this._prefix = value || [ ];
    }
});

Object.defineProperty(ObserverSync.prototype, 'paths', {
    get: function() {
        return this._paths;
    },
    set: function(value) {
        this._paths = value || null;
    }
});


/* observer-history.js */
function ObserverHistory(args) {
    Events.call(this);
    args = args || { };

    this.item = args.item;
    this._enabled = args.enabled || true;
    this._combine = args._combine || false;
    this._prefix = args.prefix || '';
    this._getItemFn = args.getItemFn;

    this._events = [];

    this._initialize();
}
ObserverHistory.prototype = Object.create(Events.prototype);


ObserverHistory.prototype._initialize = function() {
    var self = this;

    this._events.push(this.item.on('*:set', function(path, value, valueOld) {
        if (! self._enabled) return;

        // need jsonify
        if (value instanceof Observer)
            value = value.json();

        // action
        var data = {
            name: self._prefix + path,
            combine: self._combine,
            undo: function() {
                var item = self._getItemFn();
                if (! item) return;

                item.history.enabled = false;

                if (valueOld === undefined) {
                    item.unset(path);
                } else {
                    item.set(path, valueOld);
                }

                item.history.enabled = true;
            },
            redo: function() {
                var item = self._getItemFn();
                if (! item) return;

                item.history.enabled = false;

                if (value === undefined) {
                    item.unset(path);
                } else {
                    item.set(path, value);
                }

                item.history.enabled = true;
            }
        };

        if (data.combine && editor.call('history:canUndo') && editor.call('history:current').name === data.name) {
            // update
            self.emit('record', 'update', data);
        } else {
            // add
            self.emit('record', 'add', data);
        }
    }));

    this._events.push(this.item.on('*:unset', function(path, valueOld) {
        if (! self._enabled) return;

        // action
        var data = {
            name: self._prefix + path,
            undo: function() {
                var item = self._getItemFn();
                if (! item) return;

                item.history.enabled = false;
                item.set(path, valueOld);
                item.history.enabled = true;
            },
            redo: function() {
                var item = self._getItemFn();
                if (! item) return;

                item.history.enabled = false;
                item.unset(path);
                item.history.enabled = true;
            }
        };

        self.emit('record', 'add', data);
    }));

    this._events.push(this.item.on('*:insert', function(path, value, ind) {
        if (! self._enabled) return;

        // need jsonify
        // if (value instanceof Observer)
        //     value = value.json();

        // action
        var data = {
            name: self._prefix + path,
            undo: function() {
                var item = self._getItemFn();
                if (! item) return;

                item.history.enabled = false;
                item.removeValue(path, value);
                item.history.enabled = true;
            },
            redo: function() {
                var item = self._getItemFn();
                if (! item) return;

                item.history.enabled = false;
                item.insert(path, value, ind);
                item.history.enabled = true;
            }
        };

        self.emit('record', 'add', data);
    }));

    this._events.push(this.item.on('*:remove', function(path, value, ind) {
        if (! self._enabled) return;

        // need jsonify
        // if (value instanceof Observer)
        //     value = value.json();

        // action
        var data = {
            name: self._prefix + path,
            undo: function() {
                var item = self._getItemFn();
                if (! item) return;

                item.history.enabled = false;
                item.insert(path, value, ind);
                item.history.enabled = true;
            },
            redo: function() {
                var item = self._getItemFn();
                if (! item) return;

                item.history.enabled = false;
                item.removeValue(path, value);
                item.history.enabled = true;
            }
        };

        self.emit('record', 'add', data);
    }));

    this._events.push(this.item.on('*:move', function(path, value, ind, indOld) {
        if (! self._enabled) return;

        // action
        var data = {
            name: self._prefix + path,
            undo: function() {
                var item = self._getItemFn();
                if (! item) return;

                item.history.enabled = false;
                item.move(path, ind, indOld);
                item.history.enabled = true;
            },
            redo: function() {
                var item = self._getItemFn();
                if (! item) return;

                item.history.enabled = false;
                item.move(path, indOld, ind);
                item.history.enabled = true;
            }
        };

        self.emit('record', 'add', data);
    }));
};

ObserverHistory.prototype.destroy = function () {
    this._events.forEach(function (evt) {
        evt.unbind();
    });

    this._events.length = 0;
    this.item = null;
};

Object.defineProperty(ObserverHistory.prototype, 'enabled', {
    get: function() {
        return this._enabled;
    },
    set: function(value) {
        this._enabled = !! value;
    }
});


Object.defineProperty(ObserverHistory.prototype, 'prefix', {
    get: function() {
        return this._prefix;
    },
    set: function(value) {
        this._prefix = value || '';
    }
});


Object.defineProperty(ObserverHistory.prototype, 'combine', {
    get: function() {
        return this._combine;
    },
    set: function(value) {
        this._combine = !! value;
    }
});


/* ui.js */
"use strict";

window.ui = { };


/* ui/element.js */
"use strict";

function Element() {
    Events.call(this);
    // this.parent = null;

    this._parent = null;
    var self = this;
    this._parentDestroy = function() {
        self.destroy();
    };

    this._destroyed = false;
    this._element = null;
    this._link = null;
    this.path = '';
    this._linkSet = null;
    this._linkUnset = null;
    this.renderChanges = null;
    // render changes only from next ticks
    setTimeout(function() {
        if (this.renderChanges === null)
            this.renderChanges = true;
    }.bind(this), 0);

    this._disabled = false;
    this._disabledParent = false;

    this._evtClick = null;

    this._parentDisable = function() {
        if (self._disabledParent)
            return;

        self._disabledParent = true;

        if (! self._disabled) {
            self.emit('disable');
            self.class.add('disabled');
        }
    };
    this._parentEnable = function() {
        if (! self._disabledParent)
            return;

        self._disabledParent = false;

        if (! self._disabled) {
            self.emit('enable');
            self.class.remove('disabled');
        }
    };
}
Element.prototype = Object.create(Events.prototype);

Element.prototype.link = function(link, path) {
    if (this._link) this.unlink();
    this._link = link;
    this.path = path;

    this.emit('link', path);

    // add :set link
    if (this._onLinkChange) {
        var renderChanges = this.renderChanges;
        this.renderChanges = false;
        this._linkOnSet = this._link.on(this.path + ':set', this._onLinkChange.bind(this));
        this._linkOnUnset = this._link.on(this.path + ':unset', this._onLinkChange.bind(this));
        this._onLinkChange(this._link.get(this.path));
        this.renderChanges = renderChanges;
    }
};

Element.prototype.unlink = function() {
    if (! this._link) return;

    this.emit('unlink', this.path);

    // remove :set link
    if (this._linkOnSet) {
        this._linkOnSet.unbind();
        this._linkOnSet = null;

        this._linkOnUnset.unbind();
        this._linkOnUnset = null;
    }

    this._link = null;
    this.path = '';
};

Element.prototype.destroy = function() {
    if (this._destroyed)
        return;

    this._destroyed = true;

    if (this._parent) {
        this._evtParentDestroy.unbind();
        this._evtParentDisable.unbind();
        this._evtParentEnable.unbind();
        this._parent = null;
    }

    if (this._element.parentNode)
        this._element.parentNode.removeChild(this._element);

    this.unlink();

    this.emit('destroy');

    this.unbind();
};

Object.defineProperty(Element.prototype, 'element', {
    get: function() {
        return this._element;
    },
    set: function(value) {
        if (this._element)
            return;

        this._element = value;
        this._element.ui = this;

        var self = this;
        this._evtClick = function(evt) {
            if (self.disabled) return;
            self.emit('click', evt);
        };
        this._element.addEventListener('click', this._evtClick, false);

        this._evtHover = function(evt) {
            self.emit('hover', evt);
        };
        this._element.addEventListener('mouseover', this._evtHover, false);

        this._evtBlur = function(evt) {
            self.emit('blur', evt);
        };
        this._element.addEventListener('mouseout', this._evtBlur, false);

        if (! this.innerElement)
            this.innerElement = this._element;
    }
});

Object.defineProperty(Element.prototype, 'parent', {
    get: function() {
        return this._parent;
    },
    set: function(value) {
        // if (! value)
            // return;

        if (this._parent) {
            this._parent = null;
            this._evtParentDestroy.unbind();
            this._evtParentDisable.unbind();
            this._evtParentEnable.unbind();
        }

        if (value) {
            this._parent = value;
            this._evtParentDestroy = this._parent.once('destroy', this._parentDestroy);
            this._evtParentDisable = this._parent.on('disable', this._parentDisable);
            this._evtParentEnable = this._parent.on('enable', this._parentEnable);

            if (this._disabledParent !== this._parent.disabled) {
                this._disabledParent = this._parent.disabled;

                if (this._disabledParent) {
                    this.class.add('disabled');
                    this.emit('disable');
                } else {
                    this.class.remove('disabled');
                    this.emit('enable');
                }
            }
        }

        this.emit('parent');
    }
});

Object.defineProperty(Element.prototype, 'disabled', {
    get: function() {
        return this._disabled || this._disabledParent;
    },
    set: function(value) {
        if (this._disabled == value)
            return;

        this._disabled = !! value;
        this.emit((this._disabled || this._disabledParent) ? 'disable' : 'enable');

        if ((this._disabled || this._disabledParent)) {
            this.class.add('disabled');
        } else {
            this.class.remove('disabled');
        }
    }
});

Object.defineProperty(Element.prototype, 'disabledSelf', {
    get: function() {
        return this._disabled;
    }
});

Object.defineProperty(Element.prototype, 'enabled', {
    get: function() {
        return ! this._disabled;
    },
    set: function(value) {
        this.disabled = ! value;
    }
});

Object.defineProperty(Element.prototype, 'value', {
    get: function() {
        if (! this._link) return null;
        return this._link.get(this.path);
    },
    set: function(value) {
        if (! this._link) return;
        this._link.set(this.path, value);
    }
});


Object.defineProperty(Element.prototype, 'hidden', {
    get: function() {
        return this._element.classList.contains('hidden');
    },
    set: function(value) {
        if (this._element.classList.contains('hidden') === !! value)
            return;

        if (value) {
            this._element.classList.add('hidden');
            this.emit('hide');
        } else {
            this._element.classList.remove('hidden');
            this.emit('show');
        }
    }
});


Object.defineProperty(Element.prototype, 'style', {
    get: function() {
        return this._element.style;
    }
});


Object.defineProperty(Element.prototype, 'class', {
    get: function() {
        return this._element.classList;
    }
});


Object.defineProperty(Element.prototype, 'flexGrow', {
    get: function() {
        return this._element.style.flexGrow;
    },
    set: function(value) {
        this._element.style.flexGrow = value;
        this._element.style.WebkitFlexGrow = value;
    }
});


Object.defineProperty(Element.prototype, 'flexShrink', {
    get: function() {
        return this._element.style.flexShrink;
    },
    set: function(value) {
        this._element.style.flexShrink = value;
        this._element.style.WebkitFlexShrink = value;
    }
});


Element.prototype.flash = function() {
    this.class.add('flash');
    setTimeout(this._onFlashDelay.bind(this), 200);
};


Element.prototype._onFlashDelay = function() {
    this.class.remove('flash');
};


window.ui.Element = Element;


/* ui/container-element.js */
"use strict";

function ContainerElement() {
    ui.Element.call(this);
    this._innerElement = null;

    this._observerChanged = false;
    this._observer = new MutationObserver(this._onMutations.bind(this));
}
ContainerElement.prototype = Object.create(ui.Element.prototype);


ContainerElement.prototype._observerOptions = {
    childList: true,
    attributes: true,
    characterData: false,
    subtree: true,
    attributeOldValue: false,
    characterDataOldValue: false
};


ContainerElement.prototype.append = function(element) {
    var html = (element instanceof HTMLElement);
    var node = html ? element : element.element;

    this._innerElement.appendChild(node);

    if (! html) {
        element.parent = this;
        this.emit('append', element);
    }
};


ContainerElement.prototype.appendBefore = function(element, reference) {
    var html = (element instanceof HTMLElement);
    var node = html ? element : element.element;

    if (reference instanceof ui.Element)
        reference = reference.element;

    this._innerElement.insertBefore(node, reference);

    if (! html) {
        element.parent = this;
        this.emit('append', element);
    }
};

ContainerElement.prototype.appendAfter = function(element, reference) {
    var html = (element instanceof HTMLElement);
    var node = html ? element : element.element;

    if (reference instanceof ui.Element)
        reference = reference.element;

    reference = reference.nextSibling;

    if (reference) {
        this._innerElement.insertBefore(node, reference);
    } else {
        this._innerElement.appendChild(node);
    }

    if (! html) {
        element.parent = this;
        this.emit('append', element);
    }
};


ContainerElement.prototype.prepend = function(element) {
    var first = this._innerElement.firstChild;
    var html = (element instanceof HTMLElement);
    var node = html ? element : element.element;

    if (first) {
        this._innerElement.insertBefore(node, first);
    } else {
        this._innerElement.appendChild(node);
    }

    if (! html) {
        element.parent = this;
        this.emit('append', element);
    }
};


Object.defineProperty(ContainerElement.prototype, 'innerElement', {
    get: function() {
        return this._innerElement;
    },
    set: function(value) {
        if (this._innerElement) {
            this._observer.disconnect();
        }

        this._innerElement = value;

        this._observer.observe(this._innerElement, this._observerOptions);
    }
});


ContainerElement.prototype.clear = function() {
    var i, node;

    this._observer.disconnect();

    i = this._innerElement.childNodes.length;
    while(i--) {
        node = this._innerElement.childNodes[i];

        if (! node.ui)
            continue;

        node.ui.destroy();
    }
    this._innerElement.innerHTML = '';

    this._observer.observe(this._innerElement, this._observerOptions);
};


Object.defineProperty(ContainerElement.prototype, 'flexible', {
    get: function() {
        return this._element.classList.contains('flexible');
    },
    set: function(value) {
        if (this._element.classList.contains('flexible') === !! value)
            return;

        if (value) {
            this._element.classList.add('flexible');
        } else {
            this._element.classList.remove('flexible');
        }
    }
});


Object.defineProperty(ContainerElement.prototype, 'flex', {
    get: function() {
        return this._element.classList.contains('flex');
    },
    set: function(value) {
        if (this._element.classList.contains('flex') === !! value)
            return;

        if (value) {
            this._element.classList.add('flex');
        } else {
            this._element.classList.remove('flex');
        }
    }
});


Object.defineProperty(ContainerElement.prototype, 'flexDirection', {
    get: function() {
        return this._innerElement.style.flexDirection;
    },
    set: function(value) {
        this._innerElement.style.flexDirection = value;
        this._innerElement.style.WebkitFlexDirection = value;
    }
});


Object.defineProperty(ContainerElement.prototype, 'flexWrap', {
    get: function() {
        return this._innerElement.style.flexWrap;
    },
    set: function(value) {
        this.flex = true;
        this._innerElement.style.flexWrap = value;
        this._innerElement.style.WebkitFlexWrap = value;
    }
});

Object.defineProperty(ContainerElement.prototype, 'flexGrow', {
    get: function() {
        return this._element.style.flexGrow === 1;
    },
    set: function(value) {
        if (value)
            this.flex = true;

        this._element.style.flexGrow = !! value ? 1 : 0;
        this._element.style.WebkitFlexGrow = !! value ? 1 : 0;
        this._innerElement.style.flexGrow = this._element.style.flexGrow;
        this._innerElement.style.WebkitFlexGrow = this._element.style.flexGrow;
    }
});


Object.defineProperty(ContainerElement.prototype, 'flexShrink', {
    get: function() {
        return this._element.style.flexShrink === 1;
    },
    set: function(value) {
        if (value)
            this.flex = true;

        this._element.style.flexShrink = !! value ? 1 : 0;
        this._element.style.WebkitFlexShrink = !! value ? 1 : 0;
        this._innerElement.style.flexShrink = this._element.style.flexShrink;
        this._innerElement.style.WebkitFlexShrink = this._element.style.flexShrink;
    }
});


Object.defineProperty(ContainerElement.prototype, 'scroll', {
    get: function() {
        return this.class.contains('scrollable');
    },
    set: function() {
        this.class.add('scrollable');
    }
});


ContainerElement.prototype._onMutations = function(mutations) {
    if (this._observerChanged)
        return;

    this._observerChanged = true;

    setTimeout(function() {
        this._observerChanged = false;
        this.emit('nodesChanged');
    }.bind(this), 0);
};


window.ui.ContainerElement = ContainerElement;


/* ui/button.js */
"use strict";

function Button(args) {
    var self = this;
    ui.Element.call(this);
    args = args || { };

    this._text = args.text || '';

    this.element = document.createElement('div');
    this.element.classList.add('ui-button');
    this.element.innerHTML = this._text;

    this.element.tabIndex = 0;

    // space > click
    this.element.addEventListener('keydown', function(evt) {
        if (evt.keyCode === 27)
            return self.element.blur();

        if (evt.keyCode !== 32 || self.disabled)
            return;

        evt.stopPropagation();
        evt.preventDefault();
        self.emit('click');
    }, false);

    this.on('click', function() {
        this.element.blur();
    });
}
Button.prototype = Object.create(ui.Element.prototype);

Button.prototype._onLinkChange = function(value) {
    this.element.value = value;
};

Object.defineProperty(Button.prototype, 'text', {
    get: function() {
        return this._text;
    },
    set: function(value) {
        if (this._text === value) return;
        this._text = value;
        this.element.innerHTML = this._text;
    }
});


window.ui.Button = Button;


/* ui/checkbox.js */
"use strict";

function Checkbox(args) {
    ui.Element.call(this);
    args = args || { };

    this._text = args.text || '';

    this.element = document.createElement('div');
    this.element.classList.add('ui-checkbox', 'noSelect');
    this.element.tabIndex = 0;

    var self = this;
    this.element.addEventListener('keydown', function(evt) {
        if (evt.keyCode === 27)
            return self.element.blur();

        if (evt.keyCode !== 32 || self.disabled)
            return;

        evt.stopPropagation();
        evt.preventDefault();
        self.value = ! self.value;
    }, false);

    this.on('click', this._onClick.bind(this));

    this.on('change', function() {
        if (! this.renderChanges)
            return;

        this.flash();
    });
}
Checkbox.prototype = Object.create(ui.Element.prototype);


Checkbox.prototype._onLinkChange = function(value) {
    if (value === null) {
        this.element.classList.remove('checked');
        this.element.classList.add('null');
    } else if (value) {
        this.element.classList.add('checked');
        this.element.classList.remove('null');
    } else {
        this.element.classList.remove('checked', 'null');
    }
    this.emit('change', value);
};


Checkbox.prototype._onClick = function(evt) {
    this.value = ! this.value;
    this.element.blur();
};


Object.defineProperty(Checkbox.prototype, 'value', {
    get: function() {
        if (this._link) {
            return this._link.get(this.path);
        } else {
            return this.element.classList.contains('checked');
        }
    },
    set: function(value) {
        if (this._link) {
            this._link.set(this.path, value);
        } else {
            if (this.element.classList.contains('checked') !== value)
                this._onLinkChange(value);
        }
    }
});


window.ui.Checkbox = Checkbox;


/* ui/code.js */
"use strict";

function Code() {
    ui.ContainerElement.call(this);

    this.element = document.createElement('pre');
    this.element.classList.add('ui-code');
}
Code.prototype = Object.create(ui.ContainerElement.prototype);


Object.defineProperty(Code.prototype, 'text', {
    get: function() {
        return this._element.textContent;
    },
    set: function(value) {
        this._element.textContent = value;
    }
});


window.ui.Code = Code;


/* ui/label.js */
"use strict";

function Label(args) {
    ui.Element.call(this);
    args = args || { };

    this._text = args.text || '';

    this.element = document.createElement('span');
    this.element.classList.add('ui-label');
    this.element.innerHTML = this._text;

    this.on('change', function() {
        if (! this.renderChanges)
            return;

        this.flash();
    });

    if (args.placeholder)
        this.placeholder = args.placeholder;
}
Label.prototype = Object.create(ui.Element.prototype);


Label.prototype._onLinkChange = function(value) {
    this.text = value;
    this.emit('change', value);
};


Object.defineProperty(Label.prototype, 'text', {
    get: function() {
        if (this._link) {
            return this._link.get(this.path);
        } else {
            return this._text;
        }
    },
    set: function(value) {
        if (this._link) {
            if (! this._link.set(this.path, value)) {
                value = this._link.get(this.path);
                this.element.innerHTML = value;
            }
        } else {
            if (this._text === value) return;

            this._text = value;
            if (value === undefined || value === null)
                this._text = '';

            this.element.innerHTML = this._text;
            this.emit('change', value);
        }
    }
});

Object.defineProperty(Label.prototype, 'value', {
    get: function () {
        return this.text;
    },

    set: function (value) {
        this.text = value;
    }
});

Object.defineProperty(Label.prototype, 'placeholder', {
    get: function() {
        return this.element.getAttribute('placeholder');
    },
    set: function(value) {
        this.element.setAttribute('placeholder', value);
    }
});


window.ui.Label = Label;


/* ui/number-field.js */
"use strict";

function NumberField(args) {
    ui.Element.call(this);
    args = args || { };

    this.precision = (args.precision != null) ? args.precision : null;
    this.step = (args.step != null) ? args.step : ((args.precision != null) ? 1 / Math.pow(10, args.precision) : 1);

    this.max = (args.max !== null) ? args.max : null;
    this.min = (args.min !== null) ? args.min : null;

    this.element = document.createElement('div');
    this.element.classList.add('ui-number-field');

    this.elementInput = document.createElement('input');
    this.elementInput.tabIndex = 0;
    this.elementInput.classList.add('field');
    this.elementInput.type = 'text';
    this.elementInput.addEventListener('focus', this._onInputFocus.bind(this), false);
    this.elementInput.addEventListener('blur', this._onInputBlur.bind(this), false);
    this.elementInput.addEventListener('keydown', this._onKeyDown.bind(this), false);
    this.element.appendChild(this.elementInput);

    if (args.default !== undefined)
        this.value = args.default;

    this.elementInput.addEventListener('change', this._onChange.bind(this), false);
    // this.element.addEventListener('mousedown', this._onMouseDown.bind(this), false);
    // this.element.addEventListener('mousewheel', this._onMouseDown.bind(this), false);

    this._lastValue = this.value;
    this._mouseMove = null;
    this._dragging = false;
    this._dragDiff = 0;
    this._dragStart = 0;

    this.on('disable', function() {
        this.elementInput.disabled = true;
    });
    this.on('enable', function() {
        this.elementInput.disabled = false;
    });

    this.on('change', function() {
        if (! this.renderChanges)
            return;

        this.flash();
    });

    if (args.placeholder)
        this.placeholder = args.placeholder;
}
NumberField.prototype = Object.create(ui.Element.prototype);


NumberField.prototype._onLinkChange = function(value) {
    this.elementInput.value = value || 0;
    this.emit('change', value || 0);
};

NumberField.prototype._onChange = function() {
    var value = parseFloat(this.elementInput.value, 10) || 0;
    this.elementInput.value = value;
    this.value = value;
};

NumberField.prototype._onInputFocus = function() {
    this.class.add('focus');
};

NumberField.prototype._onInputBlur = function() {
    this.class.remove('focus');
};

NumberField.prototype._onKeyDown = function(evt) {
    if (evt.keyCode === 27)
        return this.elementInput.blur();

    if (this.disabled || [ 38, 40 ].indexOf(evt.keyCode) === -1)
        return;

    var inc = evt.keyCode === 40 ? -1 : 1;

    if (evt.shiftKey)
        inc *= 10;

    var value = this.value + (this.step || 1) * inc;

    if (this.max != null)
        value = Math.min(this.max, value);

    if (this.min != null)
        value = Math.max(this.min, value);

    if (this.precision != null)
        value = parseFloat(value.toFixed(this.precision), 10);

    this.elementInput.value = value;
    this.value = value;
};

// NumberField.prototype._onMouseDown = function(evt) {
//     if (evt.button !== 0) return;

//     this._mouseY = evt.clientY;
//     this._dragStart = this.value;

//     this._mouseMove = this._onMouseMove.bind(this);
//     this._mouseUp = this._onMouseUp.bind(this);
//     window.addEventListener('mousemove', this._mouseMove, false);
//     window.addEventListener('mouseup', this._mouseUp, false);

//     evt.preventDefault();
//     evt.stopPropagation();
// };


// NumberField.prototype._onMouseUp = function(evt) {
//     this._dragging = false;
//     this.element.disabled = false;
//     this.element.focus();
//     this.element.classList.remove('noSelect', 'active');
//     document.body.classList.remove('noSelect');

//     if (this._mouseMove) {
//         window.removeEventListener('mousemove', this._mouseMove);
//         this._mouseMove = null;
//     }
//     if (this._mouseUp) {
//         window.removeEventListener('mouseup', this._mouseUp);
//         this._mouseUp = null;
//     }

//     evt.preventDefault();
//     evt.stopPropagation();
// };

// NumberField.prototype._onMouseMove = function(evt) {
//     if (this._mouseMove === null) return;
//     if (! this._dragging) {
//         if (Math.abs(evt.clientY - this._mouseY) > 16) {
//             this._dragging = true;
//         } else {
//             return;
//         }
//         this._mouseY = evt.clientY;
//         this.element.disabled = true;
//         this.element.blur();
//         this.element.classList.add('noSelect', 'active');
//         document.body.classList.add('noSelect');
//     }

//     this._dragDiff = this._mouseY - evt.clientY;

//     if (this.step !== 1)
//         this._dragDiff *= this.step;

//     if (this.precision !== null)
//         this._dragDiff = parseFloat(this._dragDiff.toFixed(this.precision));

//     this.value = this._dragStart + this._dragDiff;

//     evt.preventDefault();
//     evt.stopPropagation();
// };

Object.defineProperty(NumberField.prototype, 'value', {
    get: function() {
        if (this._link) {
            return this._link.get(this.path);
        } else {
            return this.elementInput.value !== '' ? parseFloat(this.elementInput.value, 10) : null;
        }
    },
    set: function(value) {
        if (this._link) {
            if (! this._link.set(this.path, value)) {
                this.elementInput.value = this._link.get(this.path);
            }
        } else {
            if (this.max !== null && this.max < value)
                value = this.max;

            if (this.min !== null && this.min > value)
                value = this.min;

            value = (value !== null && value !== undefined && (this.precision !== null) ? parseFloat(value.toFixed(this.precision), 10) : value);
            if (value === undefined)
                value = null;

            if (this._lastValue !== value) {
                this._lastValue = value;
                this.elementInput.value = value;
                this.emit('change', value);
            }
        }
    }
});


Object.defineProperty(NumberField.prototype, 'placeholder', {
    get: function() {
        return this.element.getAttribute('placeholder');
    },
    set: function(value) {
        if (! value) {
            this.element.removeAttribute('placeholder');
        } else {
            this.element.setAttribute('placeholder', value);
        }
    }
});


Object.defineProperty(NumberField.prototype, 'proxy', {
    get: function() {
        return this.element.getAttribute('proxy');
    },
    set: function(value) {
        if (! value) {
            this.element.removeAttribute('proxy');
        } else {
            this.element.setAttribute('proxy', value);
        }
    }
});


window.ui.NumberField = NumberField;


/* ui/overlay.js */
"use strict"

function Overlay(args) {
    ui.ContainerElement.call(this);
    args = args || { };

    this.element = document.createElement('div');
    this.element.classList.add('ui-overlay', 'center');

    this.elementOverlay = document.createElement('div');
    this.elementOverlay.classList.add('overlay', 'clickable');
    this.element.appendChild(this.elementOverlay);

    this.elementOverlay.addEventListener('mousedown', function(evt) {
        if (! this.clickable)
            return false;

        // some field might be in focus
        document.body.blur();

        // wait till blur takes in account
        setTimeout(function() {
            // hide overlay
            this.hidden = true;
        }.bind(this), 0);

        evt.preventDefault();
    }.bind(this), false);

    this.innerElement = document.createElement('div');
    this.innerElement.classList.add('content');
    this.element.appendChild(this.innerElement);
}
Overlay.prototype = Object.create(ui.ContainerElement.prototype);


Object.defineProperty(Overlay.prototype, 'center', {
    get: function() {
        return this._element.classList.contains('center');
    },
    set: function(value) {
        if (value) {
            this._element.classList.add('center');
            this.innerElement.style.left = '';
            this.innerElement.style.top = '';
        } else {
            this._element.classList.remove('center');
        }
    }
});


Object.defineProperty(Overlay.prototype, 'transparent', {
    get: function() {
        return this._element.classList.contains('transparent');
    },
    set: function(value) {
        if (value) {
            this._element.classList.add('transparent');
        } else {
            this._element.classList.remove('transparent');
        }
    }
});

Object.defineProperty(Overlay.prototype, 'clickable', {
    get: function() {
        return this.elementOverlay.classList.contains('clickable');
    },
    set: function(value) {
        if (value) {
            this.elementOverlay.classList.add('clickable');
        } else {
            this.elementOverlay.classList.remove('clickable');
        }
    }
});


Object.defineProperty(Overlay.prototype, 'rect', {
    get: function() {
        return this.innerElement.getBoundingClientRect();
    }
});


Overlay.prototype.position = function(x, y) {

    var area = this.elementOverlay.getBoundingClientRect();
    var rect = this.innerElement.getBoundingClientRect();

    x = Math.max(0, Math.min(area.width - rect.width, x));
    y = Math.max(0, Math.min(area.height - rect.height, y));

    this.innerElement.style.left = x + 'px';
    this.innerElement.style.top = y + 'px';
};


window.ui.Overlay = Overlay;


/* ui/panel.js */
"use strict";

function Panel(header) {
    var self = this;

    ui.ContainerElement.call(this);

    this.element = document.createElement('div');
    this.element.classList.add('ui-panel', 'noHeader', 'noAnimation');

    this.headerElement = null;
    this.headerElementTitle = null;

    if (header)
        this.header = header;

    this.on('nodesChanged', function() {
        if (! this.foldable || this.folded || this.horizontal || this.hidden)
            return;

        this.style.height = ((this.headerSize || 32) + this.innerElement.clientHeight) + 'px';
    });

    // content
    this.innerElement = document.createElement('div');
    this.innerElement.classList.add('content');
    this.element.appendChild(this.innerElement);

    this.innerElement.addEventListener('scroll', this._onScroll.bind(this), false);

    // HACK
    // skip 2 frames before enabling transitions
    requestAnimationFrame(function() {
        requestAnimationFrame(function() {
            this.class.remove('noAnimation');
        }.bind(this));
    }.bind(this));

    // on parent change
    this.on('parent', function() {
        // HACK
        // wait till DOM parses, then reflow
        requestAnimationFrame(this._reflow.bind(this));
    });

    this._handleElement = null;
    this._handle = null;
    this._resizeData = null;
    this._resizeLimits = {
        min: 0,
        max: Infinity
    };

    this.headerSize = 0;
}
Panel.prototype = Object.create(ui.ContainerElement.prototype);


Object.defineProperty(Panel.prototype, 'header', {
    get: function() {
        return (this.headerElement && this.headerElementTitle.textContent) || '';
    },
    set: function(value) {
        if (! this.headerElement && value) {
            this.headerElement = document.createElement('header');
            this.headerElement.classList.add('ui-header');

            this.headerElementTitle = document.createElement('span');
            this.headerElementTitle.classList.add('title');
            this.headerElementTitle.textContent = value;
            this.headerElement.appendChild(this.headerElementTitle);

            var first = this.element.firstChild;
            if (first) {
                this.element.insertBefore(this.headerElement, first);
            } else {
                this.element.appendChild(this.headerElement);
            }

            this.class.remove('noHeader');

            var self = this;

            // folding
            this.headerElement.addEventListener('click', function(evt) {
                if (! self.foldable || (evt.target !== self.headerElement && evt.target !== self.headerElementTitle))
                    return;

                self.folded = ! self.folded;
            }, false);
        } else if (! value && this.headerElement) {
            this.headerElement.parentNode.removeChild(this.headerElement);
            this.headerElement = null;
            this.headerElementTitle = null;
            this.class.add('noHeader');
        } else {
            this.headerElementTitle.textContent = value || '';
            this.class.remove('noHeader');
        }
    }
});


Panel.prototype.headerAppend = function(element) {
    if (! this.headerElement)
        return;

    var html = (element instanceof HTMLElement);
    var node = html ? element : element.element;

    this.headerElement.insertBefore(node, this.headerElementTitle);

    if (! html)
        element.parent = this;
};


Panel.prototype._reflow = function() {
    if (this.hidden)
        return;

    if (this.folded) {
        if (this.horizontal) {
            this.style.height = '';
            this.style.width = (this.headerSize || 32) + 'px';
        } else {
            this.style.height = (this.headerSize || 32) + 'px';
        }
    } else if (this.foldable) {
        if (this.horizontal) {
            this.style.height = '';
            this.style.width = this._innerElement.clientWidth + 'px';
        } else {
            this.style.height = ((this.headerSize || 32) + this._innerElement.clientHeight) + 'px';
        }
    }
};


Panel.prototype._onScroll = function(evt) {
    this.emit('scroll', evt);
};


Object.defineProperty(Panel.prototype, 'foldable', {
    get: function() {
        return this.class.contains('foldable');
    },
    set: function(value) {
        if (value) {
            this.class.add('foldable');

            if(this.class.contains('folded'))
                this.emit('fold');
        } else {
            this.class.remove('foldable');

            if (this.class.contains('folded'))
                this.emit('unfold');
        }

        this._reflow();
    }
});


Object.defineProperty(Panel.prototype, 'folded', {
    get: function() {
        return this.class.contains('foldable') && this.class.contains('folded');
    },
    set: function(value) {
        if (this.hidden)
            return;

        if (this.headerElement && this.headerSize === 0)
            this.headerSize = this.headerElement.clientHeight;

        if (value) {
            this.class.add('folded');

            if (this.class.contains('foldable'))
                this.emit('fold');
        } else {
            this.class.remove('folded');

            if (this.class.contains('foldable'))
                this.emit('unfold');
        }

        this._reflow();
    }
});


Object.defineProperty(Panel.prototype, 'horizontal', {
    get: function() {
        return this.class.contains('horizontal');
    },
    set: function(value) {
        if (value) {
            this.class.add('horizontal');
        } else {
            this.class.remove('horizontal');
        }
        this._reflow();
    }
});


Object.defineProperty(Panel.prototype, 'resizable', {
    get: function() {
        return this._handle;
    },
    set: function(value) {
        if (this._handle === value)
            return;

        var oldHandle = this._handle;
        this._handle = value;

        if (this._handle) {
            if (! this._handleElement) {
                this._handleElement = document.createElement('div');
                this._handleElement.classList.add('handle');
                this._handleElement.addEventListener('mousedown', this._resizeStart.bind(this), false);
                // this._handleElement.on('mouseup', this._resizeStart.bind(this));
            }

            if (this._handleElement.parentNode)
                this._element.removeChild(this._handleElement);
            // TODO
            // append in right place
            this._element.appendChild(this._handleElement);
            this.class.add('resizable', 'resizable-' + this._handle);
        } else {
            this._element.removeChild(this._handleElement);
            this.class.remove('resizable', 'resizable-' + oldHandle);
        }

        this._reflow();
    }
});


Object.defineProperty(Panel.prototype, 'resizeMin', {
    get: function() {
        return this._resizeLimits.min;
    },
    set: function(value) {
        this._resizeLimits.min = Math.max(0, Math.min(this._resizeLimits.max, value));
    }
});


Object.defineProperty(Panel.prototype, 'resizeMax', {
    get: function() {
        return this._resizeLimits.max;
    },
    set: function(value) {
        this._resizeLimits.max = Math.max(this._resizeLimits.min, value);
    }
});


Panel.prototype._resizeStart = function(evt) {
    if (! this._handle)
        return;

    this.class.add('noAnimation', 'resizing');
    this._resizeData = null;

    this._resizeEvtMove = this._resizeMove.bind(this);
    this._resizeEvtEnd = this._resizeEnd.bind(this);

    window.addEventListener('mousemove', this._resizeEvtMove, false);
    window.addEventListener('mouseup', this._resizeEvtEnd, false);

    evt.preventDefault();
    evt.stopPropagation();
};


Panel.prototype._resizeMove = function(evt) {
    if (! this._resizeData) {
        this._resizeData = {
            x: evt.clientX,
            y: evt.clientY,
            width: this._innerElement.clientWidth,
            height: this._innerElement.clientHeight
        };
    } else {
        if (this._handle === 'left' || this._handle === 'right') {
            // horizontal
            var offsetX = this._resizeData.x - evt.clientX;

            if (this._handle === 'right')
                offsetX = -offsetX;

            var width = Math.max(this._resizeLimits.min, Math.min(this._resizeLimits.max, (this._resizeData.width + offsetX)));

            this.style.width = (width + 4) + 'px';
            this._innerElement.style.width = (width + 4) + 'px';
        } else {
            // vertical
            var offsetY = this._resizeData.y - evt.clientY;

            if (this._handle === 'bottom')
                offsetY = -offsetY;

            var height = Math.max(this._resizeLimits.min, Math.min(this._resizeLimits.max, (this._resizeData.height + offsetY)));

            this.style.height = (height + (this.headerSize === -1 ? 0 : this.headerSize || 32)) + 'px';
            this._innerElement.style.height = height + 'px';
        }
    }

    evt.preventDefault();
    evt.stopPropagation();

    this.emit('resize');
};

Panel.prototype._resizeEnd = function(evt) {
    window.removeEventListener('mousemove', this._resizeEvtMove, false);
    window.removeEventListener('mouseup', this._resizeEvtEnd, false);

    this.class.remove('noAnimation', 'resizing');
    this._resizeData = null;

    evt.preventDefault();
    evt.stopPropagation();
};


window.ui.Panel = Panel;


/* ui/select-field.js */
"use strict";

function SelectField(args) {
    var self = this;
    ui.Element.call(this);
    args = args || { };

    this.options = args.options || { };
    this.optionsKeys = [ ];
    if (this.options instanceof Array) {
        var options = { };
        for(var i = 0; i < this.options.length; i++) {
            this.optionsKeys.push(this.options[i].v);
            options[this.options[i].v] = this.options[i].t;
        }
        this.options = options;
    } else {
        this.optionsKeys = Object.keys(this.options);
    }

    this.element = document.createElement('div');
    this.element.tabIndex = 0;
    this.element.classList.add('ui-select-field', 'noSelect');

    this.elementValue = document.createElement('div');
    this.elementValue.classList.add('value');
    this.element.appendChild(this.elementValue);

    this._oldValue = null;
    this._value = null;
    this._number = !! args.number;

    this.timerClickAway = null;
    this.evtMouseDist = [ 0, 0 ];
    this.evtMouseUp = function(evt) {
        evt.preventDefault();
        evt.stopPropagation();

        if (evt.target && evt.target.uiElement && evt.target.classList.contains('selected'))
            return;

        if ((Math.abs(evt.clientX - self.evtMouseDist[0]) + Math.abs(evt.clientY - self.evtMouseDist[1])) < 8)
            return;

        if (evt.target && evt.target.uiElement)
            self._onOptionSelect.call(evt.target);

        self.close();
    };

    this.elementValue.addEventListener('mousedown', function(evt) {
        if (self.disabled)
            return;

        if (self.element.classList.contains('active')) {
            self.close();
        } else {
            evt.preventDefault();
            evt.stopPropagation();
            self.evtMouseDist[0] = evt.clientX;
            self.evtMouseDist[1] = evt.clientY;
            self.element.focus();
            self.open();
            window.addEventListener('mouseup', self.evtMouseUp);
        }
    });

    this.elementOptions = document.createElement('ul');
    this.element.appendChild(this.elementOptions);

    this.optionElements = { };

    if (args.default !== undefined && this.options[args.default] !== undefined) {
        this._value = args.default;
        if (this._number)
            this._value = parseInt(this._value, 10);
        this._oldValue = this._value;
    }

    this._optionSelectHandler = null;

    this.on('link', function(path) {
        if (this._link.schema && this._link.schema.has(path)) {
            var field = this._link.schema.get(path);
            var options = field.options || { };
            this._updateOptions(options);
        }
    });

    this._updateOptions();

    this.on('change', function() {
        if (! this.renderChanges)
            return;

        this.flash();
    });

    // arrows - change
    this.element.addEventListener('keydown', function(evt) {
        if (evt.keyCode === 27) {
            self.close();
            self.element.blur();
            return;
        }

        if (self.disabled || [ 38, 40 ].indexOf(evt.keyCode) === -1)
            return;

        evt.stopPropagation();
        evt.preventDefault();

        var keys = Object.keys(self.options);
        var ind = keys.indexOf(self.value !== undefined ? self.value.toString() : null);

        var y = evt.keyCode === 38 ? -1 : 1;

        // already first item
        if (y === -1 && ind <= 0)
            return;

        // already last item
        if (y === 1 && ind === (keys.length - 1))
            return

        // set new item
        self.value = keys[ind + y];
    }, false);
}
SelectField.prototype = Object.create(ui.Element.prototype);


SelectField.prototype.open = function() {
    if (this.disabled || this.element.classList.contains('active'))
        return;

    this.element.classList.add('active');

    var rect = this.element.getBoundingClientRect();

    // left
    var left = Math.round(rect.left) + ((Math.round(rect.width) - this.element.clientWidth) / 2);

    // top
    var top = rect.top;
    if (this.optionElements[this._value]) {
        top -= this.optionElements[this._value].offsetTop;
        top += (Math.round(rect.height) - this.optionElements[this._value].clientHeight) / 2;
    }

    // limit to bottom / top of screen
    if (top + this.elementOptions.clientHeight > window.innerHeight) {
        top = window.innerHeight - this.elementOptions.clientHeight + 1;
    } else if (top < 0) {
        top = Math.round(rect.top);
    }

    this.elementOptions.style.top = top + 'px';
    // left
    this.elementOptions.style.left = left + 'px';
    // right
    this.elementOptions.style.width = Math.round(this.element.clientWidth) + 'px';


    var self = this;
    this.timerClickAway = setTimeout(function() {
        var looseActive = function() {
            self.element.classList.remove('active');
            self.element.blur();
            window.removeEventListener('click', looseActive);
        };

        window.addEventListener('click', looseActive);
    }, 300);

    this.emit('open');
};


SelectField.prototype.close = function() {
    if (this.disabled || ! this.element.classList.contains('active'))
        return;

    window.removeEventListener('mouseup', this.evtMouseUp);
    if (this.timerClickAway) {
        clearTimeout(this.timerClickAway);
        this.timerClickAway = null;
    }

    this.element.classList.remove('active');

    this.emit('close');
};


SelectField.prototype.toggle = function() {
    if (this.element.classList.contains('active')) {
        this.close();
    } else {
        this.open();
    }
};


SelectField.prototype._updateOptions = function(options) {
    if (options !== undefined) {
        if (options instanceof Array) {
            this.options = { };
            this.optionsKeys = [ ];
            for(var i = 0; i < options.length; i++) {
                this.optionsKeys.push(options[i].v);
                this.options[options[i].v] = options[i].t;
            }
        } else {
            this.options = options;
            this.optionsKeys = Object.keys(options);
        }
    }

    if (! this._optionSelectHandler)
        this._optionSelectHandler = this._onOptionSelect.bind(this);

    for(var value in this.optionElements) {
        this.optionElements[value].removeEventListener('click', this._onOptionSelect);
    }

    this.optionElements = { };
    this.elementOptions.innerHTML = '';

    for(var i = 0; i < this.optionsKeys.length; i++) {
        if (! this.options.hasOwnProperty(this.optionsKeys[i]))
            continue;

        var element = document.createElement('li');
        element.textContent = this.options[this.optionsKeys[i]];
        element.uiElement = this;
        element.uiValue = this.optionsKeys[i];
        element.addEventListener('click', this._onOptionSelect);
        element.addEventListener('mouseover', this._onOptionHover);
        element.addEventListener('mouseout', this._onOptionOut);
        this.elementOptions.appendChild(element);
        this.optionElements[this.optionsKeys[i]] = element;
    }
};

SelectField.prototype._onOptionSelect = function() {
    this.uiElement.value = this.uiValue;
};

SelectField.prototype._onOptionHover = function() {
    this.classList.add('hover');
};

SelectField.prototype._onOptionOut = function() {
    this.classList.remove('hover');
};

SelectField.prototype._onLinkChange = function(value) {
    if (this.optionElements[value] === undefined)
        return;

    if (this.optionElements[this._oldValue]) {
        this.optionElements[this._oldValue].classList.remove('selected');
    }

    this._value = value;
    if (this._number)
        this._value = parseInt(this._value, 10);
    this.elementValue.textContent = this.options[value];
    this.optionElements[value].classList.add('selected');
    this.emit('change', value);
};


Object.defineProperty(SelectField.prototype, 'value', {
    get: function() {
        if (this._link) {
            return this._link.get(this.path);
        } else {
            return this._value;
        }
    },
    set: function(value) {
        if (this._number)
            value = parseInt(value, 10);

        if (this._link) {
            this._oldValue = this._value;
            this.emit('change:before', value);
            this._link.set(this.path, value);
        } else {
            if (this._number && isNaN(value) && this.optionElements[''])
                value = '';

            if (this._value === value) return;
            if (value !== null && this.options[value] === undefined) return;

            // deselect old one
            if (this.optionElements[this._oldValue])
                this.optionElements[this._oldValue].classList.remove('selected');

            this._value = value;
            if (this._number && value !== '')
                this._value = parseInt(this._value, 10);

            this.emit('change:before', this._value);
            this._oldValue = this._value;
            if (this.options[this._value]) {
                this.elementValue.textContent = this.options[this._value];
                this.optionElements[this._value].classList.add('selected');
            } else {
                this.elementValue.textContent = '';
            }
            this.emit('change', this._value);
        }
    }
});


window.ui.SelectField = SelectField;


/* ui/text-field.js */
"use strict";

function TextField(args) {
    ui.Element.call(this);
    args = args || { };

    this.element = document.createElement('div');
    this.element.classList.add('ui-text-field');

    this.elementInput = document.createElement('input');
    this.elementInput.classList.add('field');
    this.elementInput.type = 'text';
    this.elementInput.tabIndex = 0;
    this.elementInput.addEventListener('focus', this._onInputFocus.bind(this), false);
    this.elementInput.addEventListener('blur', this._onInputBlur.bind(this), false);
    this.element.appendChild(this.elementInput);

    if (args.default !== undefined)
        this.value = args.default;

    this.elementInput.addEventListener('change', this._onChange.bind(this), false);
    this.elementInput.addEventListener('keydown', this._onKeyDown.bind(this), false);
    this.evtKeyChange = false;

    this.on('disable', function() {
        this.elementInput.disabled = true;
    });
    this.on('enable', function() {
        this.elementInput.disabled = false;
    });

    this.on('change', function() {
        if (! this.renderChanges)
            return;

        this.flash();
    });

    if (args.placeholder)
        this.placeholder = args.placeholder;
}
TextField.prototype = Object.create(ui.Element.prototype);


TextField.prototype._onLinkChange = function(value) {
    this.elementInput.value = value;
    this.emit('change', value);
};


TextField.prototype._onChange = function() {
    this.value = this.elementInput.value || '';

    if (! this._link)
        this.emit('change', this.value);
};


TextField.prototype._onKeyDown = function(evt) {
    if (evt.keyCode === 27)
        this.elementInput.blur();
};


TextField.prototype._onInputFocus = function() {
    this.class.add('focus');
};


TextField.prototype._onInputBlur = function() {
    this.class.remove('focus');
};


Object.defineProperty(TextField.prototype, 'value', {
    get: function() {
        if (this._link) {
            return this._link.get(this.path);
        } else {
            return this.elementInput.value;
        }
    },
    set: function(value) {
        if (this._link) {
            if (! this._link.set(this.path, value)) {
                this.elementInput.value = this._link.get(this.path);
            }
        } else {
            if (this.elementInput.value === value)
                return;

            this.elementInput.value = value || '';
            this.emit('change', value);
        }
    }
});


Object.defineProperty(TextField.prototype, 'placeholder', {
    get: function() {
        return this.element.getAttribute('placeholder');
    },
    set: function(value) {
        if (! value) {
            this.element.removeAttribute('placeholder');
        } else {
            this.element.setAttribute('placeholder', value);
        }
    }
});


Object.defineProperty(TextField.prototype, 'proxy', {
    get: function() {
        return this.element.getAttribute('proxy');
    },
    set: function(value) {
        if (! value) {
            this.element.removeAttribute('proxy');
        } else {
            this.element.setAttribute('proxy', value);
        }
    }
});


Object.defineProperty(TextField.prototype, 'keyChange', {
    get: function() {
        return !! this.evtKeyChange;
    },
    set: function(value) {
        if (!! this.evtKeyChange === !! value)
            return;

        if (value) {
            var self = this;
            this.evtKeyChange = function() {
                self._onChange();
            };
            this.elementInput.addEventListener('keyup', this.evtKeyChange, false);
        } else {
            this.elementInput.removeEventListener('keyup', this.evtKeyChange);
            this.evtKeyChange = null;
        }
    }
});


window.ui.TextField = TextField;


/* ui/color-field.js */
"use strict"

function ColorField(args) {
    var self = this;
    ui.Element.call(this);
    args = args || { };

    this.element = document.createElement('div');
    this.element.tabIndex = 0;
    this.element.classList.add('ui-color-field', 'rgb');

    this.elementColor = document.createElement('span');
    this.elementColor.classList.add('color');
    this.element.appendChild(this.elementColor);

    this._channels = args.channels || 3;
    this._values = [ 0, 0, 0, 0 ];

    // space > click
    this.element.addEventListener('keydown', function(evt) {
        if (evt.keyCode === 27)
            return self.element.blur();

        if (evt.keyCode !== 32 || self.disabled)
            return;

        evt.stopPropagation();
        evt.preventDefault();
        self.emit('click');
    }, false);

    // render color back
    this.on('change', function(color) {
        if (this._channels === 1) {
            this.elementColor.style.backgroundColor = 'rgb(' + [ this.r, this.r, this.r ].join(',') + ')';
        } else if (this._channels === 3) {
            this.elementColor.style.backgroundColor = 'rgb(' + this._values.slice(0, 3).join(',') + ')';
        } else if (this._channels === 4) {
            var rgba = this._values.slice(0, 4);
            rgba[3] /= 255;
            this.elementColor.style.backgroundColor = 'rgba(' + rgba.join(',') + ')';
        } else {
            console.log('unknown channels', color);
        }
    });

    // link to channels
    var evtLinkChannels = [ ];
    this.on('link', function() {
        for(var i = 0; i < 4; i++) {
            evtLinkChannels[i] = this._link.on(this.path + '.' + i + ':set', function(value) {
                this._setValue(this._link.get(this.path));
            }.bind(this));
        }
    });
    this.on('unlink', function() {
        for(var i = 0; i < evtLinkChannels.length; i++)
            evtLinkChannels[i].unbind();

        evtLinkChannels = [ ];
    });
}
ColorField.prototype = Object.create(ui.Element.prototype);


ColorField.prototype._onLinkChange = function(value) {
    if (! value)
        return;

    this._setValue(value);
};

Object.defineProperty(ColorField.prototype, 'value', {
    get: function() {
        if (this._link) {
            return this._link.get(this.path).map(function(channel) {
                return Math.floor(channel * 255);
            });
        } else {
            return this._values.slice(0, this._channels);
        }
    },
    set: function(value) {
        if (! value) {
            this.class.add('null');
            return;
        } else {
            this.class.remove('null');
        }

        if (this._link) {
            this._link.set(this.path, value.map(function(channel) {
                return channel / 255;
            }));
        } else {
            this._setValue(value);
        }
    }
});

ColorField.prototype._setValue = function(value) {
    var changed = false;

    if (! value)
        return;

    if (value.length !== this._channels) {
        changed = true;
        this.channels = value.length;
    }

    for(var i = 0; i < this._channels; i++) {
        if (this._values[i] === Math.floor(value[i]))
            continue;

        changed = true;
        this._values[i] = Math.floor(value[i]);
    }

    if (changed)
        this.emit('change', this._values.slice(0, this._channels));
};


Object.defineProperty(ColorField.prototype, 'channels', {
    get: function() {
        return this._channels;
    },
    set: function(value) {
        if (this._channels === value)
            return;

        this._channels = value;
        this.emit('channels', this._channels);
    }
});


Object.defineProperty(ColorField.prototype, 'r', {
    get: function() {
        if (this._link) {
            return Math.floor(this._link.get(this.path + '.0') * 255);
        } else {
            return this._values[0];
        }
    },
    set: function(value) {
        value = Math.min(0, Math.max(255, value));

        if (this._values[0] === value)
            return;

        this._values[0] = value;
        this.emit('r', this._values[0]);
        this.emit('change', this._values.slice(0, this._channels));
    }
});


Object.defineProperty(ColorField.prototype, 'g', {
    get: function() {
        if (this._link) {
            return Math.floor(this._link.get(this.path + '.1') * 255);
        } else {
            return this._values[1];
        }
    },
    set: function(value) {
        value = Math.min(0, Math.max(255, value));

        if (this._values[1] === value)
            return;

        this._values[1] = value;

        if (this._channels >= 2) {
            this.emit('g', this._values[1]);
            this.emit('change', this._values.slice(0, this._channels));
        }
    }
});


Object.defineProperty(ColorField.prototype, 'b', {
    get: function() {
        if (this._link) {
            return Math.floor(this._link.get(this.path + '.2') * 255);
        } else {
            return this._values[2];
        }
    },
    set: function(value) {
        value = Math.min(0, Math.max(255, value));

        if (this._values[2] === value)
            return;

        this._values[2] = value;

        if (this._channels >= 3) {
            this.emit('b', this._values[2]);
            this.emit('change', this._values.slice(0, this._channels));
        }
    }
});


Object.defineProperty(ColorField.prototype, 'a', {
    get: function() {
        if (this._link) {
            return Math.floor(this._link.get(this.path + '.3') * 255);
        } else {
            return this._values[3];
        }
    },
    set: function(value) {
        value = Math.min(0, Math.max(255, value));

        if (this._values[3] === value)
            return;

        this._values[3] = value;

        if (this._channels >= 4) {
            this.emit('a', this._values[3]);
            this.emit('change', this._values.slice(0, this._channels));
        }
    }
});


Object.defineProperty(ColorField.prototype, 'hex', {
    get: function() {
        var values = this._values;

        if (this._link) {
            values = this._link.get(this.path).map(function(channel) {
                return Math.floor(channel * 255);
            });
        }

        var hex = '';
        for(var i = 0; i < this._channels; i++) {
            hex += ('00' + values[i].toString(16)).slice(-2);
        }
        return hex;
    },
    set: function(value) {
        console.log('todo');
    }
});


window.ui.ColorField = ColorField;


/* ui/image-field.js */
"use strict";

function ImageField(args) {
    var self = this;
    ui.Element.call(this);
    args = args || { };

    this.element = document.createElement('div');
    this.element.tabIndex = 0;
    this.element.classList.add('ui-image-field', 'empty');

    this.elementImage = new Image();
    this.elementImage.classList.add('preview');
    this.element.appendChild(this.elementImage);

    this._value = null;

    this.element.removeEventListener('click', this._evtClick);
    this.element.addEventListener('click', function(evt) {
        self.emit('click', evt);
    });

    this.on('change', function() {
        if (! this.renderChanges)
            return;

        this.flash();
    });

    // space > click
    this.element.addEventListener('keydown', function(evt) {
        if (evt.keyCode === 27)
            return self.element.blur();

        if (evt.keyCode !== 32 || self.disabled)
            return;

        evt.stopPropagation();
        evt.preventDefault();
        self.emit('pick');
    }, false);
}
ImageField.prototype = Object.create(ui.Element.prototype);


ImageField.prototype._onLinkChange = function(value) {
    this._value = value;
    this.emit('change', value);
};


Object.defineProperty(ImageField.prototype, 'image', {
    get: function() {
        return this.elementImage.src;
    },
    set: function(value) {
        if (this.elementImage.src === value)
            return;

        this.elementImage.src = value;
    }
});


Object.defineProperty(ImageField.prototype, 'empty', {
    get: function() {
        return this.class.contains('empty');
    },
    set: function(value) {
        if (this.class.contains('empty') === !! value)
            return;

        if (value) {
            this.class.add('empty');
            this.image = '';
        } else {
            this.class.remove('empty');
        }
    }
});


Object.defineProperty(ImageField.prototype, 'value', {
    get: function() {
        if (this._link) {
            return this._link.get(this.path);
        } else {
            return this._value;
        }
    },
    set: function(value) {
        value = value && parseInt(value, 10) || null;

        if (this._link) {
            if (! this._link.set(this.path, value))
                this._value = this._link.get(this.path);
        } else {
            if (this._value === value && ! this.class.contains('null'))
                return;

            this._value = value;
            this.emit('change', value);
        }
    }
});


window.ui.ImageField = ImageField;


/* ui/slider.js */
"use strict";

function Slider(args) {
    var self = this;
    ui.Element.call(this);
    args = args || { };

    this._value = 0;
    this._lastValue = 0;

    this.precision = isNaN(args.precision) ? 2 : args.precision;
    this._min = isNaN(args.min) ? 0 : args.min;
    this._max = isNaN(args.max) ? 1 : args.max;

    this.element = document.createElement('div');
    this.element.classList.add('ui-slider');

    this.elementBar = document.createElement('div');
    this.elementBar.classList.add('bar');
    this.element.appendChild(this.elementBar);

    this.elementHandle = document.createElement('div');
    this.elementHandle.tabIndex = 0;
    this.elementHandle.classList.add('handle');
    this.elementBar.appendChild(this.elementHandle);

    this.element.addEventListener('mousedown', this._onMouseDown.bind(this), false);
    this.evtMouseMove = null;
    this.evtMouseUp = null;

    this.on('change', function() {
        if (! this.renderChanges)
            return;

        this.flash();
    });

    // arrows - change
    this.element.addEventListener('keydown', function(evt) {
        if (evt.keyCode === 27)
            return self.elementHandle.blur();

        if (self.disabled || [ 37, 39 ].indexOf(evt.keyCode) === -1)
            return;

        evt.stopPropagation();
        evt.preventDefault();

        var x = evt.keyCode === 37 ? -1 : 1;

        if (evt.shiftKey)
            x *= 10;

        var rect = self.element.getBoundingClientRect();
        var step = (self._max - self._min) / rect.width;
        var value = Math.max(self._min, Math.min(self._max, self.value + x * step));
        value = parseFloat(value.toFixed(self.precision), 10);

        self.renderChanges = false;
        self._updateHandle(value);
        self.value = value;
        self.renderChanges = true;
    }, false);
}
Slider.prototype = Object.create(ui.Element.prototype);


Slider.prototype._onLinkChange = function(value) {
    this._updateHandle(value);
    this._value = value;
    this.emit('change', value || 0);
};


Slider.prototype._updateHandle = function(value) {
    this.elementHandle.style.left = (Math.max(0, Math.min(1, (value || 0) / (this._max - this._min))) * 100) + '%';
};


Slider.prototype._handleEvt = function(evt) {
    evt.stopPropagation();
    evt.preventDefault();

    var rect = this.element.getBoundingClientRect();
    var x = Math.max(0, Math.min(1, (evt.clientX - rect.left) / rect.width));

    var range = this._max - this._min;
    var value = (x * range);
    value = parseFloat(value.toFixed(this.precision), 10);

    this._updateHandle(value);
    this.value = value;
};


Slider.prototype._onMouseDown = function(evt) {
    if (evt.button !== 0 || this.disabled)
        return;

    this.elementHandle.focus();

    this.renderChanges = false;

    this.evtMouseMove = this._onMouseMove.bind(this);
    window.addEventListener('mousemove', this.evtMouseMove, false);

    this.evtMouseUp = this._onMouseUp.bind(this);
    window.addEventListener('mouseup', this.evtMouseUp, false);

    this.class.add('active');

    this.emit('start', this.value);

    this._handleEvt(evt);

    if (this._link && this._link.history)
        this._link.history.combine = true;
};


Slider.prototype._onMouseMove = function(evt) {
    this._handleEvt(evt);
};


Slider.prototype._onMouseUp = function(evt) {
    this._handleEvt(evt);

    this.renderChanges = true;

    this.class.remove('active');

    window.removeEventListener('mousemove', this.evtMouseMove);
    window.removeEventListener('mouseup', this.evtMouseUp);

    if (this._link && this._link.history)
        this._link.history.combine = false;

    this.emit('end', this.value);
};


Object.defineProperty(Slider.prototype, 'min', {
    get: function() {
        return this._min;
    },
    set: function(value) {
        if (this._min === value)
            return;

        this._min = value;
        this._updateHandle(this._value);
    }
});


Object.defineProperty(Slider.prototype, 'max', {
    get: function() {
        return this._max;
    },
    set: function(value) {
        if (this._max === value)
            return;

        this._max = value;
        this._updateHandle(this._value);
    }
});


Object.defineProperty(Slider.prototype, 'value', {
    get: function() {
        if (this._link) {
            return this._link.get(this.path);
        } else {
            return this._value;
        }
    },
    set: function(value) {
        if (this._link) {
            if (! this._link.set(this.path, value))
                this._updateHandle(this._link.get(this.path));
        } else {
            if (this._max !== null && this._max < value)
                value = this._max;

            if (this._min !== null && this._min > value)
                value = this._min;

            if (value === null) {
                this.class.add('null');
            } else {
                if (typeof value !== 'number')
                    value = undefined;

                value = (value !== undefined && this.precision !== null) ? parseFloat(value.toFixed(this.precision), 10) : value;
                this.class.remove('null');
            }

            this._updateHandle(value);
            this._value = value;

            if (this._lastValue !== value) {
                this._lastValue = value;
                this.emit('change', value);
            }
        }
    }
});


window.ui.Slider = Slider;


/* ui/progress.js */
"use strict";

function Progress(args) {
    ui.Element.call(this);
    args = args || { };

    this._progress = 0;

    if (args.progress)
        this._progress = Math.max(0, Math.min(1, args.progress));

    this._targetProgress = this._progress;

    this._lastProgress = Math.floor(this._progress * 100);

    this.element = document.createElement('div');
    this.element.classList.add('ui-progress');

    this._inner = document.createElement('div');
    this._inner.classList.add('inner');
    this._inner.style.width = (this._progress * 100) + '%';
    this.element.appendChild(this._inner);

    this._speed = args.speed || 1;

    this._now = Date.now();
    this._animating = false;

    this._failed = false;

    var self = this;
    this._animateHandler = function() {
        self._animate();
    };
}
Progress.prototype = Object.create(ui.Element.prototype);


Object.defineProperty(Progress.prototype, 'progress', {
    get: function() {
        return this._progress;
    },
    set: function(value) {
        value = Math.max(0, Math.min(1, value));

        if (this._targetProgress === value)
            return;

        this._targetProgress = value;

        if (this._speed === 0 || this._speed === 1) {
            this._progress = this._targetProgress;
            this._inner.style.width = (this._progress * 100) + '%';

            var progress = Math.max(0, Math.min(100, Math.round(this._progress * 100)));
            if (progress !== this._lastProgress) {
                this._lastProgress = progress;
                this.emit('progress:' + progress);
                this.emit('progress', progress);
            }
        } else if (! this._animating) {
            requestAnimationFrame(this._animateHandler);
        }
    }
});


Object.defineProperty(Progress.prototype, 'speed', {
    get: function() {
        return this._speed;
    },
    set: function(value) {
        this._speed = Math.max(0, Math.min(1, value));
    }
});


Object.defineProperty(Progress.prototype, 'failed', {
    get: function() {
        return this._failed;
    },
    set: function(value) {
        this._failed = !! value;

        if (this._failed) {
            this.class.add('failed');
        } else {
            this.class.remove('failed');
        }
    }
});


Progress.prototype._animate = function() {
    if (Math.abs(this._targetProgress - this._progress) < 0.01) {
        this._progress = this._targetProgress;
        this._animating = false;
    } else {
        if (! this._animating) {
            this._now = Date.now() - (1000 / 60);
            this._animating = true;
        }
        requestAnimationFrame(this._animateHandler);

        var dt = Math.max(0.1, Math.min(3, (Date.now() - this._now) / (1000 / 60)));
        this._now = Date.now();
        this._progress = this._progress + ((this._targetProgress - this._progress) * (this._speed * dt));
    }

    var progress = Math.max(0, Math.min(100, Math.round(this._progress * 100)));
    if (progress !== this._lastProgress) {
        this._lastProgress = progress;
        this.emit('progress:' + progress);
        this.emit('progress', progress);
    }

    this._inner.style.width = (this._progress * 100) + '%';
};


window.ui.Progress = Progress;


/* ui/list.js */
"use strict";

function List(args) {
    args = args || { };
    ui.ContainerElement.call(this);

    this.element = document.createElement('ul');
    this.element.classList.add('ui-list');
    this.selectable = args.selectable !== undefined ? args.selectable : true;

    this.on('select', this._onSelect);
}
List.prototype = Object.create(ui.ContainerElement.prototype);


List.prototype._onSelect = function(item) {
    var items = this.element.querySelectorAll('.ui-list-item.selected');

    if (items.length > 1) {
        for(var i = 0; i < items.length; i++) {
            if (items[i].ui === item)
                continue;

            items[i].ui.selected = false;
        }
    }
};


Object.defineProperty(List.prototype, 'selectable', {
    get: function() {
        return this._selectable;
    },
    set: function(value) {
        if (this._selectable === !! value)
            return;

        this._selectable = value;

        if (this._selectable) {
            this.class.add('selectable');
        } else {
            this.class.remove('selectable');
        }
    }
});


Object.defineProperty(List.prototype, 'selected', {
    get: function() {
        var items = [ ];
        var elements = this.element.querySelectorAll('.ui-list-item.selected');

        for(var i = 0; i < elements.length; i++) {
            items.push(elements[i].ui);
        }

        return items;
    },
    set: function(value) {
        // deselecting
        var items = this.selected;
        for(var i = 0; i < items.length; i++) {
            if (value.indexOf(items[i]) !== -1)
                continue;
            items[i].selected = false;
        }

        // selecting
        for(var i = 0; i < value.length; i++) {
            value[i].selected = true;
        }
    }
});


window.ui.List = List;


/* ui/list-item.js */
"use strict";

function ListItem(args) {
    ui.Element.call(this);
    args = args || { };

    this._text = args.text || '';
    this._selected = args.selected || false;

    this.element = document.createElement('li');
    this.element.classList.add('ui-list-item');

    this.elementText = document.createElement('span');
    this.elementText.textContent = this._text;
    this.element.appendChild(this.elementText);

    this.on('click', this._onClick);
}
ListItem.prototype = Object.create(ui.Element.prototype);


ListItem.prototype._onClick = function() {
    this.selected = ! this.selected;
};


Object.defineProperty(ListItem.prototype, 'text', {
    get: function() {
        return this._text;
    },
    set: function(value) {
        if (this._text === value) return;
        this._text = value;
        this.elementText.textContent = this._text;
    }
});


Object.defineProperty(ListItem.prototype, 'selected', {
    get: function() {
        return this._selected;
    },
    set: function(value) {
        if (this._selected === value)
            return;

        this._selected = value;

        if (this._selected) {
            this.element.classList.add('selected');
        } else {
            this.element.classList.remove('selected');
        }

        this.emit(this.selected ? 'select' : 'deselect');
        this.emit('change', this.selected);

        if (this.parent) {
            this.parent.emit(this.selected ? 'select' : 'deselect', this);
        }
    }
});


window.ui.ListItem = ListItem;


/* ui/grid.js */
"use strict";

function Grid() {
    var self = this;
    ui.ContainerElement.call(this);

    this.element = document.createElement('ul');
    this.element.tabIndex = 0;
    this.element.classList.add('ui-grid');

    this._lastSelect = null;
    this._selecting = false;

    this.on('select', this._onSelect);
    this.on('beforeDeselect', this._onBeforeDeselect);

    this.on('append', this._onAppend);
    this.on('remove', this._onRemove);
}
Grid.prototype = Object.create(ui.ContainerElement.prototype);


Grid.prototype._onSelect = function(item) {
    if (this._selecting)
        return;

    if (Grid._shift && Grid._shift()) {
        // multi select from-to
        if (this._lastSelect) {
            this._selecting = true;

            var children = Array.prototype.slice.call(this.element.children, 0);

            var startInd = children.indexOf(this._lastSelect.element);
            var endInd = children.indexOf(item.element);

            // swap if backwards
            if (startInd > endInd) {
                var t = startInd;
                startInd = endInd;
                endInd = t;
            }

            for(var i = startInd; i < endInd; i++) {
                if (children[i].ui.hidden)
                    continue;

                children[i].ui.selected = true;
            }

            this._selecting = false;
        } else {
            this._lastSelect = item;
        }
    } else if (Grid._ctrl && Grid._ctrl()) {
        // multi select
        this._lastSelect = item;
    } else {
        // single select
        var items = this.element.querySelectorAll('.ui-grid-item.selected');

        if (items.length > 1) {
            for(var i = 0; i < items.length; i++) {
                if (items[i].ui === item)
                    continue;

                items[i].ui.selected = false;
            }
        }

        this._lastSelect = item;
    }
};


Grid.prototype._onBeforeDeselect = function(item) {
    if (this._selecting)
        return;

    this._selecting = true;

    if (Grid._shift && Grid._shift()) {
        this._lastSelect = null;
    } else if (Grid._ctrl && Grid._ctrl()) {
        this._lastSelect = null;
    } else {
        var items = this.element.querySelectorAll('.ui-grid-item.selected');
        if (items.length > 1) {
            for(var i = 0; i < items.length; i++) {
                if (items[i].ui === item)
                    continue;
                items[i].ui.selected = false;
            }
            item._selectPending = true;
            this._lastSelect = item;
        }
    }

    this._selecting = false;
};


Grid.prototype.filter = function(fn) {
    this.forEach(function(item) {
        item.hidden = ! fn(item);
    });
};


Grid.prototype.forEach = function(fn) {
    var child = this.element.firstChild;
    while(child) {
        if (child.ui)
            fn(child.ui);

        child = child.nextSibling;
    };
};

Object.defineProperty(Grid.prototype, 'selected', {
    get: function() {
        var items = [ ];
        var elements = this.element.querySelectorAll('.ui-grid-item.selected');

        for(var i = 0; i < elements.length; i++)
            items.push(elements[i].ui);

        return items;
    },
    set: function(value) {
        if (this._selecting)
            return;

        this._selecting = true;

        // deselecting
        var items = this.selected;
        for(var i = 0; i < items.length; i++) {
            if (value && value.indexOf(items[i]) !== -1)
                continue;
            items[i].selected = false;
        }

        if (! value)
            return;

        // selecting
        for(var i = 0; i < value.length; i++) {
            if (! value[i])
                continue;

            value[i].selected = true;
        }

        this._selecting = false;
    }
});


window.ui.Grid = Grid;


/* ui/grid-item.js */
"use strict";

function GridItem(args) {
    var self = this;
    ui.Element.call(this);
    args = args || { };

    this._text = args.text || '';
    this._selectPending = false;
    this._selected = args.selected || false;
    this._clicked = false;

    this.element = document.createElement('li');
    this.element.tabIndex = 0;
    this.element.classList.add('ui-grid-item');
    this.element.innerHTML = this._text;

    this.element.removeEventListener('click', this._evtClick);
    this.element.addEventListener('click', this._onClick.bind(this), false);

    // this._dragRelease = null;
    // this._dragging = false;
    // this.element.addEventListener('dragstart', this._onDragStart.bind(this), false);
    // this.element.addEventListener('mouseover', this._onMouseOver.bind(this), false);

    // space > click
    this.element.addEventListener('keydown', function(evt) {
        if (evt.keyCode !== 32 || self.disabled)
            return;

        evt.stopPropagation();
        evt.preventDefault();
        self._onClick();
    }, false);

    this.on('select', function() {
        this.element.focus();
    });

    this.on('deselect', function() {
        this.element.blur();
    });
}
GridItem.prototype = Object.create(ui.Element.prototype);


GridItem.prototype._onClick = function() {
    this.emit('click');
    this._clicked = true;
    this.selected = ! this.selected;
    this._clicked = false;
};


// GridItem.prototype._onDragStart = function(evt) {
//     if (this.parent.disabled) {
//         evt.stopPropagation();
//         evt.preventDefault();
//         return;
//     }

//     this._dragging = true;

//     if (this._dragRelease)
//         window.removeEventListener('mouseup', this._dragRelease);

//     this._dragRelease = this._onMouseUp.bind(this);
//     window.addEventListener('mouseup', this._dragRelease, false);

//     evt.stopPropagation();
//     evt.preventDefault();

//     this.emit('dragstart');
// };


// GridItem.prototype._onMouseOver = function(evt) {
//     evt.stopPropagation();
//     this.emit('mouseover', evt);
// };

// GridItem.prototype._onMouseUp = function(evt) {
//     window.removeEventListener('mouseup', this._dragRelease);
//     this._dragRelease = null;

//     evt.preventDefault();
//     evt.stopPropagation();

//     this._dragging = false;
//     this.emit('dragend');
// };


Object.defineProperty(GridItem.prototype, 'text', {
    get: function() {
        return this._text;
    },
    set: function(value) {
        if (this._text === value) return;
        this._text = value;
        this.element.innerHTML = this._text;
    }
});


Object.defineProperty(GridItem.prototype, 'selected', {
    get: function() {
        return this._selected;
    },
    set: function(value) {
        if (this._selected === value)
            return;

        this._selectPending = value;
        if (this.parent && this._clicked)
            this.parent.emit('before' + (value ? 'Select' : 'Deselect'), this, this._clicked);
        if (this._selected === this._selectPending)
            return;

        this._selected = this._selectPending;

        if (this._selected) {
            this.element.classList.add('selected');
        } else {
            this.element.classList.remove('selected');
        }

        this.emit(this.selected ? 'select' : 'deselect');
        this.emit('change', this.selected);

        if (this.parent)
            this.parent.emit(this.selected ? 'select' : 'deselect', this, this._clicked);
    }
});


window.ui.GridItem = GridItem;


/* ui/tree.js */
"use strict";

function Tree() {
    ui.ContainerElement.call(this);

    this.element = document.createElement('div');
    this.element.classList.add('ui-tree');

    this.elementDrag = document.createElement('div');
    this.elementDrag.classList.add('drag-handle');
    this.element.appendChild(this.elementDrag);

    var self = this;
    this.elementDrag.addEventListener('mousemove', function(evt) {
        evt.preventDefault();
        evt.stopPropagation();

        self._onDragMove(evt);
    });
    this.element.addEventListener('mouseleave', function(evt) {
        self._onDragOut();
    });

    this.on('select', this._onSelect);
    this.on('deselect', this._onDeselect);
    this.on('append', this._onAppend);
    this.on('remove', this._onRemove);

    this.draggable = true;
    this._dragging = false;
    this._dragItems = [ ];
    this._dragOver = null;
    this._dragArea = 'inside';
    this._evtDragMove = null;
    this.reordering = true;
    this.dragInstant = true;

    this._selected = [ ];
}
Tree.prototype = Object.create(ui.ContainerElement.prototype);


Object.defineProperty(Tree.prototype, 'selected', {
    get: function() {
        return this._selected.slice(0);
    },
    set: function(value) {

    }
});


Tree.prototype._onItemClick = function(item) {
    if (Tree._ctrl && Tree._ctrl()) {
        item.selected = ! item.selected;
    } else {
        var selected = item.selected && ((this._selected.indexOf(item) === -1) || (this._selected.length === 1 && this._selected[0] === item));
        this.clear();

        if (! selected) {
            item.open = true;
            item.selected = true;
        }
    }
};


Tree.prototype._onSelect = function(item) {
    this._selected.push(item);
};


Tree.prototype._onDeselect = function(item) {
    var ind = this._selected.indexOf(item);
    if (ind === -1)
        return;

    this._selected.splice(ind, 1);
};


Tree.prototype.clear = function() {
    if (! this._selected.length)
        return;

    var i = this._selected.length;
    while(i--) {
        this._selected[i].selected = false;
    }
    this._selected = [ ];
}


Tree.prototype._onDragStart = function(item) {
    if (! this.draggable || this._dragging)
        return;

    this.class.add('dragging');

    this._dragItems = [ item ];
    item.class.add('dragged');

    this._dragging = true;

    // if (this._selected) {
    //     var i = this._selected.length;
    //     while(i--) {
    //         this._selected[i].selected = false;
    //     }
    //     this._selected = [ ];
    // }

    this._updateDragHandle();

    this.emit('dragstart');
};


Tree.prototype._onDragOver = function(item, evt) {
    if (! this.draggable || ! this._dragging || (item === this._dragItems[0] && ! this._dragOver) || this._dragOver === item)
        return;

    var dragOver = null;

    if (item !== this._dragItems[0])
        dragOver = item;

    if (this._dragOver === null && dragOver)
        this.emit('dragin');

    this._dragOver = dragOver;

    this._updateDragHandle();
    this._onDragMove(evt);
};


Tree.prototype._hoverCalculate = function(evt) {
    if (! this.draggable || ! this._dragOver)
        return;

    var rect = this.elementDrag.getBoundingClientRect();
    var area = Math.floor((evt.clientY - rect.top) / rect.height * 5);

    var oldArea = this._dragArea;
    var oldDragOver = this._dragOver;

    if (this._dragOver.parent === this) {
        if (this._dragItems[0].parent === this._dragOver) {
            this._dragOver = null;
        } else {
            this._dragArea = 'inside';
        }
    } else if (this.reordering && area <= 1 && this._dragOver.prev !== this._dragItems[0]) {
        this._dragArea = 'before';
    } else if (this.reordering && area >= 4 && this._dragOver.next !== this._dragItems[0] && (this._dragOver._children === 0 || ! this._dragOver.open)) {
        this._dragArea = 'after';
    } else {
        if (this.reordering && this._dragOver === this._dragItems[0].parent && this._dragOver.open) {
            this._dragArea = 'before';
        } else {
            this._dragArea = 'inside';
        }
    }

    if (oldArea !== this._dragArea || oldDragOver !== this._dragOver)
        this._updateDragHandle();
};


Tree.prototype._onDragMove = function(evt) {
    if (! this.draggable)
        return;

    this._hoverCalculate(evt);
    this.emit('dragmove', evt);
};


Tree.prototype._onDragOut = function() {
    if (! this.draggable || ! this._dragging || ! this._dragOver)
        return;

    this._dragOver = null;
    this._updateDragHandle();
    this.emit('dragout');
};


Tree.prototype._onDragEnd = function() {
    if (! this.draggable || ! this._dragging)
        return;

    this._dragging = false;

    this.class.remove('dragging');

    for(var i = 0; i < this._dragItems.length; i++) {
        this._dragItems[i].class.remove('dragged');

        if (this._dragOver && this._dragOver !== this._dragItems[i]) {

            var oldParent = this._dragItems[i].parent;

            if (oldParent !== this._dragOver || this._dragArea !== 'inside') {
                var newParent = null;

                if (this.dragInstant) {
                    if (this._dragItems[i].parent)
                        this._dragItems[i].parent.remove(this._dragItems[i]);
                }

                if (this._dragArea === 'before') {
                    newParent = this._dragOver.parent;
                    if (this.dragInstant)
                        this._dragOver.parent.appendBefore(this._dragItems[i], this._dragOver);
                } else if (this._dragArea === 'inside') {
                    newParent = this._dragOver;
                    if (this.dragInstant) {
                        this._dragOver.open = true;
                        this._dragOver.append(this._dragItems[i]);
                    }
                } else if (this._dragArea === 'after') {
                    newParent = this._dragOver.parent;
                    if (this.dragInstant)
                        this._dragOver.parent.appendAfter(this._dragItems[i], this._dragOver);
                }

                this.emit('reparent', this._dragItems[i], oldParent, newParent);
            }
        }
    }

    this._dragItems = [ ];

    if (this._dragOver)
        this._dragOver = null;

    this.emit('dragend');
};


Tree.prototype._updateDragHandle = function() {
    if (! this.draggable || ! this._dragging)
        return;

    if (! this._dragOver) {
        this.elementDrag.classList.add('hidden');
    } else {
        var rect = this._dragOver.elementTitle.getBoundingClientRect();

        this.elementDrag.classList.remove('before', 'inside', 'after', 'hidden')
        this.elementDrag.classList.add(this._dragArea);

        this.elementDrag.style.top = rect.top  + 'px';
        this.elementDrag.style.left = rect.left + 'px';
        this.elementDrag.style.width = (rect.width - 4) + 'px';
    }
};


Tree.prototype._onAppend = function(item) {
    item.tree = this;

    var self = this;

    item.on('dragstart', function() {
        // can't drag root
        if (this.parent === self)
            return;

        this.open = false;
        self._onDragStart(this);
    });

    item.on('mouseover', function(evt) {
        self._onDragOver(this, evt);
    });

    item.on('dragend', function() {
        self._onDragEnd();
    });
};


Tree.prototype._onRemove = function(item) {
    item.tree = null;

    item.unbind('dragstart');
    item.unbind('mouseover');
    item.unbind('dragend');
};

window.ui.Tree = Tree;


/* ui/tree-item.js */
"use strict";

function TreeItem(args) {
    var self = this;
    ui.Element.call(this);
    args = args || { };

    this.tree = null;

    this.element = document.createElement('div');
    this.element.classList.add('ui-tree-item');
    this.element.ui = this;

    this.elementTitle = document.createElement('div');
    this.elementTitle.classList.add('title');
    this.elementTitle.draggable = true;
    this.elementTitle.tabIndex = 0;
    this.element.appendChild(this.elementTitle);

    this.elementIcon = document.createElement('span');
    this.elementIcon.classList.add('icon');
    this.elementTitle.appendChild(this.elementIcon);

    this.elementText = document.createElement('span');
    this.elementText.textContent = args.text || '';
    this.elementText.classList.add('text');
    this.elementTitle.appendChild(this.elementText);

    this._children = 0;
    this.selectable = true;

    this._onClickEvt = this._onClick.bind(this);
    this._onDblClickEvt = this._onDblClick.bind(this);
    this.elementTitle.addEventListener('click', this._onClickEvt, false);
    this.elementTitle.addEventListener('dblclick', this._onDblClickEvt, false);

    this._dragRelease = null;
    this._dragging = false;
    this.elementTitle.addEventListener('dragstart', this._onDragStart.bind(this), false);
    this.elementTitle.addEventListener('mouseover', this._onMouseOver.bind(this), false);

    this.on('destroy', this._onDestroy);
    this.on('append', this._onAppend);
    this.on('remove', this._onRemove);

    this.on('select', function() {
        this.elementTitle.focus();
    });

    this.on('deselect', function() {
        this.elementTitle.blur();
    });

    this.elementTitle.addEventListener('keydown', function(evt) {
        if ((evt.target && evt.target.tagName.toLowerCase() === 'input'))
            return;

        if ([ 9, 38, 40, 37, 39 ].indexOf(evt.keyCode) === -1)
            return;

        evt.preventDefault();
        evt.stopPropagation();

        var selectedItem = null;

        switch(evt.keyCode) {
            case 9: // tab
                break;
            case 40: // down
                var item = self.element.nextSibling;
                if (item)
                    item = item.ui;

                if (self._children && self.open) {
                    var first = self.element.firstChild.nextSibling;
                    if (first && first.ui) {
                        selectedItem = first.ui;
                        // first.ui.selected = true;
                    } else if (item) {
                        selectedItem = item;
                        // item.selected = true;
                    }
                } else if (item) {
                    selectedItem = item;
                    // item.selected = true;
                } else if (self.parent && self.parent instanceof TreeItem) {
                    var parent = self.parent;

                    var findNext = function(from) {
                        var next = from.next;
                        if (next) {
                            selectedItem = next;
                            // next.selected = true;
                        } else if (from.parent instanceof TreeItem) {
                            return from.parent;
                        }
                        return false;
                    };

                    while(parent = findNext(parent)) { }
                }
                break;
            case 38: // up
                var item = self.element.previousSibling;
                if (item)
                    item = item.ui;

                if (item) {
                    if (item._children && item.open) {
                        var last = item.element.lastChild;
                        if (last.ui)
                            last = last.ui;

                        if (last) {
                            var findLast = function(inside) {
                                if (inside._children && inside.open) {
                                    return inside.element.lastChild.ui || null;
                                } else {
                                    return null;
                                }
                            }

                            var found = false;
                            while(! found) {
                                var deeper = findLast(last);
                                if (deeper) {
                                    last = deeper
                                } else {
                                    found = true;
                                }
                            }

                            selectedItem = last;
                            // last.selected = true;
                        } else {
                            selectedItem = item;
                            // item.selected = true;
                        }
                    } else {
                        selectedItem = item;
                        // item.selected = true;
                    }
                } else if (self.parent && self.parent instanceof TreeItem) {
                    selectedItem = self.parent;
                    // self.parent.selected = true;
                }

                break;
            case 37: // left (close)
                if (self.parent !== self.tree && self.open)
                    self.open = false;
                break;
            case 39: // right (open)
                if (self._children && ! self.open)
                    self.open = true;
                break;
        }

        if (selectedItem) {
            if (! (Tree._ctrl && Tree._ctrl()) && ! (Tree._shift && Tree._shift()))
                self.tree.clear();
            selectedItem.selected = true;
        }
    }, false);
}
TreeItem.prototype = Object.create(ui.Element.prototype);


TreeItem.prototype.append = function(item) {
    if (this._children === 1) {
        this.element.childNodes[1].classList.remove('single');
    }

    item.parent = this;
    this.element.appendChild(item.element);
    this._children++;

    if (this._children === 1) {
        item.class.add('single');
        this.class.add('container');
    } else if (this._children > 1) {
        item.class.remove('single');
    }

    var appendChildren = function(treeItem) {
        treeItem.emit('append', treeItem);

        if (treeItem._children) {
            for(var i = 1; i < treeItem.element.childNodes.length; i++) {
                appendChildren(treeItem.element.childNodes[i].ui);
            }
        }
    };
    appendChildren(item);
};


TreeItem.prototype.appendBefore = function(item, referenceItem) {
    if (this._children === 1) {
        this.element.childNodes[1].classList.remove('single');
    }

    item.parent = this;
    this.element.insertBefore(item.element, referenceItem.element);
    this._children++;

    if (this._children === 1) {
        item.class.add('single');
        this.class.add('container');
    } else if (this._children > 1) {
        item.class.remove('single');
    }

    var appendChildren = function(treeItem) {
        treeItem.emit('append', treeItem);

        if (treeItem._children) {
            for(var i = 1; i < treeItem.element.childNodes.length; i++) {
                appendChildren(treeItem.element.childNodes[i].ui);
            }
        }
    };
    appendChildren(item);
};


TreeItem.prototype.appendAfter = function(item, referenceItem) {
    item.parent = this;
    referenceItem = referenceItem.element.nextSibling;

    // might be last
    if (! referenceItem)
        this.append(item);

    this.element.insertBefore(item.element, referenceItem);
    this._children++;

    if (this._children === 1) {
        item.class.add('single');
        this.class.add('container');
    } else if (this._children === 2) {
        this.element.childNodes[1].classList.remove('single');
    }

    var appendChildren = function(treeItem) {
        treeItem.emit('append', treeItem);

        if (treeItem._children) {
            for(var i = 1; i < treeItem.element.childNodes.length; i++) {
                appendChildren(treeItem.element.childNodes[i].ui);
            }
        }
    };
    appendChildren(item);
};


TreeItem.prototype.remove = function(item) {
    if (! this._children || ! this.element.contains(item.element))
        return;

    this.element.removeChild(item.element);
    this._children--;

    if (this._children === 0) {
        this.class.remove('container');
    } else if (this._children === 1 && this.element.childNodes.length > 2) {
        this.element.childNodes[1].classList.add('single');
    }

    var removeChildren = function(treeItem) {
        treeItem.emit('remove', treeItem);

        if (treeItem._children) {
            for(var i = 1; i < treeItem.element.childNodes.length; i++) {
                removeChildren(treeItem.element.childNodes[i].ui);
            }
        }
    };
    removeChildren(item);
};


TreeItem.prototype._onDestroy = function() {
    this.elementTitle.removeEventListener('click', this._onClickEvt);
};


TreeItem.prototype._onAppend = function(item) {
    if (this.parent)
        this.parent.emit('append', item);
};


TreeItem.prototype._onRemove = function(item) {
    if (this.parent)
        this.parent.emit('remove', item);
};


TreeItem.prototype._onClick = function(evt) {
    if (evt.button !== 0 || ! this.selectable)
        return;

    var rect = this.elementTitle.getBoundingClientRect();

    if (this._children && (evt.clientX - rect.left) < 0) {
        this.open = ! this.open;
    } else {
        this.tree._onItemClick(this);
        evt.stopPropagation();
    }
};


TreeItem.prototype._onDblClick = function(evt) {
    if (! this.tree.allowRenaming || evt.button !== 0)
        return;

    evt.stopPropagation();
    var rect = this.elementTitle.getBoundingClientRect();

    if (this._children && (evt.clientX - rect.left) < 0) {
        return;
    } else {
        this.tree.clear();
        this.tree._onItemClick(this);

        var self = this;
        this.class.add('rename');

        // add remaning field
        var field = new ui.TextField();
        field.renderChanges = false;
        field.value = this.text;
        field.elementInput.addEventListener('blur', function() {
            field.destroy();
            self.class.remove('rename');
        }, false);
        field.on('click', function(evt) {
            evt.stopPropagation();
        });
        field.element.addEventListener('dblclick', function(evt) {
            evt.stopPropagation();
        });
        field.on('change', function(value) {
            if (value)
                self.entity.set('name', value);

            field.destroy();
            self.class.remove('rename');
        });
        this.elementTitle.appendChild(field.element);
        field.elementInput.focus();
        field.elementInput.select();
    }
};

TreeItem.prototype._onDragStart = function(evt) {
    if (this.tree.disabled || ! this.tree.draggable) {
        evt.stopPropagation();
        evt.preventDefault();
        return;
    }

    this._dragging = true;

    if (this._dragRelease)
        window.removeEventListener('mouseup', this._dragRelease);

    this._dragRelease = this._onMouseUp.bind(this);
    window.addEventListener('mouseup', this._dragRelease, false);

    evt.stopPropagation();
    evt.preventDefault();

    this.emit('dragstart');
};


TreeItem.prototype._onMouseOver = function(evt) {
    evt.stopPropagation();

    this.emit('mouseover', evt);
};

TreeItem.prototype._onMouseUp = function(evt) {
    window.removeEventListener('mouseup', this._dragRelease);
    this._dragRelease = null;

    evt.preventDefault();
    evt.stopPropagation();

    this._dragging = false;
    this.emit('dragend');
};


Object.defineProperty(TreeItem.prototype, 'selected', {
    get: function() {
        return this.class.contains('selected');
    },
    set: function(value) {
        if (this.class.contains('selected') === !! value)
            return;

        if (value) {
            this.class.add('selected');

            this.emit('select');
            if (this.tree)
                this.tree.emit('select', this);

        } else {
            this.class.remove('selected');

            this.emit('deselect');
            if (this.tree)
                this.tree.emit('deselect', this);
        }
    }
});


Object.defineProperty(TreeItem.prototype, 'text', {
    get: function() {
        return this.elementText.textContent;
    },
    set: function(value) {
        if (this.elementText.textContent === value)
            return;

        this.elementText.textContent = value;
    }
});


Object.defineProperty(TreeItem.prototype, 'open', {
    get: function() {
        return this.class.contains('open');
    },
    set: function(value) {
        if (this.class.contains('open') === !! value)
            return;

        if (value) {
            this.class.add('open');
            this.emit('open');
            this.tree.emit('open', this);
        } else {
            this.class.remove('open');
            this.emit('close');
            this.tree.emit('close', this);
        }
    }
});


Object.defineProperty(TreeItem.prototype, 'prev', {
    get: function() {
        return this.element.previousSibling && this.element.previousSibling.ui || null;
    }
});


Object.defineProperty(TreeItem.prototype, 'next', {
    get: function() {
        return this.element.nextSibling && this.element.nextSibling.ui || null;
    }
});


TreeItem.prototype.child = function(ind) {
    return this.element.childNodes[ind + 1];
};



window.ui.TreeItem = TreeItem;


/* ui/tooltip.js */
"use strict";

function Tooltip(args) {
    var self = this;

    args = args || { };
    ui.ContainerElement.call(this);

    this.element = document.createElement('div');
    this.element.classList.add('ui-tooltip', 'align-left');

    this.innerElement = document.createElement('div');
    this.innerElement.classList.add('inner');
    this.element.appendChild(this.innerElement);

    this.arrow = document.createElement('div');
    this.arrow.classList.add('arrow');
    this.element.appendChild(this.arrow);

    this.hoverable = args.hoverable || false;

    this.x = args.x || 0;
    this.y = args.y || 0;

    this._align = 'left';
    this.align = args.align || 'left';

    this.on('show', this._reflow);
    this.hidden = args.hidden !== undefined ? args.hidden : true;
    if (args.html) {
        this.html = args.html;
    } else {
        this.text = args.text || '';
    }

    this.element.addEventListener('mouseover', function(evt) {
        if (! self.hoverable)
            return;

        self.hidden = false;
        self.emit('hover', evt);
    }, false);
    this.element.addEventListener('mouseleave', function() {
        if (! self.hoverable)
            return;

        self.hidden = true;
    }, false);
}
Tooltip.prototype = Object.create(ui.ContainerElement.prototype);


Object.defineProperty(Tooltip.prototype, 'align', {
    get: function() {
        return this._align;
    },
    set: function(value) {
        if (this._align === value)
            return;

        this.class.remove('align-' + this._align);
        this._align = value;
        this.class.add('align-' + this._align);

        this._reflow();
    }
});


Object.defineProperty(Tooltip.prototype, 'flip', {
    get: function() {
        return this.class.contains('flip');
    },
    set: function(value) {
        if (this.class.contains('flip') === value)
            return;

        if (value) {
            this.class.add('flip');
        } else {
            this.class.remove('flip');
        }

        this._reflow();
    }
});


Object.defineProperty(Tooltip.prototype, 'text', {
    get: function() {
        return this.innerElement.textContent;
    },
    set: function(value) {
        if (this.innerElement.textContent === value)
            return;

        this.innerElement.textContent = value;
    }
});


Object.defineProperty(Tooltip.prototype, 'html', {
    get: function() {
        return this.innerElement.innerHTML;
    },
    set: function(value) {
        if (this.innerElement.innerHTML === value)
            return;

        this.innerElement.innerHTML = value;
    }
});


Tooltip.prototype._reflow = function() {
    if (this.hidden)
        return;

    this.element.style.top = '';
    this.element.style.right = '';
    this.element.style.bottom = '';
    this.element.style.left = '';

    this.arrow.style.top = '';
    this.arrow.style.right = '';
    this.arrow.style.bottom = '';
    this.arrow.style.left = '';

    this.element.style.display = 'block';

    // alignment
    switch(this._align) {
        case 'top':
            this.element.style.top = this.y + 'px';
            if (this.flip) {
                this.element.style.right = 'calc(100% - ' + this.x + 'px)';
            } else {
                this.element.style.left = this.x + 'px';
            }
            break;
        case 'right':
            this.element.style.top = this.y + 'px';
            this.element.style.right = 'calc(100% - ' + this.x + 'px)';
            break;
        case 'bottom':
            this.element.style.bottom = 'calc(100% - ' + this.y + 'px)';
            if (this.flip) {
                this.element.style.right = 'calc(100% - ' + this.x + 'px)';
            } else {
                this.element.style.left = this.x + 'px';
            }
            break;
        case 'left':
            this.element.style.top = this.y + 'px';
            this.element.style.left = this.x + 'px';
            break;
    }

    // limit to screen bounds
    var rect = this.element.getBoundingClientRect();

    if (rect.left < 0) {
        this.element.style.left = '0px';
        this.element.style.right = '';
    }
    if (rect.top < 0) {
        this.element.style.top = '0px';
        this.element.style.bottom = '';
    }
    if (rect.right > window.innerWidth) {
        this.element.style.right = '0px';
        this.element.style.left = '';
        this.arrow.style.left = Math.floor(rect.right - window.innerWidth + 8) + 'px';
    }
    if (rect.bottom > window.innerHeight) {
        this.element.style.bottom = '0px';
        this.element.style.top = '';
        this.arrow.style.top = Math.floor(rect.bottom - window.innerHeight + 8) + 'px';
    }

    this.element.style.display = '';
};


Tooltip.prototype.position = function(x, y) {
    x = Math.floor(x);
    y = Math.floor(y);

    if (this.x === x && this.y === y)
        return;

    this.x = x;
    this.y = y;

    this._reflow();
};


Tooltip.attach = function(args) {
    var data = {
        align: args.align
    };

    if (args.html)
        data.html = args.html;
    else
        data.text = args.text || '';

    var item = new ui.Tooltip(data);

    item.evtHover = function() {
        var rect = args.target.getBoundingClientRect();
        var off = 16;

        switch(item.align) {
            case 'top':
                if (rect.width < 64) off = rect.width / 2;
                item.flip = rect.left + off > window.innerWidth / 2;
                if (item.flip) {
                    item.position(rect.right - off, rect.bottom);
                } else {
                    item.position(rect.left + off, rect.bottom);
                }
                break;
            case 'right':
                if (rect.height < 64) off = rect.height / 2;
                item.flip = false;
                item.position(rect.left, rect.top + off);
                break;
            case 'bottom':
                if (rect.width < 64) off = rect.width / 2;
                item.flip = rect.left + off > window.innerWidth / 2;
                if (item.flip) {
                    item.position(rect.right - off, rect.top);
                } else {
                    item.position(rect.left + off, rect.top);
                }
                break;
            case 'left':
                if (rect.height < 64) off = rect.height / 2;
                item.flip = false;
                item.position(rect.right, rect.top + off);
                break;
        }

        item.hidden = false;
    };

    item.evtBlur = function() {
        item.hidden = true;
    };

    args.target.addEventListener('mouseover', item.evtHover, false);
    args.target.addEventListener('mouseout', item.evtBlur, false);

    item.on('destroy', function() {
        args.target.removeEventListener('mouseover', item.evtHover);
        args.target.removeEventListener('mouseout', item.evtBlur);
    });

    args.root.append(item);

    return item;
};


window.ui.Tooltip = Tooltip;


/* ui/menu.js */
"use strict";

function Menu(args) {
    var self = this;

    args = args || { };
    ui.ContainerElement.call(this);

    this.element = document.createElement('div');
    this.element.tabIndex = 1;
    this.element.classList.add('ui-menu');

    this.elementOverlay = document.createElement('div');
    this.elementOverlay.classList.add('overlay');
    this.elementOverlay.addEventListener('click', function() {
        self.open = false;
    }, false);
    this.elementOverlay.addEventListener('contextmenu', function() {
        self.open = false;
    }, false);
    this.element.appendChild(this.elementOverlay);

    this.innerElement = document.createElement('div');
    this.innerElement.classList.add('inner');
    this.element.appendChild(this.innerElement);

    this.element.addEventListener('keydown', function(evt) {
        if (self.open && evt.keyCode === 27)
            self.open = false;
    });

    this.on('select-propagate', function(path) {
        this.open = false;
        this.emit(path.join('.') + ':select', path);
        this.emit('select', path);
    });

    this._index = { };
    this.on('append', function(item) {
        this._index[item._value] = item;

        item.on('value', function(value, valueOld) {
           delete self._index[this.valueOld];
           self._index[value] = item;
        });
        item.once('destroy', function() {
            delete self._index[this._value];
        });
    });

    this._hovered = [ ];
    this.on('over', function(path) {
        this._updatePath(path);
    });
    this.on('open', function(state) {
        if (state) return;
        this._updatePath([ ]);
    });
}
Menu.prototype = Object.create(ui.ContainerElement.prototype);


Object.defineProperty(Menu.prototype, 'open', {
    get: function() {
        return this.class.contains('open');
    },
    set: function(value) {
        if (this.class.contains('open') === !! value)
            return;

        if (value) {
            this.class.add('open');
            this.element.focus();
        } else {
            this.class.remove('open');
        }

        this.emit('open', !! value);
    }
});


Menu.prototype.findByPath = function(path) {
    if (! (path instanceof Array))
        path = path.split('.');

    var item = this;

    for(var i = 0; i < path.length; i++) {
        item = item._index[path[i]];
        if (! item)
            return null;
    }

    return item;
};


Menu.prototype._updatePath = function(path) {
    var node = this;

    for(var i = 0; i < this._hovered.length; i++) {
        node = node._index[this._hovered[i]];
        if (! node) break;
        if (path.length <= i || path[i] !== this._hovered[i]) {
            node.class.remove('hover');
            node.innerElement.style.top = '';
            node.innerElement.style.left = '';
            node.innerElement.style.right = '';
        }
    }

    this._hovered = path;
    node = this;

    for(var i = 0; i < this._hovered.length; i++) {
        node = node._index[this._hovered[i]];

        if (! node)
            break;

        node.class.add('hover');
        node.innerElement.style.top = '';
        node.innerElement.style.left = '';
        node.innerElement.style.right = '';

        var rect = node.innerElement.getBoundingClientRect();

        // limit to bottom / top of screen
        if (rect.bottom > window.innerHeight) {
            node.innerElement.style.top = -(rect.bottom - window.innerHeight) + 'px';
        }
        if (rect.right > window.innerWidth) {
            node.innerElement.style.left = 'auto';
            node.innerElement.style.right = (node.parent.innerElement.clientWidth) + 'px';
        }
    }
};


Menu.prototype.position = function(x, y) {
    this.element.style.display = 'block';

    var rect = this.innerElement.getBoundingClientRect();

    var left = (x || 0);
    var top = (y || 0);

    // limit to bottom / top of screen
    if (top + rect.height > window.innerHeight) {
        top = window.innerHeight - rect.height;
    } else if (top < 0) {
        top = 0;
    }
    if (left + rect.width > window.innerWidth) {
        left = window.innerWidth - rect.width;
    } else if (left < 0) {
        left = 0;
    }

    this.innerElement.style.left = left + 'px';
    this.innerElement.style.top = top + 'px';

    this.element.style.display = '';
};


Menu.fromData = function(data) {
    var menu = new ui.Menu();

    var addItem = function(key, data) {
        var item = new ui.MenuItem({
            text: data.title || key,
            value: key,
            icon: data.icon
        });

        if (data.select) {
            item.on('select', data.select);
        }

        if (data.filter) {
            menu.on('open', function() {
                item.enabled = data.filter();
            });
        }

        if (data.hide) {
            menu.on('open', function () {
                item.hidden = data.hide();
            });
        }

        return item;
    };

    var listItems = function(data, parent) {
        for(var key in data) {
            var item = addItem(key, data[key]);
            parent.append(item);

            if (data[key].items)
                listItems(data[key].items, item);
        }
    };

    listItems(data, menu);

    return menu;
};


window.ui.Menu = Menu;


/* ui/menu-item.js */
"use strict";

function MenuItem(args) {
    var self = this;

    args = args || { };
    ui.ContainerElement.call(this);

    this._value = args.value || '';

    this.element = document.createElement('div');
    this.element.classList.add('ui-menu-item');

    this.elementTitle = document.createElement('div');
    this.elementTitle.classList.add('title');
    this.element.appendChild(this.elementTitle);

    this.elementIcon = null;

    this.elementText = document.createElement('span');
    this.elementText.classList.add('text');
    this.elementText.textContent = args.text || 'Untitled';
    this.elementTitle.appendChild(this.elementText);

    this.innerElement = document.createElement('div');
    this.innerElement.classList.add('content');
    this.element.appendChild(this.innerElement);

    this._index = { };

    this._container = false;

    this.elementTitle.addEventListener('mouseenter', function(evt) {
        evt.stopPropagation();
        evt.preventDefault();

        self.parent.emit('over', [ self._value ]);
    });

    this.on('over', function(path) {
        if (! this.parent)
            return;

        path.splice(0, 0, this._value);

        this.parent.emit('over', path);
    });

    this.elementTitle.addEventListener('click', function(evt) {
        if (! self.parent || self.disabled)
            return;

        self.emit('select', self._value);
        self.parent.emit('select-propagate', [ self._value ]);
        self.class.remove('hover');
    }, false);

    this.on('select-propagate', function(path) {
        if (! this.parent)
            return;

        path.splice(0, 0, this._value);

        this.parent.emit('select-propagate', path);
        this.class.remove('hover');
    });

    this.on('append', function(item) {
        this._container = true;
        this.class.add('container');

        this._index[item._value] = item;

        item.on('value', function(value, valueOld) {
           delete self._index[this.valueOld];
           self._index[value] = item;
        });
        item.once('destroy', function() {
            delete self._index[this._value];
        });
    });

    if (args.icon)
        this.icon = args.icon;
}
MenuItem.prototype = Object.create(ui.ContainerElement.prototype);


Object.defineProperty(MenuItem.prototype, 'value', {
    get: function() {
        return this._value;
    },
    set: function(value) {
        if (this._value === value)
            return;

        var valueOld = this._value;
        this._value = value;
        this.emit('value', value, valueOld);
    }
});


Object.defineProperty(MenuItem.prototype, 'text', {
    get: function() {
        return this.elementText.textContent;
    },
    set: function(value) {
        if (this.elementText.textContent === value)
            return;

        this.elementText.textContent = value;
    }
});


Object.defineProperty(MenuItem.prototype, 'icon', {
    get: function() {
        return this.elementIcon.textContent;
    },
    set: function(value) {
        if ((! value && ! this.elementIcon) || (this.elementIcon && this.elementIcon.textContent === value))
            return;

        if (! value) {
            this.elementIcon.parentNode.removeChild(this.elementIcon);
            this.elementIcon = null;
        } else {
            if (! this.elementIcon) {
                this.elementIcon = document.createElement('span');
                this.elementIcon.classList.add('icon');
                this.elementTitle.insertBefore(this.elementIcon, this.elementText);
            }

            this.elementIcon.innerHTML = value;
        }
    }
});


window.ui.MenuItem = MenuItem;


/* ui/canvas.js */
"use strict";

function Canvas(args) {
    ui.Element.call(this);
    args = args || { };

    this.element = document.createElement('canvas');
    this.class.add('ui-canvas');

    if (args.id !== undefined)
        this.element.id = args.id;

    if (args.tabindex !== undefined)
        this.element.setAttribute('tabindex', args.tabindex);

    // Disable I-bar cursor on click+drag
    this.element.onselectstart = function () {
        return false;
    };
}

Canvas.prototype = Object.create(ui.Element.prototype);


Object.defineProperty(Canvas.prototype, 'width', {
    get: function() {
        return this.element.width;
    },
    set: function(value) {
        if (this.element.width === value)
            return;

        this.element.width = value;
        this.emit('resize', this.element.width, this.element.height);
    }
});


Object.defineProperty(Canvas.prototype, 'height', {
    get: function() {
        return this.element.height;
    },
    set: function(value) {
        if (this.element.height === value)
            return;

        this.element.height = value;
        this.emit('resize', this.element.width, this.element.height);
    }
});


Canvas.prototype.resize = function(width, height) {
    if (this.element.width === width && this.element.height === height)
        return;

    this.element.width = width;
    this.element.height = height;
    this.emit('resize', this.element.width, this.element.height);
};


window.ui.Canvas = Canvas;


/* ui/curve-field.js */
"use strict"

function CurveField(args) {
    var self = this;

    ui.Element.call(this);
    args = args || { };

    this.element = document.createElement('div');
    this.element.classList.add('ui-curve-field');
    this.element.tabIndex = 0;
    this.element.addEventListener('keydown', this._onKeyDown.bind(this), false);

    // canvas to render mini version of curves
    this.canvas = new ui.Canvas();
    this.element.appendChild(this.canvas.element);
    this.canvas.on('resize', this._render.bind(this));

    // create checkerboard pattern
    this.checkerboardCanvas = new ui.Canvas();
    var size = 17;
    var halfSize = size/2;
    this.checkerboardCanvas.width = size;
    this.checkerboardCanvas.height = size;
    var ctx = this.checkerboardCanvas.element.getContext('2d');
    ctx.fillStyle = '#'
    ctx.fillStyle = "#949a9c";
    ctx.fillRect(0,0,halfSize,halfSize);
    ctx.fillRect(halfSize,halfSize,halfSize,halfSize);
    ctx.fillStyle = "#657375";
    ctx.fillRect(halfSize,0,halfSize,halfSize);
    ctx.fillRect(0,halfSize,halfSize,halfSize);

    this.checkerboard = this.canvas.element.getContext('2d').createPattern(this.checkerboardCanvas.element, 'repeat');

    this._value = null;

    // curve field can contain multiple curves
    this._paths = [];

    this._linkSetHandlers = [];
    this._resizeInterval = null;
    this._suspendEvents = false;

    this._name = args.name;

    this.curveNames = args.curves;

    this.gradient = !!(args.gradient);
}
CurveField.prototype = Object.create(ui.Element.prototype);

CurveField.prototype._onKeyDown = function(evt) {
    // esc
    if (evt.keyCode === 27)
        return this.element.blur();

    // enter
    if (evt.keyCode !== 32 || this.disabled)
        return;

    evt.stopPropagation();
    evt.preventDefault();
    this.emit('click');
};

CurveField.prototype._resize = function(width, height) {
    var changed = false;
    if (this.canvas.width !== width) {
        this.canvas.width = width;
        changed = true;
    }

    if (this.canvas.height !== height) {
        this.canvas.height = height;
        changed = true;
    }

    if (changed)
        this._render();
};

// Override link method to use multiple paths instead of one
CurveField.prototype.link = function(link, paths) {
    if (this._link) this.unlink();
    this._link = link;
    this._paths = paths;

    this.emit('link', paths);

    // handle canvas resizing
    // 20 times a second
    // if size is already same, nothing will happen
    if (this._resizeInterval)
        clearInterval(this._resizeInterval);

    this._resizeInterval = setInterval(function() {
        var rect = this.element.getBoundingClientRect();
        this.canvas.resize(rect.width, rect.height);
    }.bind(this), 1000 / 20);

    if (this._onLinkChange) {
        var renderChanges = this.renderChanges;
        this.renderChanges = false;
        this._linkSetHandlers.push(this._link.on('*:set', function (path) {
            var paths = this._paths;
            var len = paths.length;
            for (var i = 0; i < len; i++) {
                if (path.indexOf(paths[i]) === 0) {
                    this._onLinkChange();
                    break;
                }
            }
        }.bind(this)));

        this._onLinkChange();

        this.renderChanges = renderChanges;
    }
};

// Override unlink method to use multiple paths instead of one
CurveField.prototype.unlink = function() {
    if (! this._link) return;

    this.emit('unlink', this._paths);

    this._linkSetHandlers.forEach(function (handler) {
        handler.unbind();
    });

    this._linkSetHandlers.length = 0;

    clearInterval(this._resizeInterval);

    this._link = null;
    this._value = null;
    this._paths.length = 0;
};


CurveField.prototype._onLinkChange = function () {
    if (this._suspendEvents) return;

    // gather values of all paths and set new value
    var values = [];

    for (var i = 0; i < this._paths.length; i++) {
        var value = this._link.get(this._paths[i]);
        if (value !== undefined) {
            values.push(value);
        } else {
            values.push(null);
        }
    }

    this._setValue(values);
};

Object.defineProperty(CurveField.prototype, 'value', {
    get: function() {
        return this._value;
    },
    set: function(value) {
        this._setValue(value);
    }
});

CurveField.prototype._setValue = function (value) {
    this._value = value;
    this._render();
    this.emit('change', value);
};

CurveField.prototype._render = function () {
    if (this.gradient) {
        this._renderGradient();
    } else {
        this._renderCurves();
    }
};

// Renders all curves
CurveField.prototype._renderCurves = function () {
    var canvas = this.canvas.element;
    var context = canvas.ctx = canvas.ctx || canvas.getContext('2d');
    var value = this.value;

    // draw background
    context.clearRect(0, 0, canvas.width, canvas.height);

    var curveColors = ['rgb(255, 0, 0)', 'rgb(0, 255, 0)', 'rgb(133, 133, 252)', 'rgb(255, 255, 255)'];
    var fillColors = ['rgba(255, 0, 0, 0.5)', 'rgba(0, 255, 0, 0.5)', 'rgba(133, 133, 252, 0.5)', 'rgba(255, 255, 255, 0.5)'];

    var minMax = this._getMinMaxValues(value);

    // draw curves
    if (value && value[0]) {
        var primaryCurves = this._valueToCurves(value[0]);

        if (! primaryCurves)
            return;

        var secondaryCurves = value[0].betweenCurves && value.length > 1 ? this._valueToCurves(value[1]) : null;

        var minValue = minMax[0];
        var maxValue = minMax[1];

        context.lineWidth = 1;

        for (var i = 0; i < primaryCurves.length; i++) {
            var val, x;

            context.strokeStyle = curveColors[i];
            context.fillStyle = fillColors[i];

            context.beginPath();
            context.moveTo(0, canvas.height * (1 - (primaryCurves[i].value(0) - minValue) / (maxValue - minValue)));

            var precision = 1;

            for(x = 0; x < Math.floor(canvas.width / precision); x++) {
                val = primaryCurves[i].value(x * precision / canvas.width);
                context.lineTo(x * precision, canvas.height * (1 - (val - minValue) / (maxValue - minValue)));
            }

            if (secondaryCurves) {
                for(x = Math.floor(canvas.width / precision) ; x >= 0; x--) {
                    val = secondaryCurves[i].value(x * precision / canvas.width);
                    context.lineTo(x * precision, canvas.height * (1 - (val - minValue) / (maxValue - minValue)));
                }

                context.closePath();
                context.fill();
            }

            context.stroke();
        }
    }
};

// Renders color-type graph as a gradient
CurveField.prototype._renderGradient = function () {
    var canvas = this.canvas.element;
    var context = canvas.ctx = canvas.cxt || canvas.getContext('2d');
    var value = this.value && this.value.length ? this.value[0] : null;

    context.fillStyle = this.checkerboard;
    context.fillRect(0, 0, canvas.width, canvas.height);

    var swizzle = [0, 1, 2, 3];
    if (this.curveNames && this.curveNames.length === 1) {
        if (this.curveNames[0] === 'g') {
            swizzle = [1, 0, 2, 3];
        } else if (this.curveNames[0] === 'b') {
            swizzle = [2, 1, 0, 3];
        } else if (this.curveNames[0] === 'a') {
            swizzle = [3, 1, 2, 0];
        }
    }


    if (value && value.keys && value.keys.length) {
        var rgb = [];

        var curve = this.curveNames && this.curveNames.length === 1 ? new pc.CurveSet([value.keys]) : new pc.CurveSet(value.keys);
        curve.type = value.type;

        var precision = 2;

        var gradient = context.createLinearGradient(0, 0, canvas.width, canvas.height);

        for (var t = precision; t < canvas.width; t += precision) {
            curve.value(t / canvas.width, rgb);

            var rgba = Math.round((rgb[swizzle[0]] || 0) * 255) + ',' +
                       Math.round((rgb[swizzle[1]] || 0) * 255) + ',' +
                       Math.round((rgb[swizzle[2]] || 0) * 255) + ',' +
                       (isNaN(rgb[swizzle[3]]) ? 1 : rgb[swizzle[3]]);

            gradient.addColorStop(t / canvas.width, 'rgba(' + rgba + ')');
        }

        context.fillStyle = gradient;
        context.fillRect(0, 0, canvas.width, canvas.height);

    } else {
        // no keys in the curve so just render black color
        context.fillStyle = 'black';
        context.fillRect(0, 0, canvas.width, canvas.height);
    }
},

// Returns minimum and maximum values for all curves
CurveField.prototype._getMinMaxValues = function (curves) {
    var minValue = Infinity;
    var maxValue = -Infinity;
    var i, len;

    if (curves) {
        if (curves.length === undefined) {
            curves = [curves];
        }

        curves.forEach(function (value) {
            if (value && value.keys && value.keys.length) {
                if (value.keys[0].length !== undefined) {
                    value.keys.forEach(function (data) {

                        for (i = 1, len = data.length; i < len; i += 2) {
                            if (data[i] > maxValue) {
                                maxValue = data[i];
                            }

                            if (data[i] < minValue) {
                                minValue = data[i];
                            }
                        }
                    });
                } else {
                    for (i = 1, len = value.keys.length; i < len; i += 2) {
                        if (value.keys[i] > maxValue) {
                            maxValue = value.keys[i];
                        }

                        if (value.keys[i] < minValue) {
                            minValue = value.keys[i];
                        }
                    }
                }
            }
        });
    }

    // If no curves were found set min to 0...
    if (minValue === Infinity) {
        minValue = 0;
    }

    // ... and max to 1
    if (maxValue === -Infinity) {
        maxValue = 1;
    }

    // if min and max are equal then offset them both by 0.5
    // so that the straight line is rendered in the middle of the canvas
    if (minValue === maxValue) {
        minValue -= 0.5;
        maxValue += 0.5;
    }

    return [minValue, maxValue];
};

CurveField.prototype._valueToCurves = function (value) {
    var curves = null;

    if (value && value.keys && value.keys.length) {
        curves = [];
        var curve;
        if (value.keys[0].length !== undefined) {
            value.keys.forEach(function (data, index) {
                curve = new pc.Curve(data);
                curve.type = value.type;
                curves.push(curve);
            });
        } else {
            curve = new pc.Curve(value.keys);
            curve.type = value.type;
            curves.push(curve);
        }
    }

    return curves;
},

window.ui.CurveField = CurveField;


/* ui/autocomplete-element.js */
"use strict";

function AutoCompleteElement() {
    ui.Element.call(this);

    this.element = document.createElement('div');
    this.element.classList.add('ui-autocomplete', 'hidden');

    this._inputField = null;
    this._inputFieldPosition = null;

    this.innerElement = document.createElement('ul');
    this.element.appendChild(this.innerElement);

    // list of strings to show in the dropdown
    this._items = null;

    // child li elements
    this._childElements = null;

    // elements that are currently shown
    this._visibleElements = null;

    this._highlightedElement = null;

    this._filter = '';
}

AutoCompleteElement.prototype = Object.create(ui.Element.prototype);

// Get / Set list of strings to show in the dropdown
Object.defineProperty(AutoCompleteElement.prototype, 'items', {
    get: function () {
        return this._items;
    },

    set: function (value) {
        // delete existing elements
        if (this._childElements) {
            this._childElements.forEach(function (element) {
                element.parentElement.removeChild(element);
            });

            this._childElements = null;
            this._highlight(null);
        }

        this._items = value;

        if (value) {
            // sort items
            this._items.sort();

            // create new li elements for each string
            this._childElements = [];
            this._visibleElements = [];
            value.forEach(function (item) {
                var element = document.createElement('li');
                element.innerHTML = item;
                this._childElements.push(element);
                this._visibleElements.push(element);
                this.innerElement.appendChild(element);

                // click
                element.addEventListener('mousedown', function (e) {
                    e.preventDefault(); // prevent blur
                    this._select(element);
                }.bind(this), true);

                // hover
                element.addEventListener('mouseover', function () {
                    this._highlight(element, true);
                }.bind(this));

            }.bind(this));
        }
    }
});

// True if the autocomplete is visible and has a highlighted element
Object.defineProperty(AutoCompleteElement.prototype, 'isFocused', {
    get: function () {
        return !this.hidden && this._highlightedElement;
    }
});

// Attach the autocomplete element to an input field
AutoCompleteElement.prototype.attach = function (inputField) {
    this._inputField = inputField;

    // set 'relative' position
    this._inputFieldPosition = inputField.style.position;
    inputField.style.position = 'relative';
    inputField.element.appendChild(this.element);

    // fire 'change' on every keystroke
    inputField.keyChange = true;

    // add event handlers
    inputField.element.addEventListener('keydown', this.onInputKey.bind(this));
    inputField.element.addEventListener('blur', this.onInputBlur.bind(this));
    inputField.elementInput.addEventListener('blur', this.onInputBlur.bind(this));
    inputField.on('change', this.onInputChange.bind(this));
};

// Detach event handlers and clear the attached input field
AutoCompleteElement.prototype.detach = function () {
    if (!this._inputField) return;

    this._inputField.style.position = this._inputFieldPosition;
    this._inputField.element.removeChild(this.element);

    this._inputField.off('change', this.onInputChange.bind(this));
    this._inputField.element.removeEventListener('keydown', this.onInputKey.bind(this));
    this._inputField.elementInput.removeEventListener('blur', this.onInputBlur.bind(this));

    this._inputField = null;
};

AutoCompleteElement.prototype.onInputKey = function (e) {
    var index;

    // enter: select highlighted element
    if (e.keyCode === 13) {
        if (!this.hidden && this._highlightedElement) {
            this._select(this._highlightedElement);
        }
    }
    // up: show dropdown or move highlight up
    else if (e.keyCode === 38) {
        if (this.hidden) {
            this.filter(this._inputField.value);
        } else {
            if (this._highlightedElement) {
                index = this._visibleElements.indexOf(this._highlightedElement) - 1;
                if (index < 0) {
                    index = this._visibleElements.length - 1;
                }
            } else {
                index = this._visibleElements.length - 1;
            }

            this._highlight(this._visibleElements[index]);
        }
    }
    // down: show dropdown or move highlight down
    else if (e.keyCode === 40 ) {

        if (this.hidden) {
            this.filter(this._inputField.value);
        } else {
            if (this._highlightedElement) {
            index = this._visibleElements.indexOf(this._highlightedElement) + 1;
                if (index >= this._visibleElements.length) {
                    index = 0;
                }
            } else {
                index = 0;
            }

            this._highlight(this._visibleElements[index]);
        }
    }
};

AutoCompleteElement.prototype.onInputBlur = function () {
    return;
    // hide the dropdown in a timeout
    // to avoid conflicts with key handlers
    setTimeout(function () {
        this.hidden = true;
    }.bind(this), 50);
};

AutoCompleteElement.prototype.onInputChange = function (value) {
    // filter based on new input field value
    if (value !== this._filter) {
        this.filter(value);
    }
};

// Only show elements that start with the specified value
AutoCompleteElement.prototype.filter = function (value) {
    if (!this._childElements) return;

    this.hidden = false;

    this._filter = value;

    this._visibleElements = [];

    value = value.toLowerCase();

    this._childElements.forEach(function (element, i) {
        if (value && element.innerHTML.toLowerCase().indexOf(value) === 0) {
            element.classList.remove('hidden');
            this._visibleElements.push(element);
        } else {
            element.classList.add('hidden');
            if (element === this._highlightedElement)
                this._highlight(null);
        }
    }.bind(this));
};

// Highlight specified element
AutoCompleteElement.prototype._highlight = function (element, silent) {
    // unhighlight previous element
    if (this._highlightedElement === element) return;

    if (this._highlightedElement)
        this._highlightedElement.classList.remove('selected');

    this._highlightedElement = element;

    if (element) {
        element.classList.add('selected');

        if (! silent) {
            this.emit('highlight', element.innerHTML);
        }
    }
};

// Select specified element
AutoCompleteElement.prototype._select = function (element) {
    if (this._inputField) {
        this._inputField.value = element.innerHTML;
        this._inputField.elementInput.focus();
    }

    this.emit('select', element.innerHTML);

    // hide in a timeout to avoid conflicts with key handlers
    setTimeout(function () {
        this.hidden = true;
    }.bind(this));
};

window.ui.AutoCompleteElement = AutoCompleteElement;


/* ui/bubble.js */
"use strict";

function Bubble(args) {
    ui.Element.call(this);
    args = args || { };

    this.element = document.createElement('div');
    this.class.add('ui-bubble');

    var pulseCircle = document.createElement('div');
    pulseCircle.classList.add('pulse');
    this.element.appendChild(pulseCircle);

    var centerCircle = document.createElement('div');
    centerCircle.classList.add('center');
    this.element.appendChild(centerCircle);

    var self = this;
    this.on('click', function () {
        if (self.class.contains('active')) {
            self.deactivate();
        } else {
            self.activate();
        }
    });

    if (args.id !== undefined)
        this.element.id = args.id;

    if (args.tabindex !== undefined)
        this.element.setAttribute('tabindex', args.tabindex);

}

Bubble.prototype = Object.create(ui.Element.prototype);

Bubble.prototype.activate = function () {
    this.class.add('active');
    this.emit('activate');
};

Bubble.prototype.deactivate = function () {
    this.class.remove('active');
    this.emit('deactivate');
};

Bubble.prototype.position = function (x, y) {
    var rect = this.element.getBoundingClientRect();

    var left = (x || 0);
    var top = (y || 0);

    this.element.style.left = (typeof left === 'number') ? left + 'px' : left;
    this.element.style.top = (typeof top === 'number') ? top + 'px' : top;
};

window.ui.Bubble = Bubble;


/* editor/editor.js */
(function() {
    'use strict';

    function Editor() {
        Events.call(this);

        this._hooks = { };
    }
    Editor.prototype = Object.create(Events.prototype);


    Editor.prototype.method = function(name, fn) {
        if (this._hooks[name] !== undefined) {
            throw new Error('can\'t override hook: ' + name);
        }
        this._hooks[name] = fn;
    };


    Editor.prototype.methodRemove = function(name) {
        delete this._hooks[name];
    };


    Editor.prototype.call = function(name) {
        if (this._hooks[name]) {
            var args = Array.prototype.slice.call(arguments, 1);

            try {
                return this._hooks[name].apply(null, args);
            } catch(ex) {
                console.info('%c%s %c(editor.method error)', 'color: #06f', name, 'color: #f00');
                console.log(ex.stack);
            }
        }
        return null;
    };


    // editor
    window.editor = new Editor();


    // first load
    document.addEventListener('DOMContentLoaded', function() {
        editor.call('status:text', 'loading');
        editor.emit('load');
        editor.call('status:text', 'starting');
        editor.emit('start');

        editor.call('status:text', 'ready');
    }, false);
})();


// config
(function() {
    'use strict';

    var applyConfig = function(path, value) {
        if (typeof(value) === 'object') {
            for(var key in value) {
                applyConfig((path ? path + '.' : '') + key, value[key]);
            }
        } else {
            Ajax.param(path, value);
        }
    };

    applyConfig('', config);
})();


/* editor/hotkeys.js */
editor.once('load', function() {
    'use strict';


    var hotkeys = { };
    var keyIndex = { };
    var keysDown = { };
    var ctrl = false;
    var shift = false;
    var alt = false;

    var keyMap = {
        'backspace': 8,
        'tab': 9,
        'enter': 13,
        'shift': 16,
        'ctrl': 17,
        'alt': 18,
        'pause/break': 19,
        'caps lock': 20,
        'esc': 27,
        'space': 32,
        'page up': 33, 'page down': 34,
        'end': 35, 'home': 36,
        'left arrow': 37, 'up arrow': 38, 'right arrow': 39, 'down arrow': 40,
        'insert': 45, 'delete': 46,
        '0': 48, '1': 49, '2': 50, '3': 51, '4': 52, '5': 53, '6': 54, '7': 55, '8': 56, '9': 57, 'a': 65,
        'b': 66, 'c': 67, 'd': 68, 'e': 69, 'f': 70, 'g': 71, 'h': 72, 'i': 73, 'j': 74, 'k': 75, 'l': 76, 'm': 77, 'n': 78, 'o': 79, 'p': 80, 'q': 81, 'r': 82, 's': 83, 't': 84, 'u': 85, 'v': 86, 'w': 87, 'x': 88, 'y': 89, 'z': 90,
        'left window key': 91, 'right window key': 92,
        'select key': 93,
        'numpad 0': 96, 'numpad 1': 97, 'numpad 2': 98, 'numpad 3': 99, 'numpad 4': 100, 'numpad 5': 101, 'numpad 6': 102, 'numpad 7': 103, 'numpad 8': 104, 'numpad 9': 105,
        'multiply': 106,
        'add': 107,
        'subtract': 109,
        'decimal point': 110,
        'divide': 111,
        'f1': 112, 'f2': 113, 'f3': 114, 'f4': 115, 'f5': 116, 'f6': 117, 'f7': 118, 'f8': 119, 'f9': 120, 'f10': 121, 'f11': 122, 'f12': 123,
        'num lock': 144,
        'scroll lock': 145,
        'semi-colon': 186,
        'equal sign': 187,
        'comma': 188,
        'dash': 189,
        'period': 190,
        'forward slash': 191,
        'grave accent': 192,
        'open bracket': 219,
        'back slash': 220,
        'close braket': 221,
        'single quote': 222
    };


    editor.method('hotkey:register', function(name, args) {
        hotkeys[name] = args;

        // keys list
        var keys = [ args.ctrl ? 1 : 0, args.alt ? 1 : 0, args.shift ? 1 : 0 ];

        // map string to keyCode
        if (typeof(args.key) === 'string')
            args.key = keyMap[args.key];

        // unknown key
        if (! args.key) {
            console.error('unknown key: ' + name + ', ' + args.key);
            return;
        }

        keys.push(args.key);

        args.index = keys.join('+');

        if (! keyIndex[args.index])
            keyIndex[args.index] = [ ];

        keyIndex[args.index].push(name);
    });


    editor.method('hotkey:unregister', function(name) {
        var hotkey = hotkeys[name];
        if (! hotkey) return;

        if (keyIndex[hotkey.index].length === 1) {
            delete keyIndex[hotkey.index];
        } else {
            keyIndex[hotkey.index].splice(keyIndex[hotkey.index].indexOf(name), 1);
        }

        delete hotkeys[name];
    });


    editor.method('hotkey:shift', function() {
        return shift;
    });

    editor.method('hotkey:ctrl', function() {
        return ctrl;
    });

    editor.method('hotkey:alt', function() {
        return alt;
    });


    var updateModifierKeys = function(evt) {
        if (shift !== evt.shiftKey) {
            shift = evt.shiftKey;
            editor.emit('hotkey:shift', shift);
        }

        if (ctrl !== (evt.ctrlKey || evt.metaKey)) {
            ctrl = evt.ctrlKey || evt.metaKey;
            editor.emit('hotkey:ctrl', ctrl);
        }

        if (alt !== evt.altKey) {
            alt = evt.altKey;
            editor.emit('hotkey:alt', alt);
        }
    };


    window.addEventListener('keydown', function(evt) {
        if ((evt.target && evt.target.tagName.toLowerCase() === 'input'))
            return;

        updateModifierKeys(evt);

        if ([ 92, 93 ].indexOf(evt.keyCode) !== -1)
            return;

        var index = [ ctrl+0, alt+0, shift+0, evt.keyCode ].join('+');

        if (keyIndex[index]) {
            var skipPreventDefault = false;
            for(var i = 0; i < keyIndex[index].length; i++) {
                hotkeys[keyIndex[index][i]].callback();
                if (! skipPreventDefault && hotkeys[keyIndex[index][i]].skipPreventDefault)
                    skipPreventDefault = true;
            }
            if (! skipPreventDefault)
                evt.preventDefault();
        }
    }, false);


    window.addEventListener('keyup', updateModifierKeys, false);
    window.addEventListener('mousedown', updateModifierKeys, false);


    ui.Grid._ctrl = function() {
        return ctrl;
    };
    ui.Grid._shift = function() {
        return shift;
    };

    ui.Tree._ctrl = function() {
        return ctrl;
    };
    ui.Tree._shift = function() {
        return shift;
    };
});


/* editor/layout.js */
editor.on('load', function() {
    'use strict';


    // main container
    var root = new ui.Panel();
    root.element.id = 'ui-root';
    root.flex = true;
    root.flexDirection = 'column';
    root.flexWrap = 'nowrap';
    root.scroll = true;
    document.body.appendChild(root.element);
    // expose
    editor.method('layout.root', function() { return root; });

    var top = new ui.Panel();
    top.style.backgroundColor = '#5f6f72';
    top.style.cursor = 'pointer';
    top.element.id = 'ui-top';
    top.flexShrink = false;
    top.once('click', function() {
        top.destroy();
        toolbar.style.marginTop = '';
    });
    root.append(top);

    // middle
    var middle = new ui.Panel();
    middle.element.id = 'ui-middle';
    middle.flexible = true;
    middle.flexGrow = true;
    root.append(middle);

    // bottom (status)
    var bottom = new ui.Panel();
    bottom.element.id = 'ui-bottom';
    bottom.flexShrink = false;
    root.append(bottom);
    // expose
    editor.method('layout.bottom', function() { return bottom; });


    // toolbar (left)
    var toolbar = new ui.Panel();
    toolbar.element.id = 'ui-toolbar';
    toolbar.flexShrink = false;
    toolbar.style.width = '45px';
    middle.append(toolbar);
    // expose
    editor.method('layout.toolbar', function() { return toolbar; });


    // hierarchy
    var hierarchyPanel = new ui.Panel('HIERARCHY');
    hierarchyPanel.enabled = false;
    hierarchyPanel.class.add('hierarchy');
    hierarchyPanel.flexShrink = false;
    hierarchyPanel.style.width = '320px';
    hierarchyPanel.innerElement.style.width = '320px';
    hierarchyPanel.foldable = true;
    hierarchyPanel.horizontal = true;
    hierarchyPanel.scroll = true;
    hierarchyPanel.resizable = 'right';
    hierarchyPanel.resizeMin = 256;
    hierarchyPanel.resizeMax = 512;
    middle.append(hierarchyPanel);
    // expose
    editor.method('layout.left', function() { return hierarchyPanel; });
    editor.on('permissions:writeState', function(state) {
        hierarchyPanel.enabled = state;
    });



    // center
    var center = new ui.Panel();
    center.flexible = true;
    center.flexGrow = true;
    center.flexDirection = 'column';
    middle.append(center);

    // viewport
    var viewport = new ui.Panel();
    viewport.flexible = true;
    viewport.flexGrow = true;
    center.append(viewport);
    // expose
    editor.method('layout.viewport', function() { return viewport; });

    // assets
    var assetsPanel = new ui.Panel('ASSETS');
    assetsPanel.class.add('assets');
    assetsPanel.foldable = true;
    assetsPanel.flexShrink = false;
    assetsPanel.innerElement.style.height = '212px';
    assetsPanel.scroll = true;
    assetsPanel.resizable = 'top';
    assetsPanel.resizeMin = 106;
    assetsPanel.resizeMax = 106 * 6;
    assetsPanel.headerSize = -1;
    center.append(assetsPanel);
    // expose
    editor.method('layout.assets', function() { return assetsPanel; });



    // attributes
    var attributesPanel = new ui.Panel('INSPECTOR');
    attributesPanel.enabled = false;
    attributesPanel.class.add('attributes');
    attributesPanel.flexShrink = false;
    attributesPanel.style.width = '320px';
    attributesPanel.innerElement.style.width = '320px';
    attributesPanel.horizontal = true;
    attributesPanel.foldable = true;
    attributesPanel.scroll = true;
    attributesPanel.resizable = 'left';
    attributesPanel.resizeMin = 256;
    attributesPanel.resizeMax = 512;
    middle.append(attributesPanel);
    // expose
    editor.method('layout.right', function() { return attributesPanel; });
    editor.on('permissions:writeState', function(state) {
        attributesPanel.enabled = state;
    });
});


/* editor/messenger.js */
editor.on('start', function() {
    'use strict';

    if (typeof(Messenger) === 'undefined')
        return;

    var messenger = new Messenger();

    messenger.connect(config.url.messenger.ws);

    messenger.on('connect', function() {
        this.authenticate(config.accessToken, 'designer');
    });

    messenger.on('welcome', function() {
        this.projectWatch(config.project.id);
    });

    messenger.on('message', function(evt) {
        editor.emit('messenger:' + evt.name, evt.data);
    });

    window.msg = messenger;
});


/* editor/history.js */
editor.once('load', function() {
    'use strict';

    var actions = [ ];
    var current = -1;
    var canUndo = false;
    var canRedo = false;


    var checkCanUndoRedo = function() {
        if (canUndo && current == -1) {
            canUndo = false;
            editor.emit('history:canUndo', false);
        } else if (! canUndo && current >= 0) {
            canUndo = true;
            editor.emit('history:canUndo', true);
        }

        if (canRedo && current === actions.length - 1) {
            canRedo = false;
            editor.emit('history:canRedo', false);
        } else if (! canRedo && current < actions.length - 1) {
            canRedo = true;
            editor.emit('history:canRedo', true);
        }
    };

    editor.method('history:canUndo', function() {
        return canUndo;
    });
    editor.method('history:canRedo', function() {
        return canRedo;
    });


    // current
    editor.method('history:current', function(action) {
        if (current === -1)
            return null;

        return actions[current];
    });


    // clear
    editor.method('history:clear', function() {
        if (! actions.length)
            return;

        actions = [ ];
        current = -1;
        checkCanUndoRedo();
    });


    // add action
    editor.method('history:add', function(action) {
        // some history needs erasing
        if (current !== actions.length - 1) {
            actions = actions.slice(0, current + 1);
        }

        // add action
        actions.push(action);

        editor.call('status:text', action.name);

        // current action state
        current = actions.length - 1;

        checkCanUndoRedo();
    });


    // update action
    editor.method('history:update', function(action) {
        if (current === -1 || actions[current].name !== action.name)
            return;

        actions[current].redo = action.redo;

        editor.call('status:text', action.name);
    });


    // undo
    editor.method('history:undo', function() {
        // no history
        if (current === -1)
            return;

        actions[current].undo();
        current--;

        if (current >= 0) {
            editor.call('status:text', actions[current].name);
        } else {
            editor.call('status:text', '');
        }

        editor.emit('history:undo', name);
        checkCanUndoRedo();
    });


    // redo
    editor.method('history:redo', function() {
        if (current === actions.length - 1)
            return;

        current++;
        actions[current].redo();
        editor.call('status:text', actions[current].name);

        editor.emit('history:redo', name);
        checkCanUndoRedo();
    });

    // hotkey undo
    editor.call('hotkey:register', 'history:undo', {
        key: 'z',
        ctrl: true,
        callback: function() {
            editor.call('history:undo');
        }
    });

    // hotkey redo
    editor.call('hotkey:register', 'history:redo', {
        key: 'z',
        ctrl: true,
        shift: true,
        callback: function() {
            editor.call('history:redo');
        }
    });

    // hotkey redo
    editor.call('hotkey:register', 'history:redo:y', {
        key: 'y',
        ctrl: true,
        callback: function() {
            editor.call('history:redo');
        }
    });
});


/* editor/status.js */
editor.once('load', function() {
    'use strict';

    var jobs = { };
    var panel = editor.call('layout.bottom');


    // status
    var status = new ui.Label({
        text: 'PlayCanvas'
    });
    status.renderChanges = false;
    status.class.add('status');
    panel.append(status);

    // progress
    var progress = new ui.Progress();
    progress.class.add('jobsProgress');
    panel.append(progress);

    // jobs
    var jobsCount = new ui.Label({
        text: '0'
    });
    jobsCount.renderChanges = false;
    jobsCount.class.add('jobsCount');
    panel.append(jobsCount);


    // status text
    editor.method('status:text', function(text) {
        status.text = text;
        status.class.remove('error');
    });


    // status error
    editor.method('status:error', function(text) {
        status.text = text;
        status.class.add('error');
    });



    // update jobs
    var updateJobs = function() {
        var count = Object.keys(jobs).length;
        jobsCount.text = count;

        if (count > 0) {
            var least = 1;
            for(var key in jobs) {
                if (jobs[key] < least)
                    least = jobs[key];
            }
            progress.progress = least;
            progress.class.add('active');
        } else {
            progress.class.remove('active');
            progress.progress = 1;
        }
    };

    // status job
    editor.method('status:job', function(id, value) {
        if (jobs.hasOwnProperty(id) && value === undefined) {
            delete jobs[id];
        } else {
            jobs[id] = value;
        }

        updateJobs();
    });
});


/* editor/permissions.js */
editor.once('load', function() {
    'use strict';

    var permissions = { };

    // cache permissions in a dictionary
    ['read', 'write', 'admin'].forEach(function (access) {
        config.project.permissions[access].forEach(function (id) {
            permissions[id] = access;
        });
    });

    editor.method('permissions', function () {
        return config.project.permissions;
    });

    editor.method('permissions:read', function (userId) {
        if (! userId) userId = config.self.id;

        return userId in permissions;
    });

    editor.method('permissions:write', function (userId) {
        if (!userId) userId = config.self.id;

        return permissions[userId] === 'write' || permissions[userId] === 'admin';
    });

    editor.method('permissions:admin', function (userId) {
        if (!userId) userId = config.self.id;

        return permissions[userId] === 'admin';
    });

    // subscribe to messenger
    editor.on('messenger:project.permissions', function (msg) {
        var userId = msg.user.id;

        // remove from read
        var ind = config.project.permissions.read.indexOf(userId);
        if (ind !== -1)
            config.project.permissions.read.splice(ind, 1);

        // remove from write
        ind = config.project.permissions.write.indexOf(userId);
        if (ind !== -1) {
            config.project.permissions.write.splice(ind, 1);
        }

        // remove from admin
        ind = config.project.permissions.admin.indexOf(userId);
        if (ind !== -1) {
            config.project.permissions.admin.splice(ind, 1);
        }

        delete permissions[userId];

        var accessLevel = msg.user.permission;

        // add new permission
        if (accessLevel) {
            config.project.permissions[accessLevel].push(userId);
            permissions[userId] = accessLevel;
        } else {
            // lock out user if private project
            if (config.self.id === userId && config.project.private)
                window.location.reload();
        }

        editor.emit('permissions:set:' + userId, accessLevel);
    });

    // subscribe to project private changes
    editor.on('messenger:project.private', function (msg) {
        var projectId = msg.project.id;
        if (config.project.id !== projectId)
            return;

        config.project.private = msg.project.private;

        if (msg.project.private && !editor.call('permissions:read', config.self.id)) {
            // refresh page so that user gets locked out
            window.location.reload();
        }
    });

    editor.on('permissions:set:' + config.self.id, function (accessLevel) {
        var connection = editor.call('realtime:connection');
        editor.emit('permissions:writeState', connection && connection.state === 'connected' && (accessLevel === 'write' || accessLevel === 'admin'));
    });

    // emit initial event
    if (editor.call('permissions:write')) {
        editor.emit('permissions:set:' + config.self.id, 'write');
    }
});


/* editor/error.js */
editor.once('load', function() {
    'use strict';

    window.addEventListener('error', function(evt) {
        // console.log(evt);
        editor.call('status:error', evt.message);
    }, false);
});


/* editor/contextmenu.js */
editor.once('load', function() {
    'use strict';

    window.addEventListener('contextmenu', function(evt) {
        evt.preventDefault();
    }, false);
});


/* editor/drop.js */
editor.once('load', function() {
    'use strict';

    // overlay
    var overlay = document.createElement('div');
    overlay.classList.add('drop-overlay');
    editor.call('layout.root').append(overlay);

    var imgDrag = new Image();
    // imgDrag.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAACWCAYAAAAfduJyAAAAFUlEQVQoU2NkYGBgYBwlRsNgJKQDAOAfAJflUZweAAAAAElFTkSuQmCC';
    // imgDrag.style.display = 'none';

    var parts = [ 'top', 'right', 'bottom', 'left' ];
    for(var i = 0; i < parts.length; i++) {
        var part = document.createElement('div');
        part.classList.add('drop-overlay-hole-part', parts[i]);
        editor.call('layout.root').append(part);
        parts[i] = part;
    }

    // areas
    var areas = document.createElement('div');
    areas.classList.add('drop-areas');
    editor.call('layout.root').append(areas);


    var active = false;
    var currentType = '';
    var currentData = { };
    var currentElement = null;
    var dragOver = false;
    var items = [ ];
    var itemOver = null;

    var activate = function(state) {
        if (! editor.call('permissions:write'))
            return;

        if (active === state)
            return;

        active = state;

        if (active) {
            overlay.classList.add('active');
            areas.classList.add('active');
            editor.call('cursor:set', 'grabbing');
        } else {
            overlay.classList.remove('active');
            areas.classList.remove('active');
            dragOver = false;
            currentType = '';
            currentData = { };
            editor.emit('drop:set', currentType, currentData);
            editor.call('cursor:clear');
        }

        var onMouseUp = function() {
            window.removeEventListener('mouseup', onMouseUp);
            activate(false);
        };
        window.addEventListener('mouseup', onMouseUp, false);

        editor.emit('drop:active', active);
    };

    editor.method('drop:activate', activate);
    editor.method('drop:active', function() {
        return active;
    });


    // prevent drop file of redirecting
    window.addEventListener('dragenter', function(evt) {
        evt.preventDefault();

        if (! editor.call('permissions:write'))
            return;

        if (dragOver) return;
        dragOver = true;

        if (! currentType) {
            currentType = 'files';
            editor.emit('drop:set', currentType, currentData);
        }

        activate(true);
    }, false);

    window.addEventListener('dragover', function(evt) {
        evt.preventDefault();

        if (! editor.call('permissions:write'))
            return;

        evt.dataTransfer.dropEffect = 'move';

        if (dragOver) return;
        dragOver = true;

        activate(true);
    }, false);

    window.addEventListener('dragleave', function(evt) {
        evt.preventDefault();

        if (! editor.call('permissions:write'))
            return;

        if (! dragOver) return;
        dragOver = false;

        setTimeout(function() {
            if (dragOver)
                return;

            activate(false);
        }, 0);
    }, false);

    window.addEventListener('drop', function(evt) {
        evt.preventDefault();
        activate(false);
    }, false);


    var evtDragOver = function(e) {
        e.preventDefault();
        this.classList.add('over');

        if (itemOver && itemOver !== this)
            evtDragLeave.call(itemOver);

        itemOver = this;

        if (this._ref && this._ref.over && currentType) {
            var data = currentData;
            if (currentType == 'files' && e.dataTransfer)
                data = e.dataTransfer.files;
            this._ref.over(currentType, data);
        }
    };
    var evtDragLeave = function(e) {
        if (e) e.preventDefault();
        this.classList.remove('over');

        if (this._ref && this._ref.leave && currentType)
            this._ref.leave();

        if (itemOver === this)
            itemOver = null;
    };

    var fixChromeFlexBox = function(item) {
        // workaround for chrome
        // for z-index + flex-grow weird reflow bug
        // need to force reflow in next frames

        if (! window.chrome)
            return;

        // only for those who have flexgrow
        var flex = item.style.flexGrow;
        if (flex) {
            // changing overflow triggers reflow
            var overflow = item.style.overflow;
            item.style.overflow = 'hidden';
            // need to skip 2 frames, 1 is not enough
            requestAnimationFrame(function() {
                requestAnimationFrame(function() {
                    // change back to what it was
                    item.style.overflow = overflow;
                });
            });
        }
    };


    editor.method('drop:target', function(obj) {
        items.push(obj);
        obj.element = document.createElement('div');
        obj.element._ref = obj;
        obj.element.classList.add('drop-area');
        if (obj.hole)
            obj.element.classList.add('hole');

        if (obj.passThrough)
            obj.element.style.pointerEvents = 'none';

        areas.appendChild(obj.element);

        obj.evtDrop = function(e) {
            e.preventDefault();

            if (! currentType)
                return;

            // leave event
            if (obj.element.classList.contains('over')) {
                if (obj.leave && currentType) obj.leave();
                obj.element.classList.remove('over');
            }

            var data = currentData;
            if (currentType == 'files' && e.dataTransfer)
                data = e.dataTransfer.files;

            if (obj.drop)
                obj.drop(currentType, data);
        };

        obj.element.addEventListener('dragenter', evtDragOver, false);
        obj.element.addEventListener('mouseenter', evtDragOver, false);

        obj.element.addEventListener('dragleave', evtDragLeave, false);
        obj.element.addEventListener('mouseleave', evtDragLeave, false);

        var dropOn = obj.element;
        if (obj.passThrough)
            dropOn = obj.ref;

        dropOn.addEventListener('drop', obj.evtDrop, false);
        dropOn.addEventListener('mouseup', obj.evtDrop, false);

        obj.unregister = function() {
            if (! obj.element.classList.contains('drop-area'))
                return;

            obj.element.removeEventListener('dragenter', evtDragOver);
            obj.element.removeEventListener('mouseenter', evtDragOver);

            obj.element.removeEventListener('dragleave', evtDragLeave);
            obj.element.removeEventListener('mouseleave', evtDragLeave);

            dropOn.removeEventListener('drop', obj.evtDrop);
            dropOn.removeEventListener('mouseup', obj.evtDrop);

            var ind = items.indexOf(obj);
            if (ind !== -1)
                items.splice(ind, 1);

            if (obj.ref.classList.contains('drop-ref-highlight')) {
                obj.ref.classList.remove('drop-ref-highlight');
                fixChromeFlexBox(obj.ref);
            }

            obj.element.classList.remove('drop-area');
            areas.removeChild(obj.element);
        };

        return obj;
    });


    editor.method('drop:item', function(args) {
        args.element.draggable = true;

        args.element.addEventListener('dragstart', function(evt) {
            evt.preventDefault();
            evt.stopPropagation();

            if (! editor.call('permissions:write'))
                return;

            currentType = args.type;
            currentData = args.data;
            itemOver = null;
            editor.emit('drop:set', currentType, currentData);

            activate(true);
        }, false);
    });


    editor.method('drop:set', function(type, data) {
        currentType = type || '',
        currentData = data || { };

        editor.emit('drop:set', currentType, currentData);
    });


    editor.on('drop:active', function(state) {
        areas.style.pointerEvents = '';

        if (state) {
            var bottom = 0;
            var top = window.innerHeight;
            var left = window.innerWidth;
            var right = 0;

            for(var i = 0; i < items.length; i++) {
                var visible = ! items[i].disabled;

                if (visible) {
                    if (items[i].filter) {
                        visible = items[i].filter(currentType, currentData);
                    } else if (items[i].type !== currentType) {
                        visible = false;
                    }
                }

                if (visible) {
                    var rect = items[i].ref.getBoundingClientRect();
                    var depth = 4;
                    var parent = items[i].ref;
                    while(depth--) {
                        if (! rect.width || ! rect.height || ! parent.offsetHeight || window.getComputedStyle(parent).getPropertyValue('visibility') === 'hidden') {
                            visible = false;
                            break;
                        }
                        parent = parent.parentNode;
                    }
                }

                if (visible) {
                    items[i].element.style.display = 'block';

                    if (items[i].hole) {
                        items[i].element.style.left = (rect.left + 2) + 'px';
                        items[i].element.style.top = (rect.top + 2) + 'px';
                        items[i].element.style.width = (rect.width - 4) + 'px';
                        items[i].element.style.height = (rect.height - 4) + 'px';

                        overlay.classList.remove('active');

                        if (top > rect.top)
                            top = rect.top;

                        if (bottom < rect.bottom)
                            bottom = rect.bottom;

                        if (left > rect.left)
                            left = rect.left;

                        if (right < rect.right)
                            right = rect.right;

                        parts[0].classList.add('active');
                        parts[0].style.height = top + 'px';

                        parts[1].classList.add('active');
                        parts[1].style.top = top + 'px';
                        parts[1].style.bottom = (window.innerHeight - bottom) + 'px';
                        parts[1].style.width = (window.innerWidth - right) + 'px';

                        parts[2].classList.add('active');
                        parts[2].style.height = (window.innerHeight - bottom) + 'px';

                        parts[3].classList.add('active');
                        parts[3].style.top = top + 'px';
                        parts[3].style.bottom = (window.innerHeight - bottom) + 'px';
                        parts[3].style.width = left + 'px';

                        if (items[i].passThrough)
                            areas.style.pointerEvents = 'none';
                    } else {
                        items[i].element.style.left = (rect.left + 1) + 'px';
                        items[i].element.style.top = (rect.top + 1) + 'px';
                        items[i].element.style.width = (rect.width - 2) + 'px';
                        items[i].element.style.height = (rect.height - 2) + 'px';
                        items[i].ref.classList.add('drop-ref-highlight');
                    }
                } else {
                    items[i].element.style.display = 'none';

                    if (items[i].ref.classList.contains('drop-ref-highlight')) {
                        items[i].ref.classList.remove('drop-ref-highlight');
                        fixChromeFlexBox(items[i].ref);
                    }
                }
            }
        } else {
            for(var i = 0; i < parts.length; i++)
                parts[i].classList.remove('active');

            for(var i = 0; i < items.length; i++) {
                if (! items[i].ref.classList.contains('drop-ref-highlight'))
                    continue;

                items[i].ref.classList.remove('drop-ref-highlight');
                fixChromeFlexBox(items[i].ref);
            }
        }
    });
});


/* editor/cursor.js */
editor.once('load', function() {
    'use strict';

    var cursorType = '';

    editor.method('cursor:set', function(type) {
        if (cursorType === type)
            return;

        cursorType = type;
        document.body.style.setProperty('cursor', type, 'important');
        document.body.style.setProperty('cursor', '-moz-' + type, 'important');
        document.body.style.setProperty('cursor', '-webkit-' + type, 'important');
    });

    editor.method('cursor:clear', function() {
        if (! cursorType)
            return;

        cursorType = '';
        document.body.style.cursor = '';
    });

    var hiddenTime = 0;
    var tooltip = new ui.Label();
    tooltip.class.add('cursor-tooltip');
    tooltip.renderChanges = false;
    tooltip.hidden = true;
    editor.call('layout.root').append(tooltip);

    var lastX = 0;
    var lastY = 0;

    // move tooltip
    var onMove = function(evt) {
        lastX = evt.clientX;
        lastY = evt.clientY;

        if (tooltip.hidden && (Date.now() - hiddenTime) > 100)
            return;

        tooltip.style.transform = 'translate(' + evt.clientX + 'px,' + evt.clientY + 'px)';
    };
    window.addEventListener('mousemove', onMove, false);
    window.addEventListener('dragover', onMove, false);

    // set tooltip text
    editor.method('cursor:text', function(text) {
        if (text) tooltip.text = text;
        tooltip.hidden = ! text;

        tooltip.style.transform = 'translate(' + lastX + 'px,' + lastY + 'px)';

        if (! text)
            hiddenTime = Date.now();
    });
});


/* editor/datetime.js */
editor.once('load', function () {
    'use strict';

    // convert passed time to a local time with moment.js
    editor.method('datetime:convert', function (date) {
        return new Date(date).toLocaleString();
    });
});

/* realtime/share.uncompressed.js */
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.sharejs = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var Doc = require('./doc').Doc;
var Query = require('./query').Query;
var emitter = require('./emitter');


/**
 * Handles communication with the sharejs server and provides queries and
 * documents.
 *
 * We create a connection with a socket object
 *   connection = new sharejs.Connection(sockset)
 * The socket may be any object handling the websocket protocol. See the
 * documentation of bindToSocket() for details. We then wait for the connection
 * to connect
 *   connection.on('connected', ...)
 * and are finally able to work with shared documents
 *   connection.get('food', 'steak') // Doc
 *
 * @param socket @see bindToSocket
 */
var Connection = exports.Connection = function (socket) {
  emitter.EventEmitter.call(this);

  // Map of collection -> docName -> doc object for created documents.
  // (created documents MUST BE UNIQUE)
  this.collections = {};

  // Each query is created with an id that the server uses when it sends us
  // info about the query (updates, etc).
  //this.nextQueryId = (Math.random() * 1000) |0;
  this.nextQueryId = 1;

  // Map from query ID -> query object.
  this.queries = {};

  // State of the connection. The correspoding events are emmited when this
  // changes. Available states are:
  // - 'connecting'   The connection has been established, but we don't have our
  //                  client ID yet
  // - 'connected'    We have connected and recieved our client ID. Ready for data.
  // - 'disconnected' The connection is closed, but it will reconnect automatically.
  // - 'stopped'      The connection is closed, and should not reconnect.
  this.state = 'disconnected';

  // This is a helper variable the document uses to see whether we're currently
  // in a 'live' state. It is true if we're connected, or if you're using
  // browserchannel and connecting.
  this.canSend = false;

  // Private variable to support clearing of op retry interval
  this._retryInterval = null;

  // Reset some more state variables.
  this.reset();

  this.debug = false;

  // I'll store the most recent 100 messages so when errors occur we can see
  // what happened.
  this.messageBuffer = [];

  this.bindToSocket(socket);
}
emitter.mixin(Connection);


/**
 * Use socket to communicate with server
 *
 * Socket is an object that can handle the websocket protocol. This method
 * installs the onopen, onclose, onmessage and onerror handlers on the socket to
 * handle communication and sends messages by calling socket.send(msg). The
 * sockets `readyState` property is used to determine the initaial state.
 *
 * @param socket Handles the websocket protocol
 * @param socket.readyState
 * @param socket.close
 * @param socket.send
 * @param socket.onopen
 * @param socket.onclose
 * @param socket.onmessage
 * @param socket.onerror
 */
Connection.prototype.bindToSocket = function(socket) {
  if (this.socket) {
    delete this.socket.onopen
    delete this.socket.onclose
    delete this.socket.onmessage
    delete this.socket.onerror
  }

  // TODO: Check that the socket is in the 'connecting' state.

  this.socket = socket;
  // This logic is replicated in setState - consider calling setState here
  // instead.
  this.state = (socket.readyState === 0 || socket.readyState === 1) ? 'connecting' : 'disconnected';
  this.canSend = this.state === 'connecting' && socket.canSendWhileConnecting;
  this._setupRetry();

  var connection = this

  socket.onmessage = function(msg) {
    var data = msg.data;

    // Fall back to supporting old browserchannel 1.x API which implemented the
    // websocket API incorrectly. This will be removed at some point
    if (!data) data = msg;

    // Some transports don't need parsing.
    if (typeof data === 'string') data = JSON.parse(data);

    if (connection.debug) console.log('RECV', JSON.stringify(data));

    connection.messageBuffer.push({
      t: (new Date()).toTimeString(),
      recv:JSON.stringify(data)
    });
    while (connection.messageBuffer.length > 100) {
      connection.messageBuffer.shift();
    }

    try {
      connection.handleMessage(data);
    } catch (e) {
      connection.emit('error', e);
      // We could also restart the connection here, although that might result
      // in infinite reconnection bugs.
      throw e;
    }
  }

  socket.onopen = function() {
    connection._setState('connecting');
  };

  socket.onerror = function(e) {
    // This isn't the same as a regular error, because it will happen normally
    // from time to time. Your connection should probably automatically
    // reconnect anyway, but that should be triggered off onclose not onerror.
    // (onclose happens when onerror gets called anyway).
    connection.emit('connection error', e);
  };

  socket.onclose = function(reason) {
    connection._setState('disconnected', reason);
    if (reason === 'Closed' || reason === 'Stopped by server') {
      connection._setState('stopped', reason);
    }
  };
};


/**
 * @param {object} msg
 * @param {String} msg.a action
 */
Connection.prototype.handleMessage = function(msg) {
  // Switch on the message action. Most messages are for documents and are
  // handled in the doc class.
  switch (msg.a) {
    case 'init':
      // Client initialization packet. This bundle of joy contains our client
      // ID.
      if (msg.protocol !== 0) throw new Error('Invalid protocol version');
      if (typeof msg.id != 'string') throw new Error('Invalid client id');

      this.id = msg.id;
      this._setState('connected');
      break;

    case 'qfetch':
    case 'qsub':
    case 'q':
    case 'qunsub':
      // Query message. Pass this to the appropriate query object.
      var query = this.queries[msg.id];
      if (query) query._onMessage(msg);
      break;

    case 'bs':
      // Bulk subscribe response. The responses for each document are contained within.
      var result = msg.s;
      for (var cName in result) {
        for (var docName in result[cName]) {
          var doc = this.get(cName, docName);
          if (!doc) {
            if (console) console.error('Message for unknown doc. Ignoring.', msg);
            break;
          }

          var msg = result[cName][docName];
          if (typeof msg === 'object') {
            doc._handleSubscribe(msg.error, msg);
          } else {
            // The msg will be true if we simply resubscribed.
            doc._handleSubscribe(null, null);
          }
        }
      }
      break;

    default:
      // Document message. Pull out the referenced document and forward the
      // message.
      var collection, docName, doc;
      if (msg.d) {
        collection = this._lastReceivedCollection = msg.c;
        docName = this._lastReceivedDoc = msg.d;
      } else {
        collection = msg.c = this._lastReceivedCollection;
        docName = msg.d = this._lastReceivedDoc;
      }

      var doc = this.getExisting(collection, docName);
      if (doc) doc._onMessage(msg);
  }
};


Connection.prototype.reset = function() {
  this.id = this.lastError =
    this._lastReceivedCollection = this._lastReceivedDoc =
    this._lastSentCollection = this._lastSentDoc = null;

  this.seq = 1;
};


Connection.prototype._setupRetry = function() {
  if (!this.canSend) {
    clearInterval(this._retryInterval);
    this._retryInterval = null;
    return;
  }
  if (this._retryInterval != null) return;

  var connection = this;
  this._retryInterval = setInterval(function() {
    for (var collectionName in connection.collections) {
      var collection = connection.collections[collectionName];
      for (var docName in collection) {
        collection[docName].retry();
      }
    }
  }, 1000);
};


// Set the connection's state. The connection is basically a state machine.
Connection.prototype._setState = function(newState, data) {
  if (this.state === newState) return;

  // I made a state diagram. The only invalid transitions are getting to
  // 'connecting' from anywhere other than 'disconnected' and getting to
  // 'connected' from anywhere other than 'connecting'.
  if ((newState === 'connecting' && (this.state !== 'disconnected' && this.state !== 'stopped'))
      || (newState === 'connected' && this.state !== 'connecting')) {
    throw new Error("Cannot transition directly from " + this.state + " to " + newState);
  }

  this.state = newState;
  this.canSend = (newState === 'connecting' && this.socket.canSendWhileConnecting) || newState === 'connected';
  this._setupRetry();

  if (newState === 'disconnected') this.reset();

  this.emit(newState, data);

  var ignoreSubs = {};
  // No bulk subscribe for queries yet.
  for (var id in this.queries) {
    var query = this.queries[id];
    query._onConnectionStateChanged(newState, data);
    if (
      query.docMode === 'sub' &&
      (newState === 'connecting' || newState === 'connected')
    ) {
      var ignoreSubsCollection = ignoreSubs[query.collection] ||
        (ignoreSubs[query.collection] = {});
      for (var i = 0; i < query.results.length; i++) {
        ignoreSubsCollection[query.results[i].name] = true;
      }
    }
  }

  // & Emit the event to all documents & queries. It might make sense for
  // documents to just register for this stuff using events, but that couples
  // connections and documents a bit much. Its not a big deal either way.
  this.opQueue = [];
  this.bsStart();
  for (var c in this.collections) {
    var collection = this.collections[c];
    for (var docName in collection) {
      if (ignoreSubs[c] && ignoreSubs[c][docName]) continue;
      collection[docName]._onConnectionStateChanged(newState, data);
    }
  }

  // Its important that operations are resent in the same order that they were
  // originally sent. If we don't sort, an op with a high sequence number will
  // convince the server not to accept any ops with earlier sequence numbers.
  this.opQueue.sort(function(a, b) { return a.seq - b.seq; });
  for (var i = 0; i < this.opQueue.length; i++) {
    this.send(this.opQueue[i]);
  }

  this.opQueue = null;
  this.bsEnd();
};

// So, there's an awful error case where the client sends two requests (which
// fail), then reconnects. The documents could have _onConnectionStateChanged
// called in the wrong order and the operations then get sent with reversed
// sequence numbers. This causes the server to incorrectly reject the second
// sent op. So we need to queue the operations while we're reconnecting and
// resend them in the correct order.
Connection.prototype.sendOp = function(data) {
  if (this.opQueue) {
    this.opQueue.push(data);
  } else {
    this.send(data);
  }
};

Connection.prototype.bsStart = function() {
  this.subscribeData = {};
};

Connection.prototype.bsEnd = function() {
  // Only send bulk subscribe if not empty
  if (hasKeys(this.subscribeData)) {
    this.send({a:'bs', s:this.subscribeData});
  }
  this.subscribeData = null;
};

// This is called by the document class when the document wants to subscribe.
// We could just send a subscribe message, but during reconnect that causes a
// bajillion messages over browserchannel. During reconnect we'll aggregate,
// similar to sendOp.
Connection.prototype.sendSubscribe = function(collection, name, v) {
  if (this.subscribeData) {
    var data = this.subscribeData;
    if (!data[collection]) data[collection] = {};

    data[collection][name] = v || null;
  } else {
    var msg = {a:'sub', c:collection, d:name};
    if (v != null) msg.v = v;
    this.send(msg);
  }
};


/**
 * Sends a message down the socket
 */
Connection.prototype.send = function(msg) {
  if (this.debug) console.log("SEND", JSON.stringify(msg));
  this.messageBuffer.push({t:Date.now(), send:JSON.stringify(msg)});
  while (this.messageBuffer.length > 100) {
    this.messageBuffer.shift();
  }

  if (msg.d) { // The document the message refers to. Not set for queries.
    var collection = msg.c;
    var docName = msg.d;
    if (collection === this._lastSentCollection && docName === this._lastSentDoc) {
      delete msg.c;
      delete msg.d;
    } else {
      this._lastSentCollection = collection;
      this._lastSentDoc = docName;
    }
  }

  if (!this.socket.canSendJSON)
    msg = JSON.stringify(msg);

  this.socket.send(msg);
};


/**
 * Closes the socket and emits 'disconnected'
 */
Connection.prototype.disconnect = function() {
  this.socket.close();
};

Connection.prototype.getExisting = function(collection, name) {
  if (this.collections[collection]) return this.collections[collection][name];
};


/**
 * @deprecated
 */
Connection.prototype.getOrCreate = function(collection, name, data) {
  console.trace('getOrCreate is deprecated. Use get() instead');
  return this.get(collection, name, data);
};


/**
 * Get or create a document.
 *
 * @param collection
 * @param name
 * @param [data] ingested into document if created
 * @return {Doc}
 */
Connection.prototype.get = function(collection, name, data) {
  var collectionObject = this.collections[collection];
  if (!collectionObject)
    collectionObject = this.collections[collection] = {};

  var doc = collectionObject[name];
  if (!doc)
    doc = collectionObject[name] = new Doc(this, collection, name);

  // Even if the document isn't new, its possible the document was created
  // manually and then tried to be re-created with data (suppose a query
  // returns with data for the document). We should hydrate the document
  // immediately if we can because the query callback will expect the document
  // to have data.
  if (data && data.data !== undefined && !doc.state)
    doc.ingestData(data);

  return doc;
};


/**
 * Remove document from this.collections
 *
 * @private
 */
Connection.prototype._destroyDoc = function(doc) {
  var collectionObject = this.collections[doc.collection];
  if (!collectionObject) return;

  delete collectionObject[doc.name];

  // Delete the collection container if its empty. This could be a source of
  // memory leaks if you slowly make a billion collections, which you probably
  // won't do anyway, but whatever.
  if (!hasKeys(collectionObject))
    delete this.collections[doc.collection];
};


function hasKeys(object) {
  for (var key in object) return true;
  return false;
};


// Helper for createFetchQuery and createSubscribeQuery, below.
Connection.prototype._createQuery = function(type, collection, q, options, callback) {
  if (type !== 'fetch' && type !== 'sub')
    throw new Error('Invalid query type: ' + type);

  if (!options) options = {};
  var id = this.nextQueryId++;
  var query = new Query(type, this, id, collection, q, options, callback);
  this.queries[id] = query;
  query._execute();
  return query;
};

// Internal function. Use query.destroy() to remove queries.
Connection.prototype._destroyQuery = function(query) {
  delete this.queries[query.id];
};

// The query options object can contain the following fields:
//
// docMode: What to do with documents that are in the result set. Can be
//   null/undefined (default), 'fetch' or 'subscribe'. Fetch mode indicates
//   that the server should send document snapshots to the client for all query
//   results. These will be hydrated into the document objects before the query
//   result callbacks are returned. Subscribe mode gets document snapshots and
//   automatically subscribes the client to all results. Note that the
//   documents *WILL NOT* be automatically unsubscribed when the query is
//   destroyed. (ShareJS doesn't have enough information to do that safely).
//   Beware of memory leaks when using this option.
//
// poll: Forcably enable or disable polling mode. Polling mode will reissue the query
//   every time anything in the collection changes (!!) so, its quite
//   expensive.  It is automatically enabled for paginated and sorted queries.
//   By default queries run with polling mode disabled; which will only check
//   changed documents to test if they now match the specified query.
//   Set to false to disable polling mode, or true to enable it. If you don't
//   specify a poll option, polling mode is enabled or disabled automatically
//   by the query's backend.
//
// backend: Set the backend source for the query. You can attach different
//   query backends to livedb and pick which one the query should hit using
//   this parameter.
//
// results: (experimental) Initial list of resultant documents. This is
//   useful for rehydrating queries when you're using autoFetch / autoSubscribe
//   so the server doesn't have to send over snapshots for documents the client
//   already knows about. This is experimental - the API may change in upcoming
//   versions.

// Create a fetch query. Fetch queries are only issued once, returning the
// results directly into the callback.
//
// The index is specific to the source, but if you're using mongodb it'll be
// the collection to which the query is made.
// The callback should have the signature function(error, results, extraData)
// where results is a list of Doc objects.
Connection.prototype.createFetchQuery = function(index, q, options, callback) {
  return this._createQuery('fetch', index, q, options, callback);
};

// Create a subscribe query. Subscribe queries return with the initial data
// through the callback, then update themselves whenever the query result set
// changes via their own event emitter.
//
// If present, the callback should have the signature function(error, results, extraData)
// where results is a list of Doc objects.
Connection.prototype.createSubscribeQuery = function(index, q, options, callback) {
  return this._createQuery('sub', index, q, options, callback);
};

},{"./doc":2,"./emitter":3,"./query":5}],2:[function(require,module,exports){
var types = require('../types').ottypes;
var emitter = require('./emitter');

/**
 * A Doc is a client's view on a sharejs document.
 *
 * It is is uniquely identified by its `name` and `collection`.  Documents
 * should not be created directly. Create them with Connection.get()
 *
 *
 *
 * Subscriptions
 * -------------
 *
 * We can subscribe a document to stay in sync with the server.
 *   doc.subscribe(function(error) {
 *     doc.state // = 'ready'
 *     doc.subscribed // = true
 *   })
 * The server now sends us all changes concerning this document and these are
 * applied to our snapshot. If the subscription was successful the initial
 * snapshot and version sent by the server are loaded into the document.
 *
 * To stop listening to the changes we call `doc.unsubscribe()`.
 *
 * If we just want to load the data but not stay up-to-date, we call
 *   doc.fetch(function(error) {
 *     doc.snapshot // sent by server
 *   })
 *
 * TODO What happens when the document does not exist yet.
 *
 *
 *
 * Editing documents
 * ------------------
 *
 * To edit a document we have to create an editing context
 *   context = doc.context()
 * The context is an object exposing the type API of the documents OT type.
 *   doc.type = 'text'
 *   context.insert(0, 'In the beginning')
 *   doc.snapshot // 'In the beginning...'
 *
 * If a operation is applied on the snapshot the `_onOp` on the context is
 * called. The type implementation then usually triggers a corresponding event.
 *
 *
 *
 *
 * Events
 * ------
 *
 * You can use doc.on(eventName, callback) to subscribe to the following events:
 * - `before op (op, localContext)` Fired before an operation is applied to the
 *   snapshot. The document is already in locked state, so it is not allowed to
 *   submit further operations. It may be used to read the old snapshot just
 *   before applying an operation. The callback is passed the operation and the
 *   editing context if the operation originated locally and `false` otherwise
 * - `after op (op, localContext)` Fired after an operation has been applied to
 *   the snapshot. The arguments are the same as for `before op`
 * - `op (op, localContext)` The same as `after op` unless incremental updates
 *   are enabled. In this case it is fired after every partial operation with
 *   this operation as the first argument. When fired the document is in a
 *   locked state which only allows reading operations.
 * - `subscribed (error)` The document was subscribed
 * - `created (localContext)` The document was created. That means its type was
 *   set and it has some initial data.
 * - `del (localContext, snapshot)` Fired after the document is deleted, that is
 *   the snapshot is null. It is passed the snapshot before delteion as an
 *   arguments
 * - `error`
 *
 * TODO rename `op` to `after partial op`
 */
var Doc = exports.Doc = function(connection, collection, name) {
  emitter.EventEmitter.call(this);

  this.connection = connection;

  this.collection = collection;
  this.name = name;

  this.version = this.type = null;
  this.snapshot = undefined;

  // **** State in document:

  // The action the document tries to perform with the server
  //
  // - subscribe
  // - unsubscribe
  // - fetch
  // - submit: send an operation
  this.action = null;

  // The data the document object stores can be in one of the following three states:
  //   - No data. (null) We honestly don't know whats going on.
  //   - Floating ('floating'): we have a locally created document that hasn't
  //     been created on the server yet)
  //   - Live ('ready') (we have data thats current on the server at some version).
  this.state = null;

  // Our subscription status. Either we're subscribed on the server, or we aren't.
  this.subscribed = false;
  // Either we want to be subscribed (true), we want a new snapshot from the
  // server ('fetch'), or we don't care (false).  This is also used when we
  // disconnect & reconnect to decide what to do.
  this.wantSubscribe = false;
  // This list is used for subscribe and unsubscribe, since we'll only want to
  // do one thing at a time.
  this._subscribeCallbacks = [];


  // *** end state stuff.

  // This doesn't provide any standard API access right now.
  this.provides = {};

  // The editing contexts. These are usually instances of the type API when the
  // document is ready for edits.
  this.editingContexts = [];

  // The op that is currently roundtripping to the server, or null.
  //
  // When the connection reconnects, the inflight op is resubmitted.
  //
  // This has the same format as an entry in pendingData, which is:
  // {[create:{...}], [del:true], [op:...], callbacks:[...], src:, seq:}
  this.inflightData = null;

  // All ops that are waiting for the server to acknowledge @inflightData
  // This used to just be a single operation, but creates & deletes can't be composed with
  // regular operations.
  //
  // This is a list of {[create:{...}], [del:true], [op:...], callbacks:[...]}
  this.pendingData = [];

  // The OT type of this document.
  //
  // The document also responds to the api provided by the type
  this.type = null
};
emitter.mixin(Doc);

/**
 * Unsubscribe and remove all editing contexts
 */
Doc.prototype.destroy = function(callback) {
  var doc = this;
  this.unsubscribe(function() {
    // Don't care if there's an error unsubscribing.

    if (doc.hasPending()) {
      doc.once('nothing pending', function() {
        doc.connection._destroyDoc(doc);
      });
    } else {
      doc.connection._destroyDoc(doc);
    }
    doc.removeContexts();
    if (callback) callback();
  });
};


// ****** Manipulating the document snapshot, version and type.

// Set the document's type, and associated properties. Most of the logic in
// this function exists to update the document based on any added & removed API
// methods.
//
// @param newType OT type provided by the ottypes library or its name or uri
Doc.prototype._setType = function(newType) {
  if (typeof newType === 'string') {
    if (!types[newType]) throw new Error("Missing type " + newType + ' ' + this.collection + ' ' + this.name);
    newType = types[newType];
  }
  this.removeContexts();

  // Set the new type
  this.type = newType;

  // If we removed the type from the object, also remove its snapshot.
  if (!newType) {
    this.provides = {};
    this.snapshot = undefined;
  } else if (newType.api) {
    // Register the new type's API.
    this.provides = newType.api.provides;
  }
};

// Injest snapshot data. This data must include a version, snapshot and type.
// This is used both to ingest data that was exported with a webpage and data
// that was received from the server during a fetch.
//
// @param data.v    version
// @param data.data
// @param data.type
// @fires ready
Doc.prototype.ingestData = function(data) {
  if (typeof data.v !== 'number') {
    throw new Error('Missing version in ingested data ' + this.collection + ' ' + this.name);
  }
  if (this.state) {
    // Silently ignore if doc snapshot version is equal or newer
    // TODO: Investigate whether this should happen in practice or not
    if (this.version >= data.v) return;
    console.warn('Ignoring ingest data for', this.collection, this.name,
      '\n  in state:', this.state, '\n  version:', this.version,
      '\n  snapshot:\n', this.snapshot, '\n  incoming data:\n', data);
    return;
  }

  this.version = data.v;
  // data.data is what the server will actually send. data.snapshot is the old
  // field name - supported now for backwards compatibility.
  this.snapshot = data.data;
  this._setType(data.type);

  this.state = 'ready';
  this.emit('ready');
};

// Get and return the current document snapshot.
Doc.prototype.getSnapshot = function() {
  return this.snapshot;
};

// The callback will be called at a time when the document has a snapshot and
// you can start applying operations. This may be immediately.
Doc.prototype.whenReady = function(fn) {
  if (this.state === 'ready') {
    fn();
  } else {
    this.once('ready', fn);
  }
};

Doc.prototype.retry = function() {
  if (!this.inflightData) return;
  var threshold = 5000 * Math.pow(2, this.inflightData.retries);
  if (this.inflightData.sentAt < Date.now() - threshold) {
    this.connection.emit('retry', this);
    this._clearAction();
  }
};

Doc.prototype.hasPending = function() {
  return this.action != null || this.inflightData != null || !!this.pendingData.length;
};


// **** Helpers for network messages

// Send a message to the connection from this document.
Doc.prototype._send = function(message) {
  message.c = this.collection;
  message.d = this.name;
  this.connection.send(message);
};

// This function exists so connection can call it directly for bulk subscribes.
// It could just make a temporary object literal, thats pretty slow.
Doc.prototype._handleSubscribe = function(err, data) {
  if (err && err !== 'Already subscribed') {
    console.error('Could not subscribe:', err, this.collection, this.name);
    this.emit('error', err);
    // There's probably a reason we couldn't subscribe. Don't retry.
    this._setWantSubscribe(false, null, err);
    return;
  }
  if (data) this.ingestData(data);
  this.subscribed = true;
  this._clearAction();
  this.emit('subscribe');
  this._finishSub();
};

Doc.prototype._finishQuerySubscribe = function(version) {
  // This generally shouldn't happen, but in a race condition where we
  // missed a an op, just subscribe to the specific doc again
  if (version > this.version) return this.subscribe();

  // Fake out a doc subscription, since we are already up to date
  this.subscribed = true;
  this.wantSubscribe = true;
  this.emit('subscribe');
  this._finishSub();
};

// This is called by the connection when it receives a message for the document.
Doc.prototype._onMessage = function(msg) {
  if (!(msg.c === this.collection && msg.d === this.name)) {
    // This should never happen - its a sanity check for bugs in the connection code.
    throw new Error('Got message for wrong document. ' + this.collection + ' ' + this.name);
  }

  // msg.a = the action.
  switch (msg.a) {
    case 'fetch':
      // We're done fetching. This message has no other information.
      if (msg.data) this.ingestData(msg.data);
      if (this.wantSubscribe === 'fetch') this.wantSubscribe = false;
      this._clearAction();
      this._finishSub(msg.error);
      break;

    case 'sub':
      // Subscribe reply.
      this._handleSubscribe(msg.error, msg.data);
      break;

    case 'unsub':
      // Unsubscribe reply
      this.subscribed = false;
      this.emit('unsubscribe');

      this._clearAction();
      this._finishSub(msg.error);
      break;

    case 'ack':
      // Acknowledge a locally submitted operation.
      //
      // Usually we do nothing here - all the interesting logic happens when we
      // get sent our op back in the op stream (which happens even if we aren't
      // subscribed)
      if (msg.error && msg.error !== 'Op already submitted') {
        // The server has rejected an op from the client for an unexpected reason.
        // We'll send the error message to the user and try to roll back the change.
        if (this.inflightData) {
          console.warn('Operation was rejected (' + msg.error + '). Trying to rollback change locally.');
          this._tryRollback(this.inflightData);
          this._clearInflightOp(msg.error);
        } else {
          // I managed to get into this state once. I'm not sure how it happened.
          // The op was maybe double-acknowledged?
          console.warn('Second acknowledgement message (error) received', msg, this);
        }
      }
      break;

    case 'op':
      if (this.inflightData &&
          msg.src === this.inflightData.src &&
          msg.seq === this.inflightData.seq) {
        // This one is mine. Accept it as acknowledged.
        this._opAcknowledged(msg);
        break;
      }

      if (msg.v < this.version) {
        // This will happen naturally in the following (or similar) cases:
        //
        // Client is not subscribed to document.
        // -> client submits an operation (v=10)
        // -> client subscribes to a query which matches this document. Says we
        //    have v=10 of the doc.
        //
        // <- server acknowledges the operation (v=11). Server acknowledges the
        //    operation because the doc isn't subscribed
        // <- server processes the query, which says the client only has v=10.
        //    Server subscribes at v=10 not v=11, so we get another copy of the
        //    v=10 operation.
        //
        // In this case, we can safely ignore the old (duplicate) operation.
        break;
      }

      if (msg.v > this.version) {
        // If we get in here, it means we missed an operation from the server,
        // or operations are being sent to the client out of order. This
        // *should* never happen, but it currently does because of a bug in the
        // way the query code & doc class interact. If you have a document at
        // an old version (and not subscribed), when the document matches a
        // query the query will send the client a snapshot of the document
        // instead of the operations in between.
        console.warn("Client got future operation from the server",
            this.collection, this.name, msg);

        // Get the operations we missed and catch up
        this._getLatestOps();
        break;
      }

      if (this.inflightData) xf(this.inflightData, msg);

      for (var i = 0; i < this.pendingData.length; i++) {
        xf(this.pendingData[i], msg);
      }

      this.version++;
      this._otApply(msg, false);
      break;

    case 'meta':
      console.warn('Unhandled meta op:', msg);
      break;

    default:
      console.warn('Unhandled document message:', msg);
      break;
  }
};

Doc.prototype._getLatestOps = function() {
  this._send({a: 'fetch', v: this.version});
};

// Called whenever (you guessed it!) the connection state changes. This will
// happen when we get disconnected & reconnect.
Doc.prototype._onConnectionStateChanged = function(state, reason) {
  if (state === 'connecting' || state === 'connected') {
    // We go into the connected state once we have a sessionID. We can't send
    // new ops until then, so we need to flush again on connected
    this.flush();
  } else if (state === 'disconnected') {
    this._clearAction();
    this.subscribed = false;
  }
};


Doc.prototype._clearAction = function() {
  this.action = null;
  this.flush();

  if (!this.hasPending()) {
    this.emit('nothing pending');
  }
};

// Send the next pending op to the server, if we can.
//
// Only one operation can be in-flight at a time. If an operation is already on
// its way, or we're not currently connected, this method does nothing.
Doc.prototype.flush = function() {
  if (!this.connection.canSend || this.action) return;

  if (this.inflightData) {
    this._sendOpData();
    return;
  }

  var opData;
  // Pump and dump any no-ops from the front of the pending op list.
  while (this.pendingData.length && isNoOp(opData = this.pendingData[0])) {
    var callbacks = opData.callbacks;
    for (var i = 0; i < callbacks.length; i++) {
      callbacks[i](opData.error);
    }
    this.pendingData.shift();
  }

  // We consider sending operations before considering subscribing because its
  // convenient in access control code to not need to worry about subscribing
  // to documents that don't exist.
  if (!this.paused && this.pendingData.length && this.connection.state === 'connected') {
    // Try and send any pending ops. We can't send ops while in
    this.inflightData = this.pendingData.shift();
    // This also sets action to 'submit'.
    this._sendOpData();
  } else if (this.subscribed && !this.wantSubscribe) {
    this.action = 'unsubscribe';
    this._send({a:'unsub'});
  } else if (!this.subscribed && this.wantSubscribe === 'fetch') {
    this.action = 'fetch';
    this._send(this.state === 'ready' ? {a:'fetch', v:this.version} : {a:'fetch'});
  } else if (!this.subscribed && this.wantSubscribe) {
    this.action = 'subscribe';
    // Special send method needed for bulk subscribes on reconnect.
    this.connection.sendSubscribe(this.collection, this.name, this.state === 'ready' ? this.version : null);
  }
};


// ****** Subscribing, unsubscribing and fetching

// These functions iare copied into the query class as well, so be careful making
// changes here.

// Value is true, false or 'fetch'.
Doc.prototype._setWantSubscribe = function(value, callback, err) {
  if (this.subscribed === this.wantSubscribe &&
      (this.subscribed === value || value === 'fetch' && this.subscribed)) {
    if (callback) callback(err);
    return;
  }

  // If we want to subscribe, don't weaken it to a fetch.
  if (value !== 'fetch' || this.wantSubscribe !== true)
    this.wantSubscribe = value;

  if (callback) this._subscribeCallbacks.push(callback);
  this.flush();
};

// Open the document. There is no callback and no error handling if you're
// already connected.
//
// Only call this once per document.
Doc.prototype.subscribe = function(callback) {
  this._setWantSubscribe(true, callback);
};

// Unsubscribe. The data will stay around in local memory, but we'll stop
// receiving updates.
Doc.prototype.unsubscribe = function(callback) {
  this._setWantSubscribe(false, callback);
};

// Call to request fresh data from the server.
Doc.prototype.fetch = function(callback) {
  this._setWantSubscribe('fetch', callback);
};

// Called when our subscribe, fetch or unsubscribe messages are acknowledged.
Doc.prototype._finishSub = function(err) {
  if (!this._subscribeCallbacks.length) return;
  for (var i = 0; i < this._subscribeCallbacks.length; i++) {
    this._subscribeCallbacks[i](err);
  }
  this._subscribeCallbacks.length = 0;
};


// Operations


// ************ Dealing with operations.

// Helper function to set opData to contain a no-op.
var setNoOp = function(opData) {
  delete opData.op;
  delete opData.create;
  delete opData.del;
};

var isNoOp = function(opData) {
  return !opData.op && !opData.create && !opData.del;
}

// Try to compose data2 into data1. Returns truthy if it succeeds, otherwise falsy.
var tryCompose = function(type, data1, data2) {
  if (data1.create && data2.del) {
    setNoOp(data1);
  } else if (data1.create && data2.op) {
    // Compose the data into the create data.
    var data = (data1.create.data === undefined) ? type.create() : data1.create.data;
    data1.create.data = type.apply(data, data2.op);
  } else if (isNoOp(data1)) {
    data1.create = data2.create;
    data1.del = data2.del;
    data1.op = data2.op;
  } else if (data1.op && data2.op && type.compose) {
    data1.op = type.compose(data1.op, data2.op);
  } else {
    return false;
  }
  return true;
};

// Transform server op data by a client op, and vice versa. Ops are edited in place.
var xf = function(client, server) {
  // In this case, we're in for some fun. There are some local operations
  // which are totally invalid - either the client continued editing a
  // document that someone else deleted or a document was created both on the
  // client and on the server. In either case, the local document is way
  // invalid and the client's ops are useless.
  //
  // The client becomes a no-op, and we keep the server op entirely.
  if (server.create || server.del) return setNoOp(client);
  if (client.create) throw new Error('Invalid state. This is a bug. ' + this.collection + ' ' + this.name);

  // The client has deleted the document while the server edited it. Kill the
  // server's op.
  if (client.del) return setNoOp(server);

  // We only get here if either the server or client ops are no-op. Carry on,
  // nothing to see here.
  if (!server.op || !client.op) return;

  // They both edited the document. This is the normal case for this function -
  // as in, most of the time we'll end up down here.
  //
  // You should be wondering why I'm using client.type instead of this.type.
  // The reason is, if we get ops at an old version of the document, this.type
  // might be undefined or a totally different type. By pinning the type to the
  // op data, we make sure the right type has its transform function called.
  if (client.type.transformX) {
    var result = client.type.transformX(client.op, server.op);
    client.op = result[0];
    server.op = result[1];
  } else {
    var _c = client.type.transform(client.op, server.op, 'left');
    var _s = client.type.transform(server.op, client.op, 'right');
    client.op = _c; server.op = _s;
  }
};

/**
 * Applies the operation to the snapshot
 *
 * If the operation is create or delete it emits `create` or `del`.  Then the
 * operation is applied to the snapshot and `op` and `after op` are emitted.  If
 * the type supports incremental updates and `this.incremental` is true we fire
 * `op` after every small operation.
 *
 * This is the only function to fire the above mentioned events.
 *
 * @private
 */
Doc.prototype._otApply = function(opData, context) {
  this.locked = true;

  if (opData.create) {
    // If the type is currently set, it means we tried creating the document
    // and someone else won. client create x server create = server create.
    var create = opData.create;
    this._setType(create.type);
    this.snapshot = this.type.create(create.data);

    // This is a bit heavyweight, but I want the created event to fire outside of the lock.
    this.once('unlock', function() {
      this.emit('create', context);
    });
  } else if (opData.del) {
    // The type should always exist in this case. del x _ = del
    var oldSnapshot = this.snapshot;
    this._setType(null);
    this.once('unlock', function() {
      this.emit('del', context, oldSnapshot);
    });
  } else if (opData.op) {
    if (!this.type) throw new Error('Document does not exist. ' + this.collection + ' ' + this.name);

    var type = this.type;

    var op = opData.op;

    // The context needs to be told we're about to edit, just in case it needs
    // to store any extra data. (text-tp2 has this constraint.)
    for (var i = 0; i < this.editingContexts.length; i++) {
      var c = this.editingContexts[i];
      if (c != context && c._beforeOp) c._beforeOp(opData.op);
    }

    this.emit('before op', op, context);

    // This exists so clients can pull any necessary data out of the snapshot
    // before it gets changed.  Previously we kept the old snapshot object and
    // passed it to the op event handler. However, apply no longer guarantees
    // the old object is still valid.
    //
    // Because this could be totally unnecessary work, its behind a flag. set
    // doc.incremental to enable.
    if (this.incremental && type.incrementalApply) {
      var _this = this;
      type.incrementalApply(this.snapshot, op, function(o, snapshot) {
        _this.snapshot = snapshot;
        _this.emit('op', o, context);
      });
    } else {
      // This is the most common case, simply applying the operation to the local snapshot.
      this.snapshot = type.apply(this.snapshot, op);
      this.emit('op', op, context);
    }
  }
  // Its possible for none of the above cases to match, in which case the op is
  // a no-op. This will happen when a document has been deleted locally and
  // remote ops edit the document.


  this.locked = false;
  this.emit('unlock');

  if (opData.op) {
    var contexts = this.editingContexts;
    // Notify all the contexts about the op (well, all the contexts except
    // the one which initiated the submit in the first place).
    // NOTE Handle this with events?
    for (var i = 0; i < contexts.length; i++) {
      var c = contexts[i];
      if (c != context && c._onOp) c._onOp(opData.op);
    }
    for (var i = 0; i < contexts.length; i++) {
      if (contexts[i].shouldBeRemoved) contexts.splice(i--, 1);
    }

    return this.emit('after op', opData.op, context);
  }
};



// ***** Sending operations


// Actually send op data to the server.
Doc.prototype._sendOpData = function() {
  var d = this.inflightData;

  if (this.action) throw new Error('Invalid state ' + this.action + ' for sendOpData. ' + this.collection + ' ' + this.name);
  this.action = 'submit';
  d.sentAt = Date.now();
  d.retries = (d.retries == null) ? 0 : d.retries + 1;

  var msg = {a:'op', v:this.version};
  if (d.src) {
    msg.src = d.src;
    msg.seq = d.seq;
  }

  if (d.op) msg.op = d.op;
  if (d.create) msg.create = d.create;
  if (d.del) msg.del = d.del;

  msg.c = this.collection;
  msg.d = this.name;

  this.connection.sendOp(msg);

  // The first time we send an op, its id and sequence number is implicit.
  if (!d.src) {
    d.src = this.connection.id;
    d.seq = this.connection.seq++;
  }
};


// Queues the operation for submission to the server and applies it locally.
//
// Internal method called to do the actual work for submitOp(), create() and del().
// @private
//
// @param opData
// @param [opData.op]
// @param [opData.del]
// @param [opData.create]
// @param [context] the editing context
// @param [callback] called when operation is submitted
Doc.prototype._submitOpData = function(opData, context, callback) {
  if (typeof context === 'function') {
    callback = context;
    context = true; // The default context is true.
  }
  if (context == null) context = true;

  var error = function(err) {
    if (callback) return callback(err);
    console.warn('Failed attempt to submitOp:', err);
  };

  if (this.locked) {
    return error("Cannot call submitOp from inside an 'op' event handler. " + this.collection + ' ' + this.name);
  }

  // The opData contains either op, create, delete, or none of the above (a no-op).
  if (opData.op) {
    if (!this.type) return error('Document has not been created');
    // Try to normalize the op. This removes trailing skip:0's and things like that.
    if (this.type.normalize) opData.op = this.type.normalize(opData.op);
  }

  if (!this.state) {
    this.state = 'floating';
  }

  opData.type = this.type;
  opData.callbacks = [];

  // If the type supports composes, try to compose the operation onto the end
  // of the last pending operation.
  var operation;
  var previous = this.pendingData[this.pendingData.length - 1];

  if (previous && tryCompose(this.type, previous, opData)) {
    operation = previous;
  } else {
    operation = opData;
    this.pendingData.push(opData);
  }
  if (callback) operation.callbacks.push(callback);

  this._otApply(opData, context);

  // The call to flush is in a timeout so if submitOp() is called multiple
  // times in a closure all the ops are combined before being sent to the
  // server. It doesn't matter if flush is called a bunch of times.
  var _this = this;
  setTimeout((function() { _this.flush(); }), 0);
};


// *** Client OT entrypoints.

// Submit an operation to the document.
//
// @param operation handled by the OT type
// @param [context] editing context
// @param [callback] called after operation submitted
//
// @fires before op, op, after op
Doc.prototype.submitOp = function(op, context, callback) {
  this._submitOpData({op: op}, context, callback);
};

// Create the document, which in ShareJS semantics means to set its type. Every
// object implicitly exists in the database but has no data and no type. Create
// sets the type of the object and can optionally set some initial data on the
// object, depending on the type.
//
// @param type  OT type
// @param data  initial
// @param context  editing context
// @param callback  called when operation submitted
Doc.prototype.create = function(type, data, context, callback) {
  if (typeof data === 'function') {
    // Setting the context to be the callback function in this case so _submitOpData
    // can handle the default value thing.
    context = data;
    data = undefined;
  }

  var op = {create: {type:type, data:data}};
  if (this.type) {
    if (callback) callback('Document already exists', this._opErrorContext(op));
    return
  }

  this._submitOpData(op, context, callback);
};

// Delete the document. This creates and submits a delete operation to the
// server. Deleting resets the object's type to null and deletes its data. The
// document still exists, and still has the version it used to have before you
// deleted it (well, old version +1).
//
// @param context   editing context
// @param callback  called when operation submitted
Doc.prototype.del = function(context, callback) {
  if (!this.type) {
    if (callback) callback('Document does not exist');
    return;
  }

  this._submitOpData({del: true}, context, callback);
};


// Stops the document from sending any operations to the server.
Doc.prototype.pause = function() {
  this.paused = true;
};

// Continue sending operations to the server
Doc.prototype.resume = function() {
  this.paused = false;
  this.flush();
};


// *** Receiving operations


// This will be called when the server rejects our operations for some reason.
// There's not much we can do here if the OT type is noninvertable, but that
// shouldn't happen too much in real life because readonly documents should be
// flagged as such. (I should probably figure out a flag for that).
//
// This does NOT get called if our op fails to reach the server for some reason
// - we optimistically assume it'll make it there eventually.
Doc.prototype._tryRollback = function(opData) {
  // This is probably horribly broken.
  if (opData.create) {
    this._setType(null);

    // I don't think its possible to get here if we aren't in a floating state.
    if (this.state === 'floating')
      this.state = null;
    else
      console.warn('Rollback a create from state ' + this.state);

  } else if (opData.op && opData.type.invert) {
    opData.op = opData.type.invert(opData.op);

    // Transform the undo operation by any pending ops.
    for (var i = 0; i < this.pendingData.length; i++) {
      xf(this.pendingData[i], opData);
    }

    // ... and apply it locally, reverting the changes.
    //
    // This operation is applied to look like it comes from a remote context.
    // I'm still not 100% sure about this functionality, because its really a
    // local op. Basically, the problem is that if the client's op is rejected
    // by the server, the editor window should update to reflect the undo.
    this._otApply(opData, false);
  } else if (opData.op || opData.del) {
    // This is where an undo stack would come in handy.
    this._setType(null);
    this.version = null;
    this.state = null;
    this.subscribed = false;
    this.emit('error', "Op apply failed and the operation could not be reverted");

    // Trigger a fetch. In our invalid state, we can't really do anything.
    this.fetch();
    this.flush();
  }
};

Doc.prototype._opErrorContext = function(op) {
  return {
    collection: this.collection,
    name: this.name,
    opData: op || this.inflightData
  };
};

Doc.prototype._clearInflightOp = function(error) {
  var callbacks = this.inflightData.callbacks;
  var context = this._opErrorContext();
  // There's no nice way to pass this context back to the caller - I settled on
  // using simple strings for error messages, and now this is hurting me. I'll
  // fix this API in sharejs 0.8.
  for (var i = 0; i < callbacks.length; i++) {
    callbacks[i](error || this.inflightData.error, context);
  }

  this.inflightData = null;
  this._clearAction();
};

// This is called when the server acknowledges an operation from the client.
Doc.prototype._opAcknowledged = function(msg) {
  // Our inflight op has been acknowledged, so we can throw away the inflight data.
  // (We were only holding on to it incase we needed to resend the op.)
  if (!this.state) {
    throw new Error('opAcknowledged called from a null state. This should never happen. ' + this.collection + ' ' + this.name);
  } else if (this.state === 'floating') {
    if (!this.inflightData.create) throw new Error('Cannot acknowledge an op. ' + this.collection + ' ' + this.name);

    // Our create has been acknowledged. This is the same as ingesting some data.
    this.version = msg.v;
    this.state = 'ready';
    var _this = this;
    setTimeout(function() { _this.emit('ready'); }, 0);
  } else {
    // We already have a snapshot. The snapshot should be at the acknowledged
    // version, because the server has sent us all the ops that have happened
    // before acknowledging our op.

    // This should never happen - something is out of order.
    if (msg.v !== this.version) {
      throw new Error('Invalid version from server. This can happen when you submit ops in a submitOp callback. Expected: ' + this.version + ' Message version: ' + msg.v + ' ' + this.collection + ' ' + this.name);
    }
  }

  // The op was committed successfully. Increment the version number
  this.version++;

  this._clearInflightOp();
};


// Creates an editing context
//
// The context is an object responding to getSnapshot(), submitOp() and
// destroy(). It also has all the methods from the OT type mixed in.
// If the document is destroyed, the detach() method is called on the context.
Doc.prototype.createContext = function() {
  var type = this.type;
  if (!type) throw new Error('Missing type ' + this.collection + ' ' + this.name);

  // I could use the prototype chain to do this instead, but Object.create
  // isn't defined on old browsers. This will be fine.
  var doc = this;
  var context = {
    getSnapshot: function() {
      return doc.snapshot;
    },
    submitOp: function(op, callback) {
      doc.submitOp(op, context, callback);
    },
    destroy: function() {
      if (this.detach) {
        this.detach();
        // Don't double-detach.
        delete this.detach;
      }
      // It will be removed from the actual editingContexts list next time
      // we receive an op on the document (and the list is iterated through).
      //
      // This is potentially dodgy, allowing a memory leak if you create &
      // destroy a whole bunch of contexts without receiving or sending any ops
      // to the document.
      //
      // NOTE Why can't we destroy contexts immediately?
      delete this._onOp;
      this.shouldBeRemoved = true;
    },

    // This is dangerous, but really really useful for debugging. I hope people
    // don't depend on it.
    _doc: this,
  };

  if (type.api) {
    // Copy everything else from the type's API into the editing context.
    for (var k in type.api) {
      context[k] = type.api[k];
    }
  } else {
    context.provides = {};
  }

  this.editingContexts.push(context);

  return context;
};


/**
 * Destroy all editing contexts
 */
Doc.prototype.removeContexts = function() {
  for (var i = 0; i < this.editingContexts.length; i++) {
    this.editingContexts[i].destroy();
  }
  this.editingContexts.length = 0;
};

},{"../types":7,"./emitter":3}],3:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;

exports.EventEmitter = EventEmitter;
exports.mixin = mixin;

function mixin(Constructor) {
  for (var key in EventEmitter.prototype) {
    Constructor.prototype[key] = EventEmitter.prototype[key];
  }
}

},{"events":10}],4:[function(require,module,exports){
// Entry point for the client
//
// Usage:
//
//    <script src="dist/share.js"></script>

exports.Connection = require('./connection').Connection;
exports.Doc = require('./doc').Doc;
require('./textarea');

var types = require('../types');
exports.ottypes = types.ottypes;
exports.registerType = types.registerType;

},{"../types":7,"./connection":1,"./doc":2,"./textarea":6}],5:[function(require,module,exports){
var emitter = require('./emitter');

// Queries are live requests to the database for particular sets of fields.
//
// The server actively tells the client when there's new data that matches
// a set of conditions.
var Query = exports.Query = function(type, connection, id, collection, query, options, callback) {
  emitter.EventEmitter.call(this);

  // 'fetch' or 'sub'
  this.type = type;

  this.connection = connection;
  this.id = id;
  this.collection = collection;

  // The query itself. For mongo, this should look something like {"data.x":5}
  this.query = query;

  // Resultant document action for the server. Fetch mode will automatically
  // fetch all results. Subscribe mode will automatically subscribe all
  // results. Results are never unsubscribed.
  this.docMode = options.docMode; // undefined, 'fetch' or 'sub'.
  if (this.docMode === 'subscribe') this.docMode = 'sub';

  // Do we repoll the entire query whenever anything changes? (As opposed to
  // just polling the changed item). This needs to be enabled to be able to use
  // ordered queries (sortby:) and paginated queries. Set to undefined, it will
  // be enabled / disabled automatically based on the query's properties.
  this.poll = options.poll;

  // The backend we actually hit. If this isn't defined, it hits the snapshot
  // database. Otherwise this can be used to hit another configured query
  // index.
  this.backend = options.backend || options.source;

  // A list of resulting documents. These are actual documents, complete with
  // data and all the rest. If fetch is false, these documents will not
  // have any data. You should manually call fetch() or subscribe() on them.
  //
  // Calling subscribe() might be a good idea anyway, as you won't be
  // subscribed to the documents by default.
  this.knownDocs = options.knownDocs || [];
  this.results = [];

  // Do we have some initial data?
  this.ready = false;

  this.callback = callback;
};
emitter.mixin(Query);

Query.prototype.action = 'qsub';

// Helper for subscribe & fetch, since they share the same message format.
//
// This function actually issues the query.
Query.prototype._execute = function() {
  if (!this.connection.canSend) return;

  if (this.docMode) {
    var collectionVersions = {};
    // Collect the version of all the documents in the current result set so we
    // don't need to be sent their snapshots again.
    for (var i = 0; i < this.knownDocs.length; i++) {
      var doc = this.knownDocs[i];
      var c = collectionVersions[doc.collection] =
        (collectionVersions[doc.collection] || {});
      c[doc.name] = doc.version;
    }
  }

  var msg = {
    a: 'q' + this.type,
    id: this.id,
    c: this.collection,
    o: {},
    q: this.query,
  };

  if (this.docMode) {
    msg.o.m = this.docMode;
    // This should be omitted if empty, but whatever.
    msg.o.vs = collectionVersions;
  }
  if (this.backend != null) msg.o.b = this.backend;
  if (this.poll !== undefined) msg.o.p = this.poll;

  this.connection.send(msg);
};

// Make a list of documents from the list of server-returned data objects
Query.prototype._dataToDocs = function(data) {
  var results = [];
  var lastType;
  for (var i = 0; i < data.length; i++) {
    var docData = data[i];

    // Types are only put in for the first result in the set and every time the type changes in the list.
    if (docData.type) {
      lastType = docData.type;
    } else {
      docData.type = lastType;
    }

    var doc = this.connection.get(docData.c || this.collection, docData.d, docData);
    if (this.docMode === 'sub') {
      doc._finishQuerySubscribe(docData.v);
    }
    results.push(doc);
  }
  return results;
};

// Destroy the query object. Any subsequent messages for the query will be
// ignored by the connection. You should unsubscribe from the query before
// destroying it.
Query.prototype.destroy = function() {
  if (this.connection.canSend && this.type === 'sub') {
    this.connection.send({a:'qunsub', id:this.id});
  }

  this.connection._destroyQuery(this);
};

Query.prototype._onConnectionStateChanged = function(state, reason) {
  if (this.connection.state === 'connecting') {
    this._execute();
  }
};

// Internal method called from connection to pass server messages to the query.
Query.prototype._onMessage = function(msg) {
  if ((msg.a === 'qfetch') !== (this.type === 'fetch')) {
    if (console) console.warn('Invalid message sent to query', msg, this);
    return;
  }

  if (msg.error) this.emit('error', msg.error);

  switch (msg.a) {
    case 'qfetch':
      var results = msg.data ? this._dataToDocs(msg.data) : undefined;
      if (this.callback) this.callback(msg.error, results, msg.extra);
      // Once a fetch query gets its data, it is destroyed.
      this.connection._destroyQuery(this);
      break;

    case 'q':
      // Query diff data (inserts and removes)
      if (msg.diff) {
        // We need to go through the list twice. First, we'll ingest all the
        // new documents and set them as subscribed.  After that we'll emit
        // events and actually update our list. This avoids race conditions
        // around setting documents to be subscribed & unsubscribing documents
        // in event callbacks.
        for (var i = 0; i < msg.diff.length; i++) {
          var d = msg.diff[i];
          if (d.type === 'insert') d.values = this._dataToDocs(d.values);
        }

        for (var i = 0; i < msg.diff.length; i++) {
          var d = msg.diff[i];
          switch (d.type) {
            case 'insert':
              var newDocs = d.values;
              Array.prototype.splice.apply(this.results, [d.index, 0].concat(newDocs));
              this.emit('insert', newDocs, d.index);
              break;
            case 'remove':
              var howMany = d.howMany || 1;
              var removed = this.results.splice(d.index, howMany);
              this.emit('remove', removed, d.index);
              break;
            case 'move':
              var howMany = d.howMany || 1;
              var docs = this.results.splice(d.from, howMany);
              Array.prototype.splice.apply(this.results, [d.to, 0].concat(docs));
              this.emit('move', docs, d.from, d.to);
              break;
          }
        }
      }

      if (msg.extra !== void 0) {
        this.emit('extra', msg.extra);
      }
      break;
    case 'qsub':
      // This message replaces the entire result set with the set passed.
      if (!msg.error) {
        var previous = this.results;

        // Then add everything in the new result set.
        this.results = this.knownDocs = this._dataToDocs(msg.data);
        this.extra = msg.extra;

        this.ready = true;
        this.emit('change', this.results, previous);
      }
      if (this.callback) {
        this.callback(msg.error, this.results, this.extra);
        delete this.callback;
      }
      break;
  }
};

// Change the thing we're searching for. This isn't fully supported on the
// backend (it destroys the old query and makes a new one) - but its
// programatically useful and I might add backend support at some point.
Query.prototype.setQuery = function(q) {
  if (this.type !== 'sub') throw new Error('cannot change a fetch query');

  this.query = q;
  if (this.connection.canSend) {
    // There's no 'change' message to send to the server. Just resubscribe.
    this.connection.send({a:'qunsub', id:this.id});
    this._execute();
  }
};

},{"./emitter":3}],6:[function(require,module,exports){
/* This contains the textarea binding for ShareJS. This binding is really
 * simple, and a bit slow on big documents (Its O(N). However, it requires no
 * changes to the DOM and no heavy libraries like ace. It works for any kind of
 * text input field.
 *
 * You probably want to use this binding for small fields on forms and such.
 * For code editors or rich text editors or whatever, I recommend something
 * heavier.
 */

 var Doc = require('./doc').Doc;

/* applyChange creates the edits to convert oldval -> newval.
 *
 * This function should be called every time the text element is changed.
 * Because changes are always localised, the diffing is quite easy. We simply
 * scan in from the start and scan in from the end to isolate the edited range,
 * then delete everything that was removed & add everything that was added.
 * This wouldn't work for complex changes, but this function should be called
 * on keystroke - so the edits will mostly just be single character changes.
 * Sometimes they'll paste text over other text, but even then the diff
 * generated by this algorithm is correct.
 *
 * This algorithm is O(N). I suspect you could speed it up somehow using regular expressions.
 */
var applyChange = function(ctx, oldval, newval) {
  // Strings are immutable and have reference equality. I think this test is O(1), so its worth doing.
  if (oldval === newval) return;

  var commonStart = 0;
  while (oldval.charAt(commonStart) === newval.charAt(commonStart)) {
    commonStart++;
  }

  var commonEnd = 0;
  while (oldval.charAt(oldval.length - 1 - commonEnd) === newval.charAt(newval.length - 1 - commonEnd) &&
      commonEnd + commonStart < oldval.length && commonEnd + commonStart < newval.length) {
    commonEnd++;
  }

  if (oldval.length !== commonStart + commonEnd) {
    ctx.remove(commonStart, oldval.length - commonStart - commonEnd);
  }
  if (newval.length !== commonStart + commonEnd) {
    ctx.insert(commonStart, newval.slice(commonStart, newval.length - commonEnd));
  }
};

// Attach a textarea to a document's editing context.
//
// The context is optional, and will be created from the document if its not
// specified.
Doc.prototype.attachTextarea = function(elem, ctx) {
  if (!ctx) ctx = this.createContext();

  if (!ctx.provides.text) throw new Error('Cannot attach to non-text document');

  elem.value = ctx.get();

  // The current value of the element's text is stored so we can quickly check
  // if its been changed in the event handlers. This is mostly for browsers on
  // windows, where the content contains \r\n newlines. applyChange() is only
  // called after the \r\n newlines are converted, and that check is quite
  // slow. So we also cache the string before conversion so we can do a quick
  // check incase the conversion isn't needed.
  var prevvalue;

  // Replace the content of the text area with newText, and transform the
  // current cursor by the specified function.
  var replaceText = function(newText, transformCursor) {
    if (transformCursor) {
      var newSelection = [transformCursor(elem.selectionStart), transformCursor(elem.selectionEnd)];
    }

    // Fixate the window's scroll while we set the element's value. Otherwise
    // the browser scrolls to the element.
    var scrollTop = elem.scrollTop;
    elem.value = newText;
    prevvalue = elem.value; // Not done on one line so the browser can do newline conversion.
    if (elem.scrollTop !== scrollTop) elem.scrollTop = scrollTop;

    // Setting the selection moves the cursor. We'll just have to let your
    // cursor drift if the element isn't active, though usually users don't
    // care.
    if (newSelection && window.document.activeElement === elem) {
      elem.selectionStart = newSelection[0];
      elem.selectionEnd = newSelection[1];
    }
  };

  replaceText(ctx.get());


  // *** remote -> local changes

  ctx.onInsert = function(pos, text) {
    var transformCursor = function(cursor) {
      return pos < cursor ? cursor + text.length : cursor;
    };

    // Remove any window-style newline characters. Windows inserts these, and
    // they mess up the generated diff.
    var prev = elem.value.replace(/\r\n/g, '\n');
    replaceText(prev.slice(0, pos) + text + prev.slice(pos), transformCursor);
  };

  ctx.onRemove = function(pos, length) {
    var transformCursor = function(cursor) {
      // If the cursor is inside the deleted region, we only want to move back to the start
      // of the region. Hence the Math.min.
      return pos < cursor ? cursor - Math.min(length, cursor - pos) : cursor;
    };

    var prev = elem.value.replace(/\r\n/g, '\n');
    replaceText(prev.slice(0, pos) + prev.slice(pos + length), transformCursor);
  };


  // *** local -> remote changes

  // This function generates operations from the changed content in the textarea.
  var genOp = function(event) {
    // In a timeout so the browser has time to propogate the event's changes to the DOM.
    setTimeout(function() {
      if (elem.value !== prevvalue) {
        prevvalue = elem.value;
        applyChange(ctx, ctx.get(), elem.value.replace(/\r\n/g, '\n'));
      }
    }, 0);
  };

  var eventNames = ['textInput', 'keydown', 'keyup', 'select', 'cut', 'paste'];
  for (var i = 0; i < eventNames.length; i++) {
    var e = eventNames[i];
    if (elem.addEventListener) {
      elem.addEventListener(e, genOp, false);
    } else {
      elem.attachEvent('on' + e, genOp);
    }
  }

  ctx.detach = function() {
    for (var i = 0; i < eventNames.length; i++) {
      var e = eventNames[i];
      if (elem.removeEventListener) {
        elem.removeEventListener(e, genOp, false);
      } else {
        elem.detachEvent('on' + e, genOp);
      }
    }
  };

  return ctx;
};

},{"./doc":2}],7:[function(require,module,exports){

exports.ottypes = {};
exports.registerType = function(type) {
  if (type.name) exports.ottypes[type.name] = type;
  if (type.uri) exports.ottypes[type.uri] = type;
};

exports.registerType(require('ot-json0').type);
exports.registerType(require('ot-text').type);
exports.registerType(require('ot-text-tp2').type);

// The types register themselves on their respective types.
require('./text-api');
require('./text-tp2-api');

// The JSON API is buggy!! Please submit a pull request fixing it if you want to use it.
//require('./json-api');

},{"./text-api":8,"./text-tp2-api":9,"ot-json0":12,"ot-text":18,"ot-text-tp2":15}],8:[function(require,module,exports){
// Text document API for the 'text' type.

// The API implements the standard text API methods. In particular:
//
// - getLength() returns the length of the document in characters
// - getText() returns a string of the document
// - insert(pos, text, [callback]) inserts text at position pos in the document
// - remove(pos, length, [callback]) removes length characters at position pos
//
// Events are implemented by just adding the appropriate methods to your
// context object.
// onInsert(pos, text): Called when text is inserted.
// onRemove(pos, length): Called when text is removed.

var type = require('ot-text').type;

type.api = {
  provides: {text: true},

  // Returns the number of characters in the string
  getLength: function() { return this.getSnapshot().length; },


  // Returns the text content of the document
  get: function() { return this.getSnapshot(); },

  getText: function() {
    console.warn("`getText()` is deprecated; use `get()` instead.");
    return this.get();
  },

  // Insert the specified text at the given position in the document
  insert: function(pos, text, callback) {
    return this.submitOp([pos, text], callback);
  },

  remove: function(pos, length, callback) {
    return this.submitOp([pos, {d:length}], callback);
  },

  // When you use this API, you should implement these two methods
  // in your editing context.
  //onInsert: function(pos, text) {},
  //onRemove: function(pos, removedLength) {},

  _onOp: function(op) {
    var pos = 0;
    var spos = 0;
    for (var i = 0; i < op.length; i++) {
      var component = op[i];
      switch (typeof component) {
        case 'number':
          pos += component;
          spos += component;
          break;
        case 'string':
          if (this.onInsert) this.onInsert(pos, component);
          pos += component.length;
          break;
        case 'object':
          if (this.onRemove) this.onRemove(pos, component.d);
          spos += component.d;
      }
    }
  }
};

},{"ot-text":18}],9:[function(require,module,exports){
// Text document API for text-tp2

var type = require('ot-text-tp2').type;
var takeDoc = type._takeDoc;
var append = type._append;

var appendSkipChars = function(op, doc, pos, maxlength) {
  while ((maxlength == null || maxlength > 0) && pos.index < doc.data.length) {
    var part = takeDoc(doc, pos, maxlength, true);
    if (maxlength != null && typeof part === 'string') {
      maxlength -= part.length;
    }
    append(op, part.length || part);
  }
};

type.api = {
  provides: {text: true},

  // Number of characters in the string
  getLength: function() { return this.getSnapshot().charLength; },

  // Flatten the document into a string
  get: function() {
    var snapshot = this.getSnapshot();
    var strings = [];

    for (var i = 0; i < snapshot.data.length; i++) {
      var elem = snapshot.data[i];
      if (typeof elem == 'string') {
        strings.push(elem);
      }
    }

    return strings.join('');
  },

  getText: function() {
    console.warn("`getText()` is deprecated; use `get()` instead.");
    return this.get();
  },

  // Insert text at pos
  insert: function(pos, text, callback) {
    if (pos == null) pos = 0;

    var op = [];
    var docPos = {index: 0, offset: 0};
    var snapshot = this.getSnapshot();

    // Skip to the specified position
    appendSkipChars(op, snapshot, docPos, pos);

    // Append the text
    append(op, {i: text});
    appendSkipChars(op, snapshot, docPos);
    this.submitOp(op, callback);
    return op;
  },

  // Remove length of text at pos
  remove: function(pos, len, callback) {
    var op = [];
    var docPos = {index: 0, offset: 0};
    var snapshot = this.getSnapshot();

    // Skip to the position
    appendSkipChars(op, snapshot, docPos, pos);

    while (len > 0) {
      var part = takeDoc(snapshot, docPos, len, true);

      // We only need to delete actual characters. This should also be valid if
      // we deleted all the tombstones in the document here.
      if (typeof part === 'string') {
        append(op, {d: part.length});
        len -= part.length;
      } else {
        append(op, part);
      }
    }

    appendSkipChars(op, snapshot, docPos);
    this.submitOp(op, callback);
    return op;
  },

  _beforeOp: function() {
    // Its a shame we need this. This also currently relies on snapshots being
    // cloned during apply(). This is used in _onOp below to figure out what
    // text was _actually_ inserted and removed.
    //
    // Maybe instead we should do all the _onOp logic here and store the result
    // then play the events when _onOp is actually called or something.
    this.__prevSnapshot = this.getSnapshot();
  },

  _onOp: function(op) {
    var textPos = 0;
    var docPos = {index:0, offset:0};
    // The snapshot we get here is the document state _AFTER_ the specified op
    // has been applied. That means any deleted characters are now tombstones.
    var prevSnapshot = this.__prevSnapshot;

    for (var i = 0; i < op.length; i++) {
      var component = op[i];
      var part, remainder;

      if (typeof component == 'number') {
        // Skip
        for (remainder = component;
            remainder > 0;
            remainder -= part.length || part) {

          part = takeDoc(prevSnapshot, docPos, remainder);
          if (typeof part === 'string')
            textPos += part.length;
        }
      } else if (component.i != null) {
        // Insert
        if (typeof component.i == 'string') {
          // ... and its an insert of text, not insert of tombstones
          if (this.onInsert) this.onInsert(textPos, component.i);
          textPos += component.i.length;
        }
      } else {
        // Delete
        for (remainder = component.d;
            remainder > 0;
            remainder -= part.length || part) {

          part = takeDoc(prevSnapshot, docPos, remainder);
          if (typeof part == 'string' && this.onRemove)
            this.onRemove(textPos, part.length);
        }
      }
    }
  }
};

},{"ot-text-tp2":15}],10:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],11:[function(require,module,exports){
// These methods let you build a transform function from a transformComponent
// function for OT types like JSON0 in which operations are lists of components
// and transforming them requires N^2 work. I find it kind of nasty that I need
// this, but I'm not really sure what a better solution is. Maybe I should do
// this automatically to types that don't have a compose function defined.

// Add transform and transformX functions for an OT type which has
// transformComponent defined.  transformComponent(destination array,
// component, other component, side)
module.exports = bootstrapTransform
function bootstrapTransform(type, transformComponent, checkValidOp, append) {
  var transformComponentX = function(left, right, destLeft, destRight) {
    transformComponent(destLeft, left, right, 'left');
    transformComponent(destRight, right, left, 'right');
  };

  var transformX = type.transformX = function(leftOp, rightOp) {
    checkValidOp(leftOp);
    checkValidOp(rightOp);
    var newRightOp = [];

    for (var i = 0; i < rightOp.length; i++) {
      var rightComponent = rightOp[i];

      // Generate newLeftOp by composing leftOp by rightComponent
      var newLeftOp = [];
      var k = 0;
      while (k < leftOp.length) {
        var nextC = [];
        transformComponentX(leftOp[k], rightComponent, newLeftOp, nextC);
        k++;

        if (nextC.length === 1) {
          rightComponent = nextC[0];
        } else if (nextC.length === 0) {
          for (var j = k; j < leftOp.length; j++) {
            append(newLeftOp, leftOp[j]);
          }
          rightComponent = null;
          break;
        } else {
          // Recurse.
          var pair = transformX(leftOp.slice(k), nextC);
          for (var l = 0; l < pair[0].length; l++) {
            append(newLeftOp, pair[0][l]);
          }
          for (var r = 0; r < pair[1].length; r++) {
            append(newRightOp, pair[1][r]);
          }
          rightComponent = null;
          break;
        }
      }

      if (rightComponent != null) {
        append(newRightOp, rightComponent);
      }
      leftOp = newLeftOp;
    }
    return [leftOp, newRightOp];
  };

  // Transforms op with specified type ('left' or 'right') by otherOp.
  type.transform = function(op, otherOp, type) {
    if (!(type === 'left' || type === 'right'))
      throw new Error("type must be 'left' or 'right'");

    if (otherOp.length === 0) return op;

    if (op.length === 1 && otherOp.length === 1)
      return transformComponent([], op[0], otherOp[0], type);

    if (type === 'left')
      return transformX(op, otherOp)[0];
    else
      return transformX(otherOp, op)[1];
  };
};

},{}],12:[function(require,module,exports){
// Only the JSON type is exported, because the text type is deprecated
// otherwise. (If you want to use it somewhere, you're welcome to pull it out
// into a separate module that json0 can depend on).

module.exports = {
  type: require('./json0')
};

},{"./json0":13}],13:[function(require,module,exports){
/*
 This is the implementation of the JSON OT type.

 Spec is here: https://github.com/josephg/ShareJS/wiki/JSON-Operations

 Note: This is being made obsolete. It will soon be replaced by the JSON2 type.
*/

/**
 * UTILITY FUNCTIONS
 */

/**
 * Checks if the passed object is an Array instance. Can't use Array.isArray
 * yet because its not supported on IE8.
 *
 * @param obj
 * @returns {boolean}
 */
var isArray = function(obj) {
  return Object.prototype.toString.call(obj) == '[object Array]';
};

/**
 * Checks if the passed object is an Object instance.
 * No function call (fast) version
 *
 * @param obj
 * @returns {boolean}
 */
var isObject = function(obj) {
  return (!!obj) && (obj.constructor === Object);
};

/**
 * Clones the passed object using JSON serialization (which is slow).
 *
 * hax, copied from test/types/json. Apparently this is still the fastest way
 * to deep clone an object, assuming we have browser support for JSON.  @see
 * http://jsperf.com/cloning-an-object/12
 */
var clone = function(o) {
  return JSON.parse(JSON.stringify(o));
};

/**
 * JSON OT Type
 * @type {*}
 */
var json = {
  name: 'json0',
  uri: 'http://sharejs.org/types/JSONv0'
};

// You can register another OT type as a subtype in a JSON document using
// the following function. This allows another type to handle certain
// operations instead of the builtin JSON type.
var subtypes = {};
json.registerSubtype = function(subtype) {
  subtypes[subtype.name] = subtype;
};

json.create = function(data) {
  // Null instead of undefined if you don't pass an argument.
  return data === undefined ? null : clone(data);
};

json.invertComponent = function(c) {
  var c_ = {p: c.p};

  // handle subtype ops
  if (c.t && subtypes[c.t]) {
    c_.t = c.t;
    c_.o = subtypes[c.t].invert(c.o);
  }

  if (c.si !== void 0) c_.sd = c.si;
  if (c.sd !== void 0) c_.si = c.sd;
  if (c.oi !== void 0) c_.od = c.oi;
  if (c.od !== void 0) c_.oi = c.od;
  if (c.li !== void 0) c_.ld = c.li;
  if (c.ld !== void 0) c_.li = c.ld;
  if (c.na !== void 0) c_.na = -c.na;

  if (c.lm !== void 0) {
    c_.lm = c.p[c.p.length-1];
    c_.p = c.p.slice(0,c.p.length-1).concat([c.lm]);
  }

  return c_;
};

json.invert = function(op) {
  var op_ = op.slice().reverse();
  var iop = [];
  for (var i = 0; i < op_.length; i++) {
    iop.push(json.invertComponent(op_[i]));
  }
  return iop;
};

json.checkValidOp = function(op) {
  for (var i = 0; i < op.length; i++) {
    if (!isArray(op[i].p)) throw new Error('Missing path');
  }
};

json.checkList = function(elem) {
  if (!isArray(elem))
    throw new Error('Referenced element not a list');
};

json.checkObj = function(elem) {
  if (!isObject(elem)) {
    throw new Error("Referenced element not an object (it was " + JSON.stringify(elem) + ")");
  }
};

// helper functions to convert old string ops to and from subtype ops
function convertFromText(c) {
  c.t = 'text0';
  var o = {p: c.p.pop()};
  if (c.si != null) o.i = c.si;
  if (c.sd != null) o.d = c.sd;
  c.o = [o];
}

function convertToText(c) {
  c.p.push(c.o[0].p);
  if (c.o[0].i != null) c.si = c.o[0].i;
  if (c.o[0].d != null) c.sd = c.o[0].d;
  delete c.t;
  delete c.o;
}

json.apply = function(snapshot, op) {
  json.checkValidOp(op);

  op = clone(op);

  var container = {
    data: snapshot
  };

  for (var i = 0; i < op.length; i++) {
    var c = op[i];

    // convert old string ops to use subtype for backwards compatibility
    if (c.si != null || c.sd != null)
      convertFromText(c);

    var parent = null;
    var parentKey = null;
    var elem = container;
    var key = 'data';

    for (var j = 0; j < c.p.length; j++) {
      var p = c.p[j];

      parent = elem;
      parentKey = key;
      elem = elem[key];
      key = p;

      if (parent == null)
        throw new Error('Path invalid');
    }

    // handle subtype ops
    if (c.t && c.o !== void 0 && subtypes[c.t]) {
      elem[key] = subtypes[c.t].apply(elem[key], c.o);

    // Number add
    } else if (c.na !== void 0) {
      if (typeof elem[key] != 'number')
        throw new Error('Referenced element not a number');

      elem[key] += c.na;
    }

    // List replace
    else if (c.li !== void 0 && c.ld !== void 0) {
      json.checkList(elem);
      // Should check the list element matches c.ld
      elem[key] = c.li;
    }

    // List insert
    else if (c.li !== void 0) {
      json.checkList(elem);
      elem.splice(key,0, c.li);
    }

    // List delete
    else if (c.ld !== void 0) {
      json.checkList(elem);
      // Should check the list element matches c.ld here too.
      elem.splice(key,1);
    }

    // List move
    else if (c.lm !== void 0) {
      json.checkList(elem);
      if (c.lm != key) {
        var e = elem[key];
        // Remove it...
        elem.splice(key,1);
        // And insert it back.
        elem.splice(c.lm,0,e);
      }
    }

    // Object insert / replace
    else if (c.oi !== void 0) {
      json.checkObj(elem);

      // Should check that elem[key] == c.od
      elem[key] = c.oi;
    }

    // Object delete
    else if (c.od !== void 0) {
      json.checkObj(elem);

      // Should check that elem[key] == c.od
      delete elem[key];
    }

    else {
      throw new Error('invalid / missing instruction in op');
    }
  }

  return container.data;
};

// Helper to break an operation up into a bunch of small ops.
json.shatter = function(op) {
  var results = [];
  for (var i = 0; i < op.length; i++) {
    results.push([op[i]]);
  }
  return results;
};

// Helper for incrementally applying an operation to a snapshot. Calls yield
// after each op component has been applied.
json.incrementalApply = function(snapshot, op, _yield) {
  for (var i = 0; i < op.length; i++) {
    var smallOp = [op[i]];
    snapshot = json.apply(snapshot, smallOp);
    // I'd just call this yield, but thats a reserved keyword. Bah!
    _yield(smallOp, snapshot);
  }

  return snapshot;
};

// Checks if two paths, p1 and p2 match.
var pathMatches = json.pathMatches = function(p1, p2, ignoreLast) {
  if (p1.length != p2.length)
    return false;

  for (var i = 0; i < p1.length; i++) {
    if (p1[i] !== p2[i] && (!ignoreLast || i !== p1.length - 1))
      return false;
  }

  return true;
};

json.append = function(dest,c) {
  c = clone(c);

  if (dest.length === 0) {
    dest.push(c);
    return;
  }

  var last = dest[dest.length - 1];

  // convert old string ops to use subtype for backwards compatibility
  if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {
    convertFromText(c);
    convertFromText(last);
  }

  if (pathMatches(c.p, last.p)) {
    // handle subtype ops
    if (c.t && last.t && c.t === last.t && subtypes[c.t]) {
      last.o = subtypes[c.t].compose(last.o, c.o);

      // convert back to old string ops
      if (c.si != null || c.sd != null) {
        var p = c.p;
        for (var i = 0; i < last.o.length - 1; i++) {
          c.o = [last.o.pop()];
          c.p = p.slice();
          convertToText(c);
          dest.push(c);
        }

        convertToText(last);
      }
    } else if (last.na != null && c.na != null) {
      dest[dest.length - 1] = {p: last.p, na: last.na + c.na};
    } else if (last.li !== undefined && c.li === undefined && c.ld === last.li) {
      // insert immediately followed by delete becomes a noop.
      if (last.ld !== undefined) {
        // leave the delete part of the replace
        delete last.li;
      } else {
        dest.pop();
      }
    } else if (last.od !== undefined && last.oi === undefined && c.oi !== undefined && c.od === undefined) {
      last.oi = c.oi;
    } else if (last.oi !== undefined && c.od !== undefined) {
      // The last path component inserted something that the new component deletes (or replaces).
      // Just merge them.
      if (c.oi !== undefined) {
        last.oi = c.oi;
      } else if (last.od !== undefined) {
        delete last.oi;
      } else {
        // An insert directly followed by a delete turns into a no-op and can be removed.
        dest.pop();
      }
    } else if (c.lm !== undefined && c.p[c.p.length - 1] === c.lm) {
      // don't do anything
    } else {
      dest.push(c);
    }
  } else {
    // convert string ops back
    if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {
      convertToText(c);
      convertToText(last);
    }

    dest.push(c);
  }
};

json.compose = function(op1,op2) {
  json.checkValidOp(op1);
  json.checkValidOp(op2);

  var newOp = clone(op1);

  for (var i = 0; i < op2.length; i++) {
    json.append(newOp,op2[i]);
  }

  return newOp;
};

json.normalize = function(op) {
  var newOp = [];

  op = isArray(op) ? op : [op];

  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    if (c.p == null) c.p = [];

    json.append(newOp,c);
  }

  return newOp;
};

// Returns the common length of the paths of ops a and b
json.commonLengthForOps = function(a, b) {
  var alen = a.p.length;
  var blen = b.p.length;
  if (a.na != null || a.t)
    alen++;

  if (b.na != null || b.t)
    blen++;

  if (alen === 0) return -1;
  if (blen === 0) return null;

  alen--;
  blen--;

  for (var i = 0; i < alen; i++) {
    var p = a.p[i];
    if (i >= blen || p !== b.p[i])
      return null;
  }

  return alen;
};

// Returns true if an op can affect the given path
json.canOpAffectPath = function(op, path) {
  return json.commonLengthForOps({p:path}, op) != null;
};

// transform c so it applies to a document with otherC applied.
json.transformComponent = function(dest, c, otherC, type) {
  c = clone(c);

  var common = json.commonLengthForOps(otherC, c);
  var common2 = json.commonLengthForOps(c, otherC);
  var cplength = c.p.length;
  var otherCplength = otherC.p.length;

  if (c.na != null || c.t)
    cplength++;

  if (otherC.na != null || otherC.t)
    otherCplength++;

  // if c is deleting something, and that thing is changed by otherC, we need to
  // update c to reflect that change for invertibility.
  if (common2 != null && otherCplength > cplength && c.p[common2] == otherC.p[common2]) {
    if (c.ld !== void 0) {
      var oc = clone(otherC);
      oc.p = oc.p.slice(cplength);
      c.ld = json.apply(clone(c.ld),[oc]);
    } else if (c.od !== void 0) {
      var oc = clone(otherC);
      oc.p = oc.p.slice(cplength);
      c.od = json.apply(clone(c.od),[oc]);
    }
  }

  if (common != null) {
    var commonOperand = cplength == otherCplength;

    // backward compatibility for old string ops
    var oc = otherC;
    if ((c.si != null || c.sd != null) && (otherC.si != null || otherC.sd != null)) {
      convertFromText(c);
      oc = clone(otherC);
      convertFromText(oc);
    }

    // handle subtype ops
    if (oc.t && subtypes[oc.t]) {
      if (c.t && c.t === oc.t) {
        var res = subtypes[c.t].transform(c.o, oc.o, type);

        if (res.length > 0) {
          // convert back to old string ops
          if (c.si != null || c.sd != null) {
            var p = c.p;
            for (var i = 0; i < res.length; i++) {
              c.o = [res[i]];
              c.p = p.slice();
              convertToText(c);
              json.append(dest, c);
            }
          } else {
            c.o = res;
            json.append(dest, c);
          }
        }

        return dest;
      }
    }

    // transform based on otherC
    else if (otherC.na !== void 0) {
      // this case is handled below
    } else if (otherC.li !== void 0 && otherC.ld !== void 0) {
      if (otherC.p[common] === c.p[common]) {
        // noop

        if (!commonOperand) {
          return dest;
        } else if (c.ld !== void 0) {
          // we're trying to delete the same element, -> noop
          if (c.li !== void 0 && type === 'left') {
            // we're both replacing one element with another. only one can survive
            c.ld = clone(otherC.li);
          } else {
            return dest;
          }
        }
      }
    } else if (otherC.li !== void 0) {
      if (c.li !== void 0 && c.ld === undefined && commonOperand && c.p[common] === otherC.p[common]) {
        // in li vs. li, left wins.
        if (type === 'right')
          c.p[common]++;
      } else if (otherC.p[common] <= c.p[common]) {
        c.p[common]++;
      }

      if (c.lm !== void 0) {
        if (commonOperand) {
          // otherC edits the same list we edit
          if (otherC.p[common] <= c.lm)
            c.lm++;
          // changing c.from is handled above.
        }
      }
    } else if (otherC.ld !== void 0) {
      if (c.lm !== void 0) {
        if (commonOperand) {
          if (otherC.p[common] === c.p[common]) {
            // they deleted the thing we're trying to move
            return dest;
          }
          // otherC edits the same list we edit
          var p = otherC.p[common];
          var from = c.p[common];
          var to = c.lm;
          if (p < to || (p === to && from < to))
            c.lm--;

        }
      }

      if (otherC.p[common] < c.p[common]) {
        c.p[common]--;
      } else if (otherC.p[common] === c.p[common]) {
        if (otherCplength < cplength) {
          // we're below the deleted element, so -> noop
          return dest;
        } else if (c.ld !== void 0) {
          if (c.li !== void 0) {
            // we're replacing, they're deleting. we become an insert.
            delete c.ld;
          } else {
            // we're trying to delete the same element, -> noop
            return dest;
          }
        }
      }

    } else if (otherC.lm !== void 0) {
      if (c.lm !== void 0 && cplength === otherCplength) {
        // lm vs lm, here we go!
        var from = c.p[common];
        var to = c.lm;
        var otherFrom = otherC.p[common];
        var otherTo = otherC.lm;
        if (otherFrom !== otherTo) {
          // if otherFrom == otherTo, we don't need to change our op.

          // where did my thing go?
          if (from === otherFrom) {
            // they moved it! tie break.
            if (type === 'left') {
              c.p[common] = otherTo;
              if (from === to) // ugh
                c.lm = otherTo;
            } else {
              return dest;
            }
          } else {
            // they moved around it
            if (from > otherFrom) c.p[common]--;
            if (from > otherTo) c.p[common]++;
            else if (from === otherTo) {
              if (otherFrom > otherTo) {
                c.p[common]++;
                if (from === to) // ugh, again
                  c.lm++;
              }
            }

            // step 2: where am i going to put it?
            if (to > otherFrom) {
              c.lm--;
            } else if (to === otherFrom) {
              if (to > from)
                c.lm--;
            }
            if (to > otherTo) {
              c.lm++;
            } else if (to === otherTo) {
              // if we're both moving in the same direction, tie break
              if ((otherTo > otherFrom && to > from) ||
                  (otherTo < otherFrom && to < from)) {
                if (type === 'right') c.lm++;
              } else {
                if (to > from) c.lm++;
                else if (to === otherFrom) c.lm--;
              }
            }
          }
        }
      } else if (c.li !== void 0 && c.ld === undefined && commonOperand) {
        // li
        var from = otherC.p[common];
        var to = otherC.lm;
        p = c.p[common];
        if (p > from) c.p[common]--;
        if (p > to) c.p[common]++;
      } else {
        // ld, ld+li, si, sd, na, oi, od, oi+od, any li on an element beneath
        // the lm
        //
        // i.e. things care about where their item is after the move.
        var from = otherC.p[common];
        var to = otherC.lm;
        p = c.p[common];
        if (p === from) {
          c.p[common] = to;
        } else {
          if (p > from) c.p[common]--;
          if (p > to) c.p[common]++;
          else if (p === to && from > to) c.p[common]++;
        }
      }
    }
    else if (otherC.oi !== void 0 && otherC.od !== void 0) {
      if (c.p[common] === otherC.p[common]) {
        if (c.oi !== void 0 && commonOperand) {
          // we inserted where someone else replaced
          if (type === 'right') {
            // left wins
            return dest;
          } else {
            // we win, make our op replace what they inserted
            c.od = otherC.oi;
          }
        } else {
          // -> noop if the other component is deleting the same object (or any parent)
          return dest;
        }
      }
    } else if (otherC.oi !== void 0) {
      if (c.oi !== void 0 && c.p[common] === otherC.p[common]) {
        // left wins if we try to insert at the same place
        if (type === 'left') {
          json.append(dest,{p: c.p, od:otherC.oi});
        } else {
          return dest;
        }
      }
    } else if (otherC.od !== void 0) {
      if (c.p[common] == otherC.p[common]) {
        if (!commonOperand)
          return dest;
        if (c.oi !== void 0) {
          delete c.od;
        } else {
          return dest;
        }
      }
    }
  }

  json.append(dest,c);
  return dest;
};

require('./bootstrapTransform')(json, json.transformComponent, json.checkValidOp, json.append);

/**
 * Register a subtype for string operations, using the text0 type.
 */
var text = require('./text0');

json.registerSubtype(text);
module.exports = json;


},{"./bootstrapTransform":11,"./text0":14}],14:[function(require,module,exports){
// DEPRECATED!
//
// This type works, but is not exported. Its included here because the JSON0
// embedded string operations use this library.


// A simple text implementation
//
// Operations are lists of components. Each component either inserts or deletes
// at a specified position in the document.
//
// Components are either:
//  {i:'str', p:100}: Insert 'str' at position 100 in the document
//  {d:'str', p:100}: Delete 'str' at position 100 in the document
//
// Components in an operation are executed sequentially, so the position of components
// assumes previous components have already executed.
//
// Eg: This op:
//   [{i:'abc', p:0}]
// is equivalent to this op:
//   [{i:'a', p:0}, {i:'b', p:1}, {i:'c', p:2}]

var text = module.exports = {
  name: 'text0',
  uri: 'http://sharejs.org/types/textv0',
  create: function(initial) {
    if ((initial != null) && typeof initial !== 'string') {
      throw new Error('Initial data must be a string');
    }
    return initial || '';
  }
};

/** Insert s2 into s1 at pos. */
var strInject = function(s1, pos, s2) {
  return s1.slice(0, pos) + s2 + s1.slice(pos);
};

/** Check that an operation component is valid. Throws if its invalid. */
var checkValidComponent = function(c) {
  if (typeof c.p !== 'number')
    throw new Error('component missing position field');

  if ((typeof c.i === 'string') === (typeof c.d === 'string'))
    throw new Error('component needs an i or d field');

  if (c.p < 0)
    throw new Error('position cannot be negative');
};

/** Check that an operation is valid */
var checkValidOp = function(op) {
  for (var i = 0; i < op.length; i++) {
    checkValidComponent(op[i]);
  }
};

/** Apply op to snapshot */
text.apply = function(snapshot, op) {
  var deleted;

  checkValidOp(op);
  for (var i = 0; i < op.length; i++) {
    var component = op[i];
    if (component.i != null) {
      snapshot = strInject(snapshot, component.p, component.i);
    } else {
      deleted = snapshot.slice(component.p, component.p + component.d.length);
      if (component.d !== deleted)
        throw new Error("Delete component '" + component.d + "' does not match deleted text '" + deleted + "'");

      snapshot = snapshot.slice(0, component.p) + snapshot.slice(component.p + component.d.length);
    }
  }
  return snapshot;
};

/**
 * Append a component to the end of newOp. Exported for use by the random op
 * generator and the JSON0 type.
 */
var append = text._append = function(newOp, c) {
  if (c.i === '' || c.d === '') return;

  if (newOp.length === 0) {
    newOp.push(c);
  } else {
    var last = newOp[newOp.length - 1];

    if (last.i != null && c.i != null && last.p <= c.p && c.p <= last.p + last.i.length) {
      // Compose the insert into the previous insert
      newOp[newOp.length - 1] = {i:strInject(last.i, c.p - last.p, c.i), p:last.p};

    } else if (last.d != null && c.d != null && c.p <= last.p && last.p <= c.p + c.d.length) {
      // Compose the deletes together
      newOp[newOp.length - 1] = {d:strInject(c.d, last.p - c.p, last.d), p:c.p};

    } else {
      newOp.push(c);
    }
  }
};

/** Compose op1 and op2 together */
text.compose = function(op1, op2) {
  checkValidOp(op1);
  checkValidOp(op2);
  var newOp = op1.slice();
  for (var i = 0; i < op2.length; i++) {
    append(newOp, op2[i]);
  }
  return newOp;
};

/** Clean up an op */
text.normalize = function(op) {
  var newOp = [];

  // Normalize should allow ops which are a single (unwrapped) component:
  // {i:'asdf', p:23}.
  // There's no good way to test if something is an array:
  // http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
  // so this is probably the least bad solution.
  if (op.i != null || op.p != null) op = [op];

  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    if (c.p == null) c.p = 0;

    append(newOp, c);
  }

  return newOp;
};

// This helper method transforms a position by an op component.
//
// If c is an insert, insertAfter specifies whether the transform
// is pushed after the insert (true) or before it (false).
//
// insertAfter is optional for deletes.
var transformPosition = function(pos, c, insertAfter) {
  // This will get collapsed into a giant ternary by uglify.
  if (c.i != null) {
    if (c.p < pos || (c.p === pos && insertAfter)) {
      return pos + c.i.length;
    } else {
      return pos;
    }
  } else {
    // I think this could also be written as: Math.min(c.p, Math.min(c.p -
    // otherC.p, otherC.d.length)) but I think its harder to read that way, and
    // it compiles using ternary operators anyway so its no slower written like
    // this.
    if (pos <= c.p) {
      return pos;
    } else if (pos <= c.p + c.d.length) {
      return c.p;
    } else {
      return pos - c.d.length;
    }
  }
};

// Helper method to transform a cursor position as a result of an op.
//
// Like transformPosition above, if c is an insert, insertAfter specifies
// whether the cursor position is pushed after an insert (true) or before it
// (false).
text.transformCursor = function(position, op, side) {
  var insertAfter = side === 'right';
  for (var i = 0; i < op.length; i++) {
    position = transformPosition(position, op[i], insertAfter);
  }

  return position;
};

// Transform an op component by another op component. Asymmetric.
// The result will be appended to destination.
//
// exported for use in JSON type
var transformComponent = text._tc = function(dest, c, otherC, side) {
  //var cIntersect, intersectEnd, intersectStart, newC, otherIntersect, s;

  checkValidComponent(c);
  checkValidComponent(otherC);

  if (c.i != null) {
    // Insert.
    append(dest, {i:c.i, p:transformPosition(c.p, otherC, side === 'right')});
  } else {
    // Delete
    if (otherC.i != null) {
      // Delete vs insert
      var s = c.d;
      if (c.p < otherC.p) {
        append(dest, {d:s.slice(0, otherC.p - c.p), p:c.p});
        s = s.slice(otherC.p - c.p);
      }
      if (s !== '')
        append(dest, {d: s, p: c.p + otherC.i.length});

    } else {
      // Delete vs delete
      if (c.p >= otherC.p + otherC.d.length)
        append(dest, {d: c.d, p: c.p - otherC.d.length});
      else if (c.p + c.d.length <= otherC.p)
        append(dest, c);
      else {
        // They overlap somewhere.
        var newC = {d: '', p: c.p};

        if (c.p < otherC.p)
          newC.d = c.d.slice(0, otherC.p - c.p);

        if (c.p + c.d.length > otherC.p + otherC.d.length)
          newC.d += c.d.slice(otherC.p + otherC.d.length - c.p);

        // This is entirely optional - I'm just checking the deleted text in
        // the two ops matches
        var intersectStart = Math.max(c.p, otherC.p);
        var intersectEnd = Math.min(c.p + c.d.length, otherC.p + otherC.d.length);
        var cIntersect = c.d.slice(intersectStart - c.p, intersectEnd - c.p);
        var otherIntersect = otherC.d.slice(intersectStart - otherC.p, intersectEnd - otherC.p);
        if (cIntersect !== otherIntersect)
          throw new Error('Delete ops delete different text in the same region of the document');

        if (newC.d !== '') {
          newC.p = transformPosition(newC.p, otherC);
          append(dest, newC);
        }
      }
    }
  }

  return dest;
};

var invertComponent = function(c) {
  return (c.i != null) ? {d:c.i, p:c.p} : {i:c.d, p:c.p};
};

// No need to use append for invert, because the components won't be able to
// cancel one another.
text.invert = function(op) {
  // Shallow copy & reverse that sucka.
  op = op.slice().reverse();
  for (var i = 0; i < op.length; i++) {
    op[i] = invertComponent(op[i]);
  }
  return op;
};

require('./bootstrapTransform')(text, transformComponent, checkValidOp, append);

},{"./bootstrapTransform":11}],15:[function(require,module,exports){
module.exports = {
  type: require('./text-tp2')
};

},{"./text-tp2":16}],16:[function(require,module,exports){
// A TP2 implementation of text, following this spec:
// http://code.google.com/p/lightwave/source/browse/trunk/experimental/ot/README
//
// A document is made up of a string and a set of tombstones inserted throughout
// the string. For example, 'some ', (2 tombstones), 'string'.
//
// This is encoded in a document as ['some ', (2 tombstones), 'string']
// (It should be encoded as {s:'some string', t:[5, -2, 6]} because thats
// faster in JS, but its not.)
//
// Ops are lists of components which iterate over the whole document. (I might
// change this at some point, but a version thats less strict is backwards
// compatible.)
//
// Components are either:
//   N:         Skip N characters in the original document
//   {i:'str'}: Insert 'str' at the current position in the document
//   {i:N}:     Insert N tombstones at the current position in the document
//   {d:N}:     Delete (tombstone) N characters at the current position in the document
//
// Eg: [3, {i:'hi'}, 5, {d:8}]
//
// Snapshots are lists with characters and tombstones. Characters are stored in strings
// and adjacent tombstones are flattened into numbers.
//
// Eg, the document: 'Hello .....world' ('.' denotes tombstoned (deleted) characters)
// would be represented by a document snapshot of ['Hello ', 5, 'world']

var type = module.exports = {
  name: 'text-tp2',
  tp2: true,
  uri: 'http://sharejs.org/types/text-tp2v1',
  create: function(initial) {
    if (initial == null) {
      initial = '';
    } else {
      if (typeof initial != 'string') throw new Error('Initial data must be a string');
    }

    return {
      charLength: initial.length,
      totalLength: initial.length,
      data: initial.length ? [initial] : []
    };
  },

  serialize: function(doc) {
    if (!doc.data) {
      throw new Error('invalid doc snapshot');
    }
    return doc.data;
  },

  deserialize: function(data) {
    var doc = type.create();
    doc.data = data;

    for (var i = 0; i < data.length; i++) {
      var component = data[i];

      if (typeof component === 'string') {
        doc.charLength += component.length;
        doc.totalLength += component.length;
      } else {
        doc.totalLength += component;
      }
    }

    return doc;
  }
};

var isArray = Array.isArray || function(obj) {
  return Object.prototype.toString.call(obj) == '[object Array]';
};

var checkOp = function(op) {
  if (!isArray(op)) throw new Error('Op must be an array of components');

  var last = null;
  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    if (typeof c == 'object') {
      // The component is an insert or a delete.
      if (c.i !== undefined) { // Insert.
        if (!((typeof c.i === 'string' && c.i.length > 0) // String inserts
              || (typeof c.i === 'number' && c.i > 0))) // Tombstone inserts
          throw new Error('Inserts must insert a string or a +ive number');

      } else if (c.d !== undefined) { // Delete
        if (!(typeof c.d === 'number' && c.d > 0))
          throw new Error('Deletes must be a +ive number');

      } else throw new Error('Operation component must define .i or .d');

    } else {
      // The component must be a skip.
      if (typeof c != 'number') throw new Error('Op components must be objects or numbers');

      if (c <= 0) throw new Error('Skip components must be a positive number');
      if (typeof last === 'number') throw new Error('Adjacent skip components should be combined');
    }

    last = c;
  }
};

// Take the next part from the specified position in a document snapshot.
// position = {index, offset}. It will be updated.
var takeDoc = type._takeDoc = function(doc, position, maxlength, tombsIndivisible) {
  if (position.index >= doc.data.length)
    throw new Error('Operation goes past the end of the document');

  var part = doc.data[position.index];

  // This can be written as an ugly-arsed giant ternary statement, but its much
  // more readable like this. Uglify will convert it into said ternary anyway.
  var result;
  if (typeof part == 'string') {
    if (maxlength != null) {
      result = part.slice(position.offset, position.offset + maxlength);
    } else {
      result = part.slice(position.offset);
    }
  } else {
    if (maxlength == null || tombsIndivisible) {
      result = part - position.offset;
    } else {
      result = Math.min(maxlength, part - position.offset);
    }
  }

  var resultLen = result.length || result;

  if ((part.length || part) - position.offset > resultLen) {
    position.offset += resultLen;
  } else {
    position.index++;
    position.offset = 0;
  }

  return result;
};

// Append a part to the end of a document
var appendDoc = type._appendDoc = function(doc, p) {
  if (p === 0 || p === '') return;

  if (typeof p === 'string') {
    doc.charLength += p.length;
    doc.totalLength += p.length;
  } else {
    doc.totalLength += p;
  }

  var data = doc.data;
  if (data.length === 0) {
    data.push(p);
  } else if (typeof data[data.length - 1] === typeof p) {
    data[data.length - 1] += p;
  } else {
    data.push(p);
  }
};

// Apply the op to the document. The document is not modified in the process.
type.apply = function(doc, op) {
  if (doc.totalLength == null || doc.charLength == null || !isArray(doc.data)) {
    throw new Error('Snapshot is invalid');
  }
  checkOp(op);

  var newDoc = type.create();
  var position = {index: 0, offset: 0};

  for (var i = 0; i < op.length; i++) {
    var component = op[i];
    var remainder, part;

    if (typeof component == 'number') { // Skip
      remainder = component;
      while (remainder > 0) {
        part = takeDoc(doc, position, remainder);
        appendDoc(newDoc, part);
        remainder -= part.length || part;
      }

    } else if (component.i !== undefined) { // Insert
      appendDoc(newDoc, component.i);

    } else if (component.d !== undefined) { // Delete
      remainder = component.d;
      while (remainder > 0) {
        part = takeDoc(doc, position, remainder);
        remainder -= part.length || part;
      }
      appendDoc(newDoc, component.d);
    }
  }
  return newDoc;
};

// Append an op component to the end of the specified op.  Exported for the
// randomOpGenerator.
var append = type._append = function(op, component) {
  var last;

  if (component === 0 || component.i === '' || component.i === 0 || component.d === 0) {
    // Drop the new component.
  } else if (op.length === 0) {
    op.push(component);
  } else {
    last = op[op.length - 1];
    if (typeof component == 'number' && typeof last == 'number') {
      op[op.length - 1] += component;
    } else if (component.i != null && (last.i != null) && typeof last.i === typeof component.i) {
      last.i += component.i;
    } else if (component.d != null && (last.d != null)) {
      last.d += component.d;
    } else {
      op.push(component);
    }
  }
};

var take = function(op, cursor, maxlength, insertsIndivisible) {
  if (cursor.index === op.length) return null;
  var e = op[cursor.index];
  var current;
  var result;

  var offset = cursor.offset;

  // if the current element is a skip, an insert of a number or a delete
  if (typeof (current = e) == 'number' || typeof (current = e.i) == 'number' || (current = e.d) != null) {
    var c;
    if ((maxlength == null) || current - offset <= maxlength || (insertsIndivisible && e.i != null)) {
      // Return the rest of the current element.
      c = current - offset;
      ++cursor.index;
      cursor.offset = 0;
    } else {
      cursor.offset += maxlength;
      c = maxlength;
    }

    // Package the component back up.
    if (e.i != null) {
      return {i: c};
    } else if (e.d != null) {
      return {d: c};
    } else {
      return c;
    }
  } else { // Insert of a string.
    if ((maxlength == null) || e.i.length - offset <= maxlength || insertsIndivisible) {
      result = {i: e.i.slice(offset)};
      ++cursor.index;
      cursor.offset = 0;
    } else {
      result = {i: e.i.slice(offset, offset + maxlength)};
      cursor.offset += maxlength;
    }
    return result;
  }
};

// Find and return the length of an op component
var componentLength = function(component) {
  if (typeof component === 'number') {
    return component;
  } else if (typeof component.i === 'string') {
    return component.i.length;
  } else {
    return component.d || component.i;
  }
};

// Normalize an op, removing all empty skips and empty inserts / deletes.
// Concatenate adjacent inserts and deletes.
type.normalize = function(op) {
  var newOp = [];
  for (var i = 0; i < op.length; i++) {
    append(newOp, op[i]);
  }
  return newOp;
};

// This is a helper method to transform and prune. goForwards is true for transform, false for prune.
var transformer = function(op, otherOp, goForwards, side) {
  checkOp(op);
  checkOp(otherOp);

  var newOp = [];

  // Cursor moving over op. Used by take
  var cursor = {index:0, offset:0};

  for (var i = 0; i < otherOp.length; i++) {
    var component = otherOp[i];
    var len = componentLength(component);
    var chunk;

    if (component.i != null) { // Insert text or tombs
      if (goForwards) { // Transform - insert skips over deleted parts.
        if (side === 'left') {
          // The left side insert should go first.
          var next;
          while ((next = op[cursor.index]) && next.i != null) {
            append(newOp, take(op, cursor));
          }
        }
        // In any case, skip the inserted text.
        append(newOp, len);

      } else { // Prune. Remove skips for inserts.
        while (len > 0) {
          chunk = take(op, cursor, len, true);

          // The chunk will be null if we run out of components in the other op.
          if (chunk === null) throw new Error('The transformed op is invalid');
          if (chunk.d != null)
            throw new Error('The transformed op deletes locally inserted characters - it cannot be purged of the insert.');

          if (typeof chunk == 'number')
            len -= chunk;
          else
            append(newOp, chunk);
        }
      }
    } else { // Skips or deletes.
      while (len > 0) {
        chunk = take(op, cursor, len, true);
        if (chunk === null) throw new Error('The op traverses more elements than the document has');

        append(newOp, chunk);
        if (!chunk.i) len -= componentLength(chunk);
      }
    }
  }

  // Append extras from op1.
  var component;
  while ((component = take(op, cursor))) {
    if (component.i === undefined) {
      throw new Error("Remaining fragments in the op: " + component);
    }
    append(newOp, component);
  }
  return newOp;
};

// transform op1 by op2. Return transformed version of op1. op1 and op2 are
// unchanged by transform. Side should be 'left' or 'right', depending on if
// op1.id <> op2.id.
//
// 'left' == client op for ShareJS.
type.transform = function(op, otherOp, side) {
  if (side != 'left' && side != 'right')
    throw new Error("side (" + side + ") should be 'left' or 'right'");

  return transformer(op, otherOp, true, side);
};

type.prune = function(op, otherOp) {
  return transformer(op, otherOp, false);
};

type.compose = function(op1, op2) {
  //var chunk, chunkLength, component, length, result, take, _, _i, _len, _ref;
  if (op1 == null) return op2;

  checkOp(op1);
  checkOp(op2);

  var result = [];

  // Cursor over op1.
  var cursor = {index:0, offset:0};

  var component;

  for (var i = 0; i < op2.length; i++) {
    component = op2[i];
    var len, chunk;

    if (typeof component === 'number') { // Skip
      // Just copy from op1.
      len = component;
      while (len > 0) {
        chunk = take(op1, cursor, len);
        if (chunk === null)
          throw new Error('The op traverses more elements than the document has');

        append(result, chunk);
        len -= componentLength(chunk);
      }

    } else if (component.i !== undefined) { // Insert
      append(result, {i: component.i});

    } else { // Delete
      len = component.d;
      while (len > 0) {
        chunk = take(op1, cursor, len);
        if (chunk === null)
          throw new Error('The op traverses more elements than the document has');

        var chunkLength = componentLength(chunk);

        if (chunk.i !== undefined)
          append(result, {i: chunkLength});
        else
          append(result, {d: chunkLength});

        len -= chunkLength;
      }
    }
  }

  // Append extras from op1.
  while ((component = take(op1, cursor))) {
    if (component.i === undefined) {
      throw new Error("Remaining fragments in op1: " + component);
    }
    append(result, component);
  }
  return result;
};


},{}],17:[function(require,module,exports){
// Text document API for the 'text' type. This implements some standard API
// methods for any text-like type, so you can easily bind a textarea or
// something without being fussy about the underlying OT implementation.
//
// The API is desigend as a set of functions to be mixed in to some context
// object as part of its lifecycle. It expects that object to have getSnapshot
// and submitOp methods, and call _onOp when an operation is received.
//
// This API defines:
//
// - getLength() returns the length of the document in characters
// - getText() returns a string of the document
// - insert(pos, text, [callback]) inserts text at position pos in the document
// - remove(pos, length, [callback]) removes length characters at position pos
//
// A user can define:
// - onInsert(pos, text): Called when text is inserted.
// - onRemove(pos, length): Called when text is removed.

module.exports = api;
function api(getSnapshot, submitOp) {
  return {
    // Returns the text content of the document
    get: function() { return getSnapshot(); },

    // Returns the number of characters in the string
    getLength: function() { return getSnapshot().length; },

    // Insert the specified text at the given position in the document
    insert: function(pos, text, callback) {
      return submitOp([pos, text], callback);
    },

    remove: function(pos, length, callback) {
      return submitOp([pos, {d:length}], callback);
    },

    // When you use this API, you should implement these two methods
    // in your editing context.
    //onInsert: function(pos, text) {},
    //onRemove: function(pos, removedLength) {},

    _onOp: function(op) {
      var pos = 0;
      var spos = 0;
      for (var i = 0; i < op.length; i++) {
        var component = op[i];
        switch (typeof component) {
          case 'number':
            pos += component;
            spos += component;
            break;
          case 'string':
            if (this.onInsert) this.onInsert(pos, component);
            pos += component.length;
            break;
          case 'object':
            if (this.onRemove) this.onRemove(pos, component.d);
            spos += component.d;
        }
      }
    }
  };
};
api.provides = {text: true};

},{}],18:[function(require,module,exports){
var type = require('./text');
type.api = require('./api');

module.exports = {
  type: type
};

},{"./api":17,"./text":19}],19:[function(require,module,exports){
/* Text OT!
 *
 * This is an OT implementation for text. It is the standard implementation of
 * text used by ShareJS.
 *
 * This type is composable but non-invertable. Its similar to ShareJS's old
 * text-composable type, but its not invertable and its very similar to the
 * text-tp2 implementation but it doesn't support tombstones or purging.
 *
 * Ops are lists of components which iterate over the document.
 * Components are either:
 *   A number N: Skip N characters in the original document
 *   "str"     : Insert "str" at the current position in the document
 *   {d:N}     : Delete N characters at the current position in the document
 *
 * Eg: [3, 'hi', 5, {d:8}]
 *
 * The operation does not have to skip the last characters in the document.
 *
 * Snapshots are strings.
 *
 * Cursors are either a single number (which is the cursor position) or a pair of
 * [anchor, focus] (aka [start, end]). Be aware that end can be before start.
 */

/** @module text */

exports.name = 'text';
exports.uri = 'http://sharejs.org/types/textv1';

/** Create a new text snapshot.
 *
 * @param {string} initial - initial snapshot data. Optional. Defaults to ''.
 */
exports.create = function(initial) {
  if ((initial != null) && typeof initial !== 'string') {
    throw Error('Initial data must be a string');
  }
  return initial || '';
};

var isArray = Array.isArray || function(obj) {
  return Object.prototype.toString.call(obj) === "[object Array]";
};

/** Check the operation is valid. Throws if not valid. */
var checkOp = function(op) {
  if (!isArray(op)) throw Error('Op must be an array of components');

  var last = null;
  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    switch (typeof c) {
      case 'object':
        // The only valid objects are {d:X} for +ive values of X.
        if (!(typeof c.d === 'number' && c.d > 0)) throw Error('Object components must be deletes of size > 0');
        break;
      case 'string':
        // Strings are inserts.
        if (!(c.length > 0)) throw Error('Inserts cannot be empty');
        break;
      case 'number':
        // Numbers must be skips. They have to be +ive numbers.
        if (!(c > 0)) throw Error('Skip components must be >0');
        if (typeof last === 'number') throw Error('Adjacent skip components should be combined');
        break;
    }
    last = c;
  }

  if (typeof last === 'number') throw Error('Op has a trailing skip');
};

/** Check that the given selection range is valid. */
var checkSelection = function(selection) {
  // This may throw from simply inspecting selection[0] / selection[1]. Thats
  // sort of ok, though it'll generate the wrong message.
  if (typeof selection !== 'number'
      && (typeof selection[0] !== 'number' || typeof selection[1] !== 'number'))
    throw Error('Invalid selection');
};

/** Make a function that appends to the given operation. */
var makeAppend = function(op) {
  return function(component) {
    if (!component || component.d === 0) {
      // The component is a no-op. Ignore!

    } else if (op.length === 0) {
      return op.push(component);

    } else if (typeof component === typeof op[op.length - 1]) {
      if (typeof component === 'object') {
        return op[op.length - 1].d += component.d;
      } else {
        return op[op.length - 1] += component;
      }
    } else {
      return op.push(component);
    }
  };
};

/** Makes and returns utility functions take and peek. */
var makeTake = function(op) {
  // The index of the next component to take
  var idx = 0;
  // The offset into the component
  var offset = 0;

  // Take up to length n from the front of op. If n is -1, take the entire next
  // op component. If indivisableField == 'd', delete components won't be separated.
  // If indivisableField == 'i', insert components won't be separated.
  var take = function(n, indivisableField) {
    // We're at the end of the operation. The op has skips, forever. Infinity
    // might make more sense than null here.
    if (idx === op.length)
      return n === -1 ? null : n;

    var part;
    var c = op[idx];
    if (typeof c === 'number') {
      // Skip
      if (n === -1 || c - offset <= n) {
        part = c - offset;
        ++idx;
        offset = 0;
        return part;
      } else {
        offset += n;
        return n;
      }
    } else if (typeof c === 'string') {
      // Insert
      if (n === -1 || indivisableField === 'i' || c.length - offset <= n) {
        part = c.slice(offset);
        ++idx;
        offset = 0;
        return part;
      } else {
        part = c.slice(offset, offset + n);
        offset += n;
        return part;
      }
    } else {
      // Delete
      if (n === -1 || indivisableField === 'd' || c.d - offset <= n) {
        part = {d: c.d - offset};
        ++idx;
        offset = 0;
        return part;
      } else {
        offset += n;
        return {d: n};
      }
    }
  };

  // Peek at the next op that will be returned.
  var peekType = function() { return op[idx]; };

  return [take, peekType];
};

/** Get the length of a component */
var componentLength = function(c) {
  // Uglify will compress this down into a ternary
  if (typeof c === 'number') {
    return c;
  } else {
    return c.length || c.d;
  }
};

/** Trim any excess skips from the end of an operation.
 *
 * There should only be at most one, because the operation was made with append.
 */
var trim = function(op) {
  if (op.length > 0 && typeof op[op.length - 1] === 'number') {
    op.pop();
  }
  return op;
};

exports.normalize = function(op) {
  var newOp = [];
  var append = makeAppend(newOp);
  for (var i = 0; i < op.length; i++) {
    append(op[i]);
  }
  return trim(newOp);
};

/** Apply an operation to a document snapshot */
exports.apply = function(str, op) {
  if (typeof str !== 'string') {
    throw Error('Snapshot should be a string');
  }
  checkOp(op);

  // We'll gather the new document here and join at the end.
  var newDoc = [];

  for (var i = 0; i < op.length; i++) {
    var component = op[i];
    switch (typeof component) {
      case 'number':
        if (component > str.length) throw Error('The op is too long for this document');

        newDoc.push(str.slice(0, component));
        // This might be slow for big strings. Consider storing the offset in
        // str instead of rewriting it each time.
        str = str.slice(component);
        break;
      case 'string':
        newDoc.push(component);
        break;
      case 'object':
        str = str.slice(component.d);
        break;
    }
  }

  return newDoc.join('') + str;
};

/** Transform op by otherOp.
 *
 * @param op - The operation to transform
 * @param otherOp - Operation to transform it by
 * @param side - Either 'left' or 'right'
 */
exports.transform = function(op, otherOp, side) {
  if (side != 'left' && side != 'right') throw Error("side (" + side + ") must be 'left' or 'right'");

  checkOp(op);
  checkOp(otherOp);

  var newOp = [];
  var append = makeAppend(newOp);

  var _fns = makeTake(op);
  var take = _fns[0],
      peek = _fns[1];

  for (var i = 0; i < otherOp.length; i++) {
    var component = otherOp[i];

    var length, chunk;
    switch (typeof component) {
      case 'number': // Skip
        length = component;
        while (length > 0) {
          chunk = take(length, 'i');
          append(chunk);
          if (typeof chunk !== 'string') {
            length -= componentLength(chunk);
          }
        }
        break;

      case 'string': // Insert
        if (side === 'left') {
          // The left insert should go first.
          if (typeof peek() === 'string') {
            append(take(-1));
          }
        }

        // Otherwise skip the inserted text.
        append(component.length);
        break;

      case 'object': // Delete
        length = component.d;
        while (length > 0) {
          chunk = take(length, 'i');
          switch (typeof chunk) {
            case 'number':
              length -= chunk;
              break;
            case 'string':
              append(chunk);
              break;
            case 'object':
              // The delete is unnecessary now - the text has already been deleted.
              length -= chunk.d;
          }
        }
        break;
    }
  }

  // Append any extra data in op1.
  while ((component = take(-1)))
    append(component);

  return trim(newOp);
};

/** Compose op1 and op2 together and return the result */
exports.compose = function(op1, op2) {
  checkOp(op1);
  checkOp(op2);

  var result = [];
  var append = makeAppend(result);
  var take = makeTake(op1)[0];

  for (var i = 0; i < op2.length; i++) {
    var component = op2[i];
    var length, chunk;
    switch (typeof component) {
      case 'number': // Skip
        length = component;
        while (length > 0) {
          chunk = take(length, 'd');
          append(chunk);
          if (typeof chunk !== 'object') {
            length -= componentLength(chunk);
          }
        }
        break;

      case 'string': // Insert
        append(component);
        break;

      case 'object': // Delete
        length = component.d;

        while (length > 0) {
          chunk = take(length, 'd');

          switch (typeof chunk) {
            case 'number':
              append({d: chunk});
              length -= chunk;
              break;
            case 'string':
              length -= chunk.length;
              break;
            case 'object':
              append(chunk);
          }
        }
        break;
    }
  }

  while ((component = take(-1)))
    append(component);

  return trim(result);
};

// Calculate the cursor position after the given operation
function applyToCursor(op) {
  var pos = 0;
  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    switch (typeof c) {
    case 'number':
      pos += c;
      break;
    case 'string':
      pos += c.length;
      break;
    case 'object':
      //pos -= c.d;
      break;
    }
  }
  return pos;
};


// Generate an operation that semantically inverts the given operation
// when applied to the provided snapshot.
// It needs a snapshot of the document before the operation
// was applied to invert delete operations.
exports.semanticInvert = function (str, op) {
    if (typeof str !== 'string') {
        throw Error('Snapshot should be a string');
    }
    checkOp(op);

    // Save copy
    var originalOp = op.slice();

    // Shallow copy
    op = op.slice();

    var len = op.length;
    var cursor, prevOps, tmpStr;
    for (var i = 0; i < len; i++) {
        var c = op[i];
        switch (typeof c) {
        case 'number':
            // In case we have cursor movement we do nothing
            break;
        case 'string':
            // In case we have string insertion we generate a string deletion
            op[i] = {d: c.length};
            break;
        case 'object':
          // In case of a deletion we need to reinsert the deleted string
            prevOps = originalOp.slice(0, i);
            cursor = applyToCursor(prevOps);
            tmpStr = exports.apply(str, trim(prevOps));
            op[i] = tmpStr.substring(cursor, cursor + c.d);
            break;
        }
    }

    return exports.normalize(op);
};




var transformPosition = function(cursor, op) {
  var pos = 0;
  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    if (cursor <= pos) break;

    // I could actually use the op_iter stuff above - but I think its simpler
    // like this.
    switch (typeof c) {
      case 'number':
        if (cursor <= pos + c)
          return cursor;
        pos += c;
        break;

      case 'string':
        pos += c.length;
        cursor += c.length;
        break;

      case 'object':
        cursor -= Math.min(c.d, cursor - pos);
        break;
    }
  }
  return cursor;
};

exports.transformSelection = function(selection, op, isOwnOp) {
  var pos = 0;
  if (isOwnOp) {
    // Just track the position. We'll teleport the cursor to the end anyway.
    // This works because text ops don't have any trailing skips at the end - so the last
    // component is the last thing.
    for (var i = 0; i < op.length; i++) {
      var c = op[i];
      switch (typeof c) {
        case 'number':
          pos += c;
          break;
        case 'string':
          pos += c.length;
          break;
        // Just eat deletes.
      }
    }
    return pos;
  } else {
    return typeof selection === 'number' ?
      transformPosition(selection, op) : [transformPosition(selection[0], op), transformPosition(selection[1], op)];
  }
};

exports.selectionEq = function(c1, c2) {
  if (c1[0] != null && c1[0] === c1[1]) c1 = c1[0];
  if (c2[0] != null && c2[0] === c2[1]) c2 = c2[0];
  return c1 === c2 || (c1[0] != null && c2[0] != null && c1[0] === c2[0] && c1[1] == c2[1]);
};


},{}]},{},[4])(4)
});

/* editor/realtime.js */
editor.once('load', function() {
    'use strict';

    editor.once('start', function() {
        var auth = false;
        var socket = new SockJS(config.url.realtime.http);
        var connection = new sharejs.Connection(socket);
        var scene = null;
        var data;
        var reconnectAttempts = 0;
        var reconnectInterval = 1;

        editor.method('realtime:connection', function () {
            return connection;
        });

        var connect = function () {
            if (reconnectAttempts > 8) {
                editor.emit('realtime:cannotConnect');
                return;
            }

            reconnectAttempts++;
            editor.emit('realtime:connecting', reconnectAttempts);

            var sharejsMessage = connection.socket.onmessage;

            connection.socket.onmessage = function(msg) {
                try {
                    if (msg.data.startsWith('auth')) {
                        if (!auth) {
                            auth = true;
                            data = JSON.parse(msg.data.slice(4));

                            editor.emit('realtime:authenticated');

                            // load scene
                            if (! scene && config.scene.id)
                                editor.call('realtime:loadScene', config.scene.id);
                        }
                    } else if (msg.data.startsWith('whoisonline:')) {
                        data = msg.data.slice('whoisonline:'.length);
                        var ind = data.indexOf(':');
                        if (ind !== -1) {
                            var op = data.slice(0, ind);
                            if (op === 'set') {
                                data = JSON.parse(data.slice(ind + 1));
                            } else if (op === 'add' || op === 'remove') {
                                data = parseInt(data.slice(ind + 1), 10);
                            }
                            editor.call('whoisonline:' + op, data);
                        } else {
                            sharejsMessage(msg);
                        }
                    } else if (msg.data.startsWith('fs:')) {
                        data = msg.data.slice('fs:'.length);
                        var ind = data.indexOf(':');
                        if (ind !== -1) {
                            var op = data.slice(0, ind);
                            if (op === 'paths') {
                                data = JSON.parse(data.slice(ind + 1));
                                editor.call('assets:fs:paths:patch', data);
                            }
                        } else {
                            sharejsMessage(msg);
                        }
                    } else {
                        sharejsMessage(msg);
                    }
                } catch (e) {
                    console.error(e);
                }

            };

            connection.on('connected', function() {
                reconnectAttempts = 0;
                reconnectInterval = 1;

                this.socket.send('auth' + JSON.stringify({
                    accessToken: config.accessToken
                }));

                editor.emit('realtime:connected');
            });

            connection.on('error', function(msg) {
                if (connection.state === 'connected') {
                    console.log(msg);
                    return;
                }

                editor.emit('realtime:error', msg);
            });

            var onConnectionClosed = connection.socket.onclose;
            connection.socket.onclose = function (reason) {
                auth = false;

                if (scene) {
                    scene.destroy();
                    scene = null;
                }

                editor.emit('realtime:disconnected', reason);
                onConnectionClosed(reason);

                // try to reconnect after a while
                editor.emit('realtime:nextAttempt', reconnectInterval);

                setTimeout(reconnect, reconnectInterval * 1000);

                reconnectInterval++;
            };
        };

        var reconnect = function () {
            // create new socket...
            socket = new SockJS(config.url.realtime.http);
            // ... and new sharejs connection
            connection = new sharejs.Connection(socket);
            // connect again
            connect();
        };

        connect();

        var emitOp = function(type, op) {
            // console.log('in: [ ' + Object.keys(op).filter(function(i) { return i !== 'p' }).join(', ') + ' ]', op.p.join('.'));
            // console.log(op);

            if (op.p[0])
                editor.emit('realtime:' + type + ':op:' + op.p[0], op);
        };

        editor.method('realtime:loadScene', function (id) {
            scene = connection.get('scenes', '' + id);

            // error
            scene.on('error', function(err) {
                editor.emit('realtime:scene:error', err);
            });

            // ready to sync
            scene.on('ready', function() {
                // notify of operations
                scene.on('after op', function(ops, local) {
                    if (local) return;

                    for (var i = 0; i < ops.length; i++)
                        emitOp('scene', ops[i]);
                });

                // notify of scene load
                editor.emit('scene:load', id);
                editor.emit('scene:raw', scene.getSnapshot());
            });

            // subscribe for realtime events
            scene.subscribe();
        });

        // write scene operations
        editor.method('realtime:scene:op', function(op) {
            if (! editor.call('permissions:write') || ! scene)
                return;

            // console.trace();
            // console.log('out: [ ' + Object.keys(op).filter(function(i) { return i !== 'p' }).join(', ') + ' ]', op.p.join('.'));
            // console.log(op)

            try {
                scene.submitOp([ op ]);
            } catch (e) {
                console.error(e);
                editor.emit('realtime:scene:error', e);
            }
        });

        editor.method('realtime:send', function(name, data) {
            socket.send(name + JSON.stringify(data));
        });

        editor.on('realtime:disconnected', function () {
            editor.emit('permissions:writeState', false);
        });

        editor.on('realtime:connected', function () {
            editor.emit('permissions:writeState', editor.call('permissions:write'));
        });

        editor.on('scene:unload', function (id) {
            if (scene) {
                scene.destroy();
                scene = null;

                connection.socket.send('close:scene:' + id);
            }
        });
    });
});


/* editor/selector/selector.js */
editor.once('load', function() {
    'use strict';

    var enabled = true;
    var selector = new ObserverList();
    selector.type = null;



    var index = { };

    var keyByType = function(type) {
        switch(type) {
            case 'entity':
                return 'resource_id';
            case 'asset':
                return 'id';
        }
        return null;
    }

    var setIndex = function(type, item) {
        var key = keyByType(type);
        if (! key) return;

        if (! index[type])
            index[type] = { };

        index[type][item.get[key]] = item.once('destroy', function() {
            var state = editor.call('selector:history');
            if (state)
                editor.call('selector:history', false);

            selector.remove(item);
            delete index[type][item.get[key]];

            if (state)
                editor.call('selector:history', true);
        });
    };

    var removeIndex = function(type, item) {
        if (! index[type]) return;

        var key = keyByType(type);
        if (! key) return;

        var ind = index[type][item.get[key]];
        if (! ind) return;

        ind.unbind();
    };

    var evtChange = false;
    var evtChangeFn = function() {
        evtChange = false;
        editor.emit('selector:change', selector.type, selector.array());
    };

    // adding
    selector.on('add', function(item) {
        // add index
        setIndex(this.type, item);

        editor.emit('selector:add', item, this.type);

        if (! evtChange) {
            evtChange = true;
            setTimeout(evtChangeFn, 0);
        }
    });


    // removing
    selector.on('remove', function(item) {
        editor.emit('selector:remove', item, this.type);

        // remove index
        removeIndex(this.type, item);

        if (this.length === 0)
            this.type = null;

        if (! evtChange) {
            evtChange = true;
            setTimeout(evtChangeFn, 0);
        }
    });


    // selecting item (toggle)
    editor.method('selector:toggle', function(type, item) {
        if (! enabled)
            return;

        if (selector.length && selector.type !== type) {
            selector.clear();
        }
        selector.type = type;

        if (selector.has(item)) {
            selector.remove(item);
        } else {
            selector.add(item);
        }
    });


    // selecting list of items
    editor.method('selector:set', function(type, items) {
        if (! enabled)
            return;

        selector.clear();

        if (! type || ! items.length)
            return;

        // make sure items still exist
        if (type === 'asset') {
            items = items.filter(function(item) {
                return item.get('type') === 'script' || !! editor.call('assets:get', item.get('id'));
            });
        } else if (type === 'entity') {
            items = items.filter(function(item) {
                return !! editor.call('entities:get', item.get('resource_id'));
            });
        }

        if (! items.length)
            return;

        // type
        selector.type = type;

        // remove
        selector.find(function(item) {
            return items.indexOf(item) === -1;
        }).forEach(function(item) {
            selector.remove(item);
        });

        // add
        for(var i = 0; i < items.length; i++)
            selector.add(items[i]);
    });


    // selecting item
    editor.method('selector:add', function(type, item) {
        if (! enabled)
            return;

        if (selector.has(item))
            return;

        if (selector.length && selector.type !== type)
            selector.clear();

        selector.type = type;
        selector.add(item);
    });


    // deselecting item
    editor.method('selector:remove', function(item) {
        if (! enabled)
            return;

        if (! selector.has(item))
            return;

        selector.remove(item);
    });


    // deselecting
    editor.method('selector:clear', function(item) {
        if (! enabled)
            return;

        selector.clear();
    });


    // return select type
    editor.method('selector:type', function() {
        return selector.type;
    });


    // return selected count
    editor.method('selector:count', function() {
        return selector.length;
    });


    // return selected items
    editor.method('selector:items', function() {
        return selector.array();
    });


    // return if it has item
    editor.method('selector:has', function(item) {
        return selector.has(item);
    });


    editor.method('selector:enabled', function(state) {
        enabled = state;
    });
});


/* editor/selector/selector-history.js */
editor.once('load', function() {
    'use strict';

    var selectorHistory = true;
    var changing = false;

    var newType = editor.call('selector:type');
    var newItems = editor.call('selector:items');

    var onSelectorChange = function() {
        changing = false;

        var oldType = newType;
        var oldItems = newItems;

        var type = editor.call('selector:type');
        var items = editor.call('selector:items');

        newType = type;
        newItems = items;

        editor.call('history:add', {
            name: (items.length === 0) ? 'deselect' : ('select ' + type),
            undo: function() {
                var prev = selectorHistory;
                selectorHistory = false;
                editor.call('selector:set', oldType, oldItems);
                editor.once('selector:change', function() {
                    selectorHistory = prev;
                });
            },
            redo: function() {
                var prev = selectorHistory;
                selectorHistory = false;
                editor.call('selector:set', type, items);
                editor.once('selector:change', function() {
                    selectorHistory = prev;
                });
            }
        });
    };

    editor.on('selector:change', function(type, items) {
        if (! selectorHistory) {
            newType = type;
            newItems = items;
            return;
        }

        if (changing)
            return;

        changing = true;
        setTimeout(onSelectorChange, 0);
    });

    editor.method('selector:history', function (toggle) {
        if (toggle === undefined)
            return selectorHistory;

        selectorHistory = toggle;
    });

});


/* editor/designer-settings/designer-settings.js */
editor.once('load', function() {
    'use strict';

    var designerSettings = new Observer({
        'camera_near_clip': 0.1,
        'camera_far_clip': 1000,
        'camera_clear_color': [
            0.722,
            0.722,
            0.722,
            1
        ],
        'grid_divisions': 8,
        'grid_division_size': 1,
        'snap_increment': 1,
        'icons_size': .2,
        'local_server': 'http://localhost:51000',
        'help': true
    });
    designerSettings.sync = false;

    // get designer settings
    editor.method('designerSettings', function() {
        return designerSettings;
    });

    var syncTimeout;

    // sync
    designerSettings.on('*:set', function(field, value) {
        if (! this.sync)
            return;

        if (syncTimeout)
            clearTimeout(syncTimeout);

        syncTimeout = setTimeout(function () {
            Ajax({
                url: '{{url.api}}/scenes/{{scene.id}}/designer_settings/{{self.id}}',
                method: 'PUT',
                query: {
                    access_token: '{{accessToken}}'
                },
                data: this.json()
            });
            syncTimeout = null;
        }.bind(this), 100);
    });

    // load designer settings
    var loadSettings = function () {
        Ajax
        .get('{{url.api}}/scenes/{{scene.id}}/designer_settings/{{self.id}}?access_token={{accessToken}}')
        .on('load', function(status, data) {
            designerSettings.history = false;

            for(var i = 0; i < designerSettings._keys.length; i++) {
                var key = designerSettings._keys[i];
                var value = data.response[0][key];

                if (value !== undefined)
                    designerSettings.set(key, value);
            }

            designerSettings.history = true;
            designerSettings.sync = true;

            editor.emit('designerSettings:load');
        });
    };

    // if we already have a scene id then load settings otherwise
    // wait for a scene id to be loaded and then load settings
    if (config.scene.id) {
        loadSettings();
        // wait for first scene:raw to pass then register on scene:raw to reload settings
        editor.once('scene:raw', function () {
            editor.on('scene:raw', loadSettings);
        });
    } else  {
        editor.on('scene:raw', loadSettings);
    }
});


/* editor/designer-settings/designer-settings-attributes.js */
editor.once('load', function() {
    'use strict';

    var designerSettings = editor.call('designerSettings');

    var sceneName = 'Untitled';
    editor.on('scene:raw', function(data) {
        editor.emit('scene:name', data.name);
    });
    editor.on('realtime:scene:op:name', function(op) {
        editor.emit('scene:name', op.oi);
    });
    editor.on('scene:name', function(name) {
        sceneName = name;
    });

    // inspecting
    editor.on('attributes:inspect[designerSettings]', function() {

        var panelScene = editor.call('attributes:addPanel');
        panelScene.class.add('component');

        // scene name
        var fieldName = editor.call('attributes:addField', {
            parent: panelScene,
            name: 'Scene Name',
            type: 'string',
            value: sceneName
        });
        var changingName = false;
        fieldName.on('change', function(value) {
            if (changingName)
                return;

            editor.call('realtime:scene:op', {
                p: [ 'name' ],
                od: sceneName || '',
                oi: value || ''
            });
            editor.emit('scene:name', value);
        });
        var evtNameChange = editor.on('realtime:scene:op:name', function(op) {
            changingName = true;
            fieldName.value = op.oi;
            changingName = false;
        });
        fieldName.on('destroy', function() {
            evtNameChange.unbind();
        });
        // reference
        editor.call('attributes:reference:settings:name:attach', fieldName.parent.innerElement.firstChild.ui);

        var panel = editor.call('attributes:addPanel', {
            name: 'Editor Settings'
        });
        panel.class.add('component');
        // reference
        editor.call('attributes:reference:settings:designer:attach', panel, panel.headerElement);

        // grid divisions
        var fieldGrid = editor.call('attributes:addField', {
            parent: panel,
            name: 'Grid',
            placeholder: 'Divisions',
            type: 'number',
            precision: 1,
            step: 1,
            min: 0,
            link: designerSettings,
            path: 'grid_divisions'
        });
        fieldGrid.style.width = '32px';
        // reference
        editor.call('attributes:reference:settings:grid:attach', fieldGrid.parent.innerElement.firstChild.ui);


        // grid divisions size
        var fieldFarClip = new ui.NumberField({
            precision: 1,
            step: 1,
            min: 0,
        });
        fieldFarClip.placeholder = 'Size';
        fieldFarClip.style.width = '32px';
        fieldFarClip.flexGrow = 1;
        fieldFarClip.link(designerSettings, 'grid_division_size');
        fieldGrid.parent.append(fieldFarClip);


        // snap increment
        var fieldSnap = editor.call('attributes:addField', {
            parent: panel,
            name: 'Snap',
            type: 'number',
            precision: 2,
            step: 1,
            min: 0,
            placeholder: 'Increment',
            link: designerSettings,
            path: 'snap_increment'
        });
        // reference
        editor.call('attributes:reference:settings:snap:attach', fieldSnap.parent.innerElement.firstChild.ui);


        // camera near clip
        var fieldClip = editor.call('attributes:addField', {
            parent: panel,
            name: 'Camera Clip',
            placeholder: 'Near',
            type: 'number',
            precision: 2,
            step: .1,
            min: 0,
            link: designerSettings,
            path: 'camera_near_clip'
        });
        fieldClip.style.width = '32px';
        // reference
        editor.call('attributes:reference:settings:cameraClip:attach', fieldClip.parent.innerElement.firstChild.ui);


        // camera far clip
        var fieldFarClip = new ui.NumberField({
            precision: 2,
            step: 1,
            min: 0
        });
        fieldFarClip.placeholder = 'Far';
        fieldFarClip.style.width = '32px';
        fieldFarClip.flexGrow = 1;
        fieldFarClip.link(designerSettings, 'camera_far_clip');
        fieldClip.parent.append(fieldFarClip);


        // clear color
        var fieldClearColor = editor.call('attributes:addField', {
            parent: panel,
            name: 'Clear Color',
            type: 'rgb',
            link: designerSettings,
            path: 'camera_clear_color'
        });
        // reference
        editor.call('attributes:reference:settings:clearColor:attach', fieldClearColor.parent.innerElement.firstChild.ui);


        // icons size
        var fieldIconsSize = editor.call('attributes:addField', {
            parent: panel,
            name: 'Icons Size',
            type: 'number',
            precision: 2,
            step: .1,
            min: 0,
            link: designerSettings,
            path: 'icons_size'
        });
        // reference
        editor.call('attributes:reference:settings:iconsSize:attach', fieldIconsSize.parent.innerElement.firstChild.ui);


        // local server
        var fieldLocalServer = editor.call('attributes:addField', {
            parent: panel,
            name: 'Local Server',
            type: 'string',
            link: designerSettings,
            path: 'local_server'
        });

        var changingLocalServer = false;
        var oldLocalServer = fieldLocalServer.value;
        fieldLocalServer.on('change', function (value) {
            if (changingLocalServer) return;

            changingLocalServer = true;
            if (! /^http(s)?:\/\/\S+/.test(value)) {
                fieldLocalServer.value = oldLocalServer;
            } else {
                oldLocalServer = value;
            }

            changingLocalServer = false;
        });

        // reference
        editor.call('attributes:reference:settings:localServer:attach', fieldLocalServer.parent.innerElement.firstChild.ui);

    });
});


/* editor/designer-settings/designer-settings-history.js */
editor.once('load', function() {
    'use strict';

    var obj = editor.call('designerSettings');
    obj.history = true;

    obj.on('*:set', function(path, value, oldValue) {
        if (! this.history)
            return;

        editor.call('history:add', {
            name: 'change designerSettings ' + path,
            undo: function() {
                obj.history = false;
                obj.set(path, oldValue);
                obj.history = true;
            },
            redo: function() {
                obj.history = false;
                obj.set(path, value);
                obj.history = true;
            }
        });
    });
});


/* editor/scene-settings/scene-settings.js */
editor.once('load', function() {
    'use strict';

    var sceneSettings = new Observer();

    // get scene settings
    editor.method('sceneSettings', function() {
        return sceneSettings;
    });


    // loaded scene
    editor.on('scene:raw', function(data) {
        var sync = sceneSettings.sync ? sceneSettings.sync.enabled : false;
        if (sync)
            sceneSettings.sync.enabled = false;

        var history = sceneSettings.history ? sceneSettings.history.enabled : false;
        if (history)
            sceneSettings.history.enabled = false;

        sceneSettings.patch(data.settings);

        if (history)
            sceneSettings.history.enabled = true;

        if (sync)
            sceneSettings.sync.enabled = sync;

        editor.emit('sceneSettings:load', sceneSettings);
    });

    editor.on('scene:unload', function () {
        if (sceneSettings.history)
            sceneSettings.history.enabled = false;
        if (sceneSettings.sync)
            sceneSettings.sync.enabled = false;

        sceneSettings.set('render.skybox', null);

        if (sceneSettings.history)
            sceneSettings.history.enabled = true;
        if (sceneSettings.sync)
            sceneSettings.sync.enabled = true;
    });
});


/* editor/scene-settings/scene-settings-history.js */
editor.once('load', function() {
    'use strict';

    editor.on('sceneSettings:load', function(settings) {
        if (settings.history)
            settings.history.destroy();

        settings.history = new ObserverHistory({
            item: settings,
            prefix: 'settings.',
            getItemFn: function () {
                return editor.call('sceneSettings');
            }
        });

        // record history
        settings.history.on('record', function(action, data) {
            editor.call('history:' + action, data);
        });
    });
});


/* editor/scene-settings/scene-settings-sync.js */
editor.once('load', function() {
    'use strict';

    editor.on('sceneSettings:load', function(settings) {
        settings.sync = new ObserverSync({
            item: settings,
            prefix: [ 'settings' ]
        });

        var events = [];

        // client > server
        events.push(settings.sync.on('op', function(op) {
            editor.call('realtime:scene:op', op);
        }));

        // server > client
        events.push(editor.on('realtime:scene:op:settings', function(op) {
            settings.sync.write(op);
        }));

        editor.on('scene:unload', function () {
            for (var i = 0; i < events.length; i++)
                events[i].unbind();
        });
    });
});


/* editor/scene-settings/scene-settings-attributes.js */
editor.once('load', function() {
    'use strict';

    var sceneSettings = editor.call('sceneSettings');

    editor.on('attributes:inspect[designerSettings]', function() {
        editor.call('attributes:header', 'Settings');

        var app = editor.call('viewport:framework');
        var root = editor.call('layout.root');

        var filteredFields = [ ];

        var addFiltered = function (field, filter) {
            filteredFields.push({
                element: field.length ? field[0].parent : field.parent,
                filter: filter
            });
            return field;
        };

        var filter = function () {
            filteredFields.forEach(function (f) {
                f.element.hidden = !f.filter();
            });
        };

        var fogFilter = function () {
            return sceneSettings.get('render') && sceneSettings.get('render.fog') !== 'none';
        };


        // physics settings
        var physicsPanel = editor.call('attributes:addPanel', {
            name: 'Physics Settings'
        });
        physicsPanel.class.add('component');

        // gravity
        var fieldGravity = editor.call('attributes:addField', {
            parent: physicsPanel,
            name: 'Gravity',
            placeholder: [ 'X', 'Y', 'Z' ],
            precision: 2,
            step: .1,
            type: 'vec3',
            link: sceneSettings,
            path: 'physics.gravity'
        });
        // reference
        editor.call('attributes:reference:settings:gravity:attach', fieldGravity[0].parent.innerElement.firstChild.ui);


        // environment
        var panelEnvironment = editor.call('attributes:addPanel', {
            name: 'Environment'
        });
        panelEnvironment.class.add('component');


        // ambient
        var fieldGlobalAmbient = editor.call('attributes:addField', {
            parent: panelEnvironment,
            name: 'Ambient Color',
            type: 'rgb',
            link: sceneSettings,
            path: 'render.global_ambient'
        });
        // reference
        editor.call('attributes:reference:settings:ambientColor:attach', fieldGlobalAmbient.parent.innerElement.firstChild.ui);


        // skyboxHover
        var skyboxOld = null;
        var hoverSkybox = null;
        var setSkybox = function() {
            if (! hoverSkybox)
                return;

            app.scene.setSkybox(hoverSkybox.resources);
            editor.call('viewport:render');
        }
        // skybox
        var fieldSkybox = editor.call('attributes:addField', {
            parent: panelEnvironment,
            name: 'Skybox',
            type: 'asset',
            kind: 'cubemap',
            link: sceneSettings,
            path: 'render.skybox',
            over: function(type, data) {
                skyboxOld = app.assets.get(sceneSettings.get('render.skybox')) || null;

                hoverSkybox = app.assets.get(parseInt(data.id, 10));
                if (hoverSkybox) {
                    if (sceneSettings.get('render.skyboxMip') === 0)
                        hoverSkybox.loadFaces = true;

                    app.assets.load(hoverSkybox);
                    hoverSkybox.on('load', setSkybox);
                    setSkybox();
                }
            },
            leave: function() {
                if (skyboxOld) {
                    app.scene.setSkybox(skyboxOld.resources)
                    skyboxOld = null;
                    editor.call('viewport:render');
                }
                if (hoverSkybox) {
                    hoverSkybox.off('load', setSkybox);
                    hoverSkybox = null;
                }
            }
        });
        // reference
        editor.call('attributes:reference:settings:skybox:attach', fieldSkybox._label);


        // skyboxIntensity
        var fieldSkyboxIntensity = editor.call('attributes:addField', {
            parent: panelEnvironment,
            name: 'Intensity',
            type: 'number',
            precision: 3,
            step: .05,
            min: 0,
            max: 32,
            link: sceneSettings,
            path: 'render.skyboxIntensity'
        });
        fieldSkyboxIntensity.style.width = '32px';
        // reference
        editor.call('attributes:reference:settings:skyboxIntensity:attach', fieldSkyboxIntensity.parent.innerElement.firstChild.ui);

        // skyboxIntensity slider
        var fieldExposureSlider = new ui.Slider({
            min: 0,
            max: 32,
            precision: 3
        });
        fieldExposureSlider.flexGrow = 4;
        fieldExposureSlider.link(sceneSettings, 'render.skyboxIntensity');
        fieldSkyboxIntensity.parent.append(fieldExposureSlider);


        // skyboxMip
        var fieldSkyboxIntensity = editor.call('attributes:addField', {
            parent: panelEnvironment,
            name: 'Mip',
            type: 'number',
            enum: {
                0: '1',
                1: '2',
                2: '3',
                3: '4',
                4: '5'
            },
            link: sceneSettings,
            path: 'render.skyboxMip'
        });
        // reference
        editor.call('attributes:reference:settings:skyboxMip:attach', fieldSkyboxIntensity.parent.innerElement.firstChild.ui);


        // camera
        var panelCamera = editor.call('attributes:addPanel', {
            name: 'Camera'
        });
        panelCamera.class.add('component');


        // tonemapping
        var fieldTonemapping = editor.call('attributes:addField', {
            parent: panelCamera,
            name: 'Tonemapping',
            type: 'number',
            enum: {
                0: 'Linear',
                1: 'Filmic'
            },
            link: sceneSettings,
            path: 'render.tonemapping'
        });
        // reference
        editor.call('attributes:reference:settings:toneMapping:attach', fieldTonemapping.parent.innerElement.firstChild.ui);


        // exposure
        var fieldExposure = editor.call('attributes:addField', {
            parent: panelCamera,
            name: 'Exposure',
            type: 'number',
            precision: 2,
            step: .1,
            min: 0,
            max: 32,
            link: sceneSettings,
            path: 'render.exposure'
        });
        fieldExposure.style.width = '32px';
        // reference
        editor.call('attributes:reference:settings:exposure:attach', fieldExposure.parent.innerElement.firstChild.ui);


        // exposure slider
        var fieldExposureSlider = new ui.Slider({
            min: 0,
            max: 32,
            precision: 2
        });
        fieldExposureSlider.flexGrow = 4;
        fieldExposureSlider.link(sceneSettings, 'render.exposure');
        fieldExposure.parent.append(fieldExposureSlider);


        // gamma correction
        var fieldGammaCorrection = editor.call('attributes:addField', {
            parent: panelCamera,
            name: 'Gamma',
            type: 'number',
            enum: {
                0: '1.0',
                1: '2.2',
                2: '2.2 Fast'
            },
            link: sceneSettings,
            path: 'render.gamma_correction'
        });
        // reference
        editor.call('attributes:reference:settings:gammaCorrection:attach', fieldGammaCorrection.parent.innerElement.firstChild.ui);


        // fog
        var panelFog = editor.call('attributes:addPanel', {
            name: 'Fog'
        });
        panelFog.class.add('component');


        // fog type
        var fieldFogType = editor.call('attributes:addField', {
            parent: panelFog,
            name: 'Type',
            type: 'string',
            enum: {
                'none': 'None',
                'linear': 'Linear',
                'exp': 'Exponential',
                'exp2': 'Exponential Squared'
            },
            link: sceneSettings,
            path: 'render.fog'
        });
        // reference
        editor.call('attributes:reference:settings:fog:attach', fieldFogType.parent.innerElement.firstChild.ui);


        // fog density
        var fieldFogDensity = addFiltered(editor.call('attributes:addField', {
            parent: panelFog,
            name: 'Density',
            type: 'number',
            precision: 3,
            step: .01,
            min: 0,
            link: sceneSettings,
            path: 'render.fog_density',
        }), fogFilter);
        // reference
        editor.call('attributes:reference:settings:fogDensity:attach', fieldFogDensity.parent.innerElement.firstChild.ui);


        // fog distance near
        var fieldFogDistance = editor.call('attributes:addField', {
            parent: panelFog,
            name: 'Distance',
            placeholder: 'Start',
            type: 'number',
            precision: 2,
            step: 1,
            min: 0,
            link: sceneSettings,
            path: 'render.fog_start',
        });
        fieldFogDistance.style.width = '32px';
        addFiltered(fieldFogDistance, fogFilter);
        // reference
        editor.call('attributes:reference:settings:fogDistance:attach', fieldFogDistance.parent.innerElement.firstChild.ui);


        // fog dinstance far
        var fieldFogEnd = new ui.NumberField({
            precision: 2,
            step: 1,
            min: 0
        });
        fieldFogEnd.placeholder = 'End';
        fieldFogEnd.style.width = '32px';
        fieldFogEnd.flexGrow = 1;
        fieldFogEnd.link(sceneSettings, 'render.fog_end');
        fieldFogDistance.parent.append(fieldFogEnd);

        // fog color
        var fieldFogColor = addFiltered(editor.call('attributes:addField', {
            parent: panelFog,
            name: 'Color',
            type: 'rgb',
            link: sceneSettings,
            path: 'render.fog_color'
        }), fogFilter);
        // reference
        editor.call('attributes:reference:settings:fogColor:attach', fieldFogColor.parent.innerElement.firstChild.ui);


        filter();

        // filter fields when scene settings change
        var evtFilter = sceneSettings.on('*:set', filter);

        // clean up filter event when one of the panels is destroyed
        physicsPanel.on('destroy', function () {
            evtFilter.unbind();
        });


        // loading screen
        var panelLoadingScreen = editor.call('attributes:addPanel', {
            name: 'Loading Screen'
        });
        panelLoadingScreen.class.add('component', 'loading-screen');

        // custom loading screen script
        if (config.owner.superUser || config.owner.plan.type === 'org') {
            var panelButtons = new ui.Panel();
            panelButtons.class.add('flex', 'component');
            panelLoadingScreen.append(panelButtons);

            var btnDefaultScript = new ui.Button({
                text: 'Create default'
            });
            btnDefaultScript.class.add('add');
            btnDefaultScript.class.add('loading-screen');

            var repositories = editor.call('repositories');
            // disable create button for non directory repos
            btnDefaultScript.disabled = repositories.get('current') !== 'directory';

            panelButtons.append(btnDefaultScript);

            var tooltipText = 'Create a default loading screen script.';
            if (btnDefaultScript.disabled) {
                tooltipText += '<br/><small><em>(Disabled because you are synced to an external code repository)</em></small>';
            }
            Tooltip.attach({
                target: btnDefaultScript.element,
                html:  tooltipText,
                align: 'right',
                root: root
            });

            btnDefaultScript.on('click', function () {
                editor.call('selector:enabled', false);
                editor.call('sourcefiles:new', editor.call('sourcefiles:loadingScreen:skeleton'));
                var evtNew = editor.once('sourcefiles:add', function (file) {
                    setLoadingScreen(file.get('filename'));
                    evtNew = null;
                });

                editor.once('sourcefiles:new:close', function () {
                    editor.call('selector:enabled', true);
                    if (evtNew) {
                        evtNew.unbind();
                        evtNew = null;
                    }
                });
            });

            var btnSelectScript = new ui.Button({
                text: 'Select existing'
            });
            btnSelectScript.class.add('loading-screen');
            panelButtons.append(btnSelectScript);

            btnSelectScript.on('click', function () {
                var evtPick = editor.once("picker:asset", function (asset) {
                    setLoadingScreen(asset.get('filename'));
                    evtPick = null;
                });

                // show asset picker
                editor.call("picker:asset", "script", null);

                editor.once('picker:asset:close', function () {
                    if (evtPick) {
                        evtPick.unbind();
                        evtPick = null;
                    }
                });
            });

            Tooltip.attach({
                target: btnSelectScript.element,
                text: 'Select an existing loading screen script',
                align: 'bottom',
                root: root
            });

            var fieldScriptPicker = editor.call('attributes:addField', {
                parent: panelLoadingScreen,
                name: 'Script',
                type: 'button'
            });

            fieldScriptPicker.style['font-size'] = '11px';
            fieldScriptPicker.parent.hidden = true;

            var btnRemove = new ui.Button();
            btnRemove.class.add('remove');
            fieldScriptPicker.parent.append(btnRemove);
            btnRemove.on("click", function () {
                setLoadingScreen(null);
            });

            var setLoadingScreen = function (filename) {
                editor.call('project:setLoadingScreenScript', filename);
                fieldScriptPicker.text = filename ? filename : 'Select loading screen script';
                if (filename) {
                    btnRemove.class.remove('not-visible');
                } else {
                    btnRemove.class.add('not-visible');
                }

                onLoadingScreen(filename);
            };

            var onLoadingScreen = function (filename) {
                if (filename) {
                    fieldScriptPicker.text = filename;
                    fieldScriptPicker.parent.hidden = false;
                    panelButtons.hidden = true;
                } else {
                    fieldScriptPicker.parent.hidden = true;
                    panelButtons.hidden = false;
                }
            };

            editor.call('project:getLoadingScreenScript', onLoadingScreen);

            fieldScriptPicker.on('click', function () {
                var evtPick = editor.once("picker:asset", function (asset) {
                    setLoadingScreen(asset.get('filename'));
                    evtPick = null;
                });

                // show asset picker
                editor.call("picker:asset", "script", null);

                editor.once('picker:asset:close', function () {
                    if (evtPick) {
                        evtPick.unbind();
                        evtPick = null;
                    }
                });
            });

            // reference
            editor.call('attributes:reference:settings:loadingScreenScript:attach', fieldScriptPicker.parent.innerElement.firstChild.ui);

            // drag drop
            var dropRef = editor.call('drop:target', {
                ref: panelLoadingScreen.element,
                filter: function(type, data) {
                    var rectA = root.innerElement.getBoundingClientRect();
                    var rectB = panelLoadingScreen.element.getBoundingClientRect();
                    return type === 'asset.script' && data.filename !== fieldScriptPicker.text && rectB.top > rectA.top && rectB.bottom < rectA.bottom;
                },
                drop: function(type, data) {
                    if (type !== 'asset.script')
                        return;

                    setLoadingScreen(data.filename);
                }
            });

        } else {
            var labelUpgrade = new ui.Label({
                text: 'This is an ORG account feature. <a href="/upgrade" target="_blank">UPGRADE</a> to create custom loading screens.'
            });
            labelUpgrade.style.fontSize = '12px';
            labelUpgrade.style.color = '#fff';
            panelLoadingScreen.append(labelUpgrade);
        }

    });
});


/* editor/scene-settings/scene-settings-priority-scripts.js */
editor.once('load', function() {
    'use strict';

    var sceneSettings = editor.call('sceneSettings');
    var sourcefiles = null;
    var priorityScripts = [];

    var refreshPriorityList = function () {
        priorityList.clear();

        if (priorityScripts.length === 0) {
            var item = new ui.ListItem();
            priorityList.append(item);
        } else {
            priorityScripts.forEach(function (script, index) {
                var item = new ui.ListItem();
                item.text = script;

                var moveUp = new ui.Button();
                moveUp.class.add('move-up');
                if (index) {
                    moveUp.on("click", function () {
                        var index = priorityScripts.indexOf(script);
                        priorityScripts.splice(index, 1);
                        priorityScripts.splice(index-1, 0, script);
                        sceneSettings.set("priority_scripts", priorityScripts);
                        refreshPriorityList();
                    });
                } else {
                    moveUp.class.add('not-visible')
                }

                var moveDown = new ui.Button();
                moveDown.class.add('move-down');
                if (index < priorityScripts.length-1) {
                    moveDown.on("click", function () {
                        var index = priorityScripts.indexOf(script);
                        priorityScripts.splice(index, 1);
                        priorityScripts.splice(index+1, 0, script);
                        sceneSettings.set("priority_scripts", priorityScripts);
                        refreshPriorityList();
                    });
                } else {
                    moveDown.class.add('not-visible');
                }

                var remove = new ui.Button();
                remove.class.add('remove');
                remove.on("click", function () {
                    var index = priorityScripts.indexOf(script);
                    priorityScripts.splice(index, 1);
                    sceneSettings.set("priority_scripts", priorityScripts);
                    refreshPriorityList();
                });

                item.element.appendChild(remove.element);
                item.element.appendChild(moveUp.element);
                item.element.appendChild(moveDown.element);

                priorityList.append(item);
            });
        }
    };

    editor.on('sourcefiles:load', function (obs) {
        sourcefiles = obs;
    });

    var root = editor.call('layout.root');

    var overlay = new ui.Overlay();
    overlay.class.add("script-priorities");
    overlay.hidden = true;

    var label = new ui.Label();
    label.text = "Script Loading Priority";
    label.class.add('title');
    overlay.append(label);

    var description = new ui.Label();
    description.text = "Scripts in the priority list are loaded first in the order that they are listed. Other scripts are loaded in an unspecified order.";
    description.class.add('description');
    overlay.append(description);

    var panel = new ui.Panel();
    overlay.append(panel);

    // Add new script button
    var button = new ui.Button();
    button.text = "Add Script";
    button.class.add('add-script');
    button.on("click", function (evt) {
        // use asset-picker to select script
        overlay.hidden = true;
        editor.once("picker:asset", function (asset) {
            overlay.hidden = false;
            var value = asset.get("filename");
            if (priorityScripts.indexOf(value) < 0) {
                priorityScripts.push(value);
                if (sceneSettings.get('priority_scripts')) {
                    sceneSettings.insert("priority_scripts", value);
                } else {
                    sceneSettings.set('priority_scripts', priorityScripts);
                }
                refreshPriorityList();
            }
        });
        editor.once("picker:asset:close", function (asset) {
            overlay.hidden = false;
        });

        // show asset picker
        editor.call("picker:asset", "script", null);
    });
    overlay.append(button);

    var priorityList = new ui.List();
    sceneSettings.on("priority_scripts:set", function (scripts) {
        priorityScripts = scripts.slice();
        refreshPriorityList();
    });
    panel.append(priorityList);

    root.append(overlay);

    // esc > no
    editor.call('hotkey:register', 'sceneSettings:priorityScripts:close', {
        key: 'esc',
        callback: function() {
            if (overlay.hidden)
                return;

            overlay.hidden = true;
        }
    });

    editor.method('sceneSettings:priorityScripts', function () {
        overlay.hidden = false;
        refreshPriorityList();
    });
});


/* editor/repositories/repositories.js */
editor.once('load', function() {
    'use strict';

    var repositories = new Observer();

    // Load repositories
    editor.once('start', function() {
        Ajax
        .get('{{url.api}}/projects/{{project.id}}/repositories?access_token={{accessToken}}')
        .on('load', function(status, data) {
            var response = data.response[0];
            for (var key in response) {
                if (response.hasOwnProperty(key)) {
                    repositories.set(key, response[key]);
                }
            }

            editor.emit('repositories:load', repositories);
        });
    });

    // get repositories
    editor.method('repositories', function () {
        return repositories;
    });
});


/* editor/sourcefiles/sourcefiles.js */
editor.once('repositories:load', function (repositories) {
    'use strict';

    var sourcefiles = new ObserverList();

    var scriptNamePattern = new RegExp("^(?:[\\w\\d\\.-]+\\\/)*[\\w\\d\\.-]+(?:\\.js(?:on)?)?$", 'i');

    // get listing of sourcefiles
    Ajax
    .get('{{url.api}}/projects/{{project.id}}/repositories/' + repositories.get('current') + '/sourcefiles?access_token=' + config.accessToken)
    .on('load', function (status, data) {
        if (data.response && data.response.length) {
            data.response.forEach(function (sourcefile) {
                var observer = new Observer(sourcefile);
                sourcefiles.add(observer);
                editor.emit('sourcefiles:add', observer);
            });
        }

        editor.emit('sourcefiles:load', sourcefiles);
    });

    editor.method('sourcefiles:list', function () {
        return sourcefiles.array();
    });

    editor.method('sourcefiles:get', function (filename) {
        var entry = sourcefiles.findOne(function (file) {
            return file.get('filename') === filename;
        });

        return entry ? entry[1] : null;
    });

    // get script full URL
    editor.method('sourcefiles:url', function (relativeUrl) {
        var services = {
            directory: 'directory',
            bitbucket: 'bitbucket.org',
            github: 'github.com'
        };

        var fullUrl = [
            config.url.api,
            'projects',
            config.project.id,
            'repositories',
            repositories.get('current'),
            'sourcefiles',
            relativeUrl
        ].join('/') + '?access_token=' + config.accessToken;

        return fullUrl;
    });

    // get script content
    editor.method('sourcefiles:content', function (relativeUrl, callback) {
        var fullUrl = editor.call('sourcefiles:url', relativeUrl);

        new AjaxRequest({
            url: fullUrl,
            notJson: true
        })
        .on('load', function(status, data) {
            if (callback)
                callback(null, data);
        })
        .on('error', function (status) {
            if (callback)
                callback(status);
        });
    });

    editor.method('sourcefiles:create', function (url, content, callback) {
        if (repositories.get('current') !== 'directory') return;

        var data = {
            filename: url,
            content: content
        };

        var createUrl = [config.url.api, 'projects', config.project.id, 'repositories', repositories.get('current'), 'sourcefiles', url].join('/');
        createUrl += '?access_token=' + config.accessToken;

        Ajax
        .put(createUrl, data)
        .on('load', function (status, data) {

            var file = new Observer({
                filename: url
            });

            sourcefiles.add(file);

            editor.emit('sourcefiles:add', file);

            if (callback) {
                callback(null, file);
            }
        })
        .on('error', function (status, msg) {
            if (callback)
                callback(msg);
        });
    });

    editor.method('sourcefiles:rename', function (oldFilename, newFilename, callback) {
        if (repositories.get('current') !== 'directory') return;

        var data = {
            filename: newFilename
        };

        var renameUrl = [
            config.url.api,
            'projects',
            config.project.id,
            'repositories',
            repositories.get('current'),
            'sourcefiles',
            'rename',
            oldFilename
        ].join('/');
        renameUrl += '?access_token=' + config.accessToken;

        Ajax.put(renameUrl, data)
        .on('load', function (status, data) {
            if (callback)
                callback();
        })
        .on('error', function (err) {
            if (callback)
                callback(err);
        });
    });

    // save source file content
    editor.method('sourcefiles:save', function (content, relativeUrl, callback) {
        var saveUrl = [
            config.url.api,
            'projects',
            config.project.id,
            'repositories',
            repositories.get('current'),
            'sourcefiles',
            relativeUrl
        ].join('/');

        var data = {
            url: saveUrl,
            method: 'PUT',
            query: {
                'access_token': '{{accessToken}}'
            },
            data: {
                filename: relativeUrl,
                content: content
            },
            ignoreContentType: true,
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json'
            }
        };

        Ajax(data)
        .on('load', function () {
            if (callback)
                callback(null);
        })
        .on('error', function (err) {
            if (callback)
                callback(err);
        });
    });

    // rename on filename set
    editor.on('sourcefiles:add', function (file) {
        var setting = false;
        file.on('filename:set', function (value, oldValue) {
            if (!editor.call('permissions:write') || setting)
                return;

            if (! value) {
                setting = true;
                file.set('filename', oldValue);
                setting = false;
                return;
            }


            if (! value.toLowerCase().endsWith('.js')) {
                value += '.js';
                setting = true;
                file.set('filename', value);
                setting = false;
            }

            if (! scriptNamePattern.test(value)) {
                setting = true;
                file.set('filename', oldValue);
                setting = false;
                setTimeout(function () {
                    editor.call('status:error', 'Invalid script name');
                });
                return;
            }

            editor.call('sourcefiles:rename', oldValue, value, function (err) {
                if (err) {
                    setting = true;
                    file.set('filename', oldValue);
                    setting = false;
                    editor.call('status:error', 'Could not rename script: ' + err);
                } else {
                    // get script and if its content is the same as the skeleton script
                    // then recreate it
                    editor.call('sourcefiles:content', value, function (err, content) {
                        var newContents = null;
                        if (!err && content === editor.call('sourcefiles:skeleton', oldValue)) {
                            newContents = editor.call('sourcefiles:skeleton', value);
                            editor.call('sourcefiles:save', newContents, value);
                        }
                    });

                }
            });

        });
    });

    editor.on('sourcefiles:remove', function (sourcefile) {
        sourcefiles.remove(sourcefile);
    });

});


/* editor/sourcefiles/sourcefiles-skeleton.js */
editor.once('load', function () {
    'use strict';

    // returns skeleton script for a script with the specified url
    editor.method('sourcefiles:skeleton', function (url) {
        var parts = url.split('/');
        // remove .js extension
        var scriptName = parts[parts.length-1].slice(0,-3).replace(new RegExp("[\\.-]"), '_');
        var objectName = scriptName.charAt(0).toUpperCase() + scriptName.slice(1);

        var result = [
            "pc.script.create('" + scriptName + "', function (app) {",
            "    // Creates a new " + objectName + " instance",
            "    var " + objectName + " = function (entity) {",
            "        this.entity = entity;",
            "    };",
            "",
            "    " + objectName + ".prototype = {",
            "        // Called once after all resources are loaded and before the first update",
            "        initialize: function () {",
            "        },",
            "",
            "        // Called every frame, dt is time in seconds since last update",
            "        update: function (dt) {",
            "        }",
            "    };",
            "",
            "    return " + objectName + ";",
            "});"].join('\n');

        return result;
    });

    editor.method('sourcefiles:loadingScreen:skeleton', function () {
        return [
            "pc.script.createLoadingScreen(function (app) {",
            "    var showSplash = function () {",
            "        // splash",
            "        var splash = document.createElement('a');",
            "        splash.href = 'https://playcanvas.com/explore';",
            "        splash.target = '_blank';",
            "        splash.id = 'application-splash';",
            "        document.body.appendChild(splash);",
            "        splash.style.display = 'none';",
            "                                ",
            "        var logo = document.createElement('img');",
            "        logo.src = 'https://s3-eu-west-1.amazonaws.com/static.playcanvas.com/images/play_text_252_white.png';",
            "        splash.appendChild(logo);",
            "        logo.onload = function () {",
            "            splash.style.display = 'block';",
            "        };",
            "        ",
            "        var container = document.createElement('div');",
            "        container.id = 'progress-bar-container';",
            "        splash.appendChild(container);",
            "        ",
            "        var bar = document.createElement('div');",
            "        bar.id = 'progress-bar';",
            "        container.appendChild(bar);     ",
            "               ",
            "    };",
            "",
            "    var hideSplash = function () {",
            "        var splash = document.getElementById('application-splash');",
            "        splash.parentElement.removeChild(splash);",
            "    };",
            "",
            "    var setProgress = function (value) {",
            "        var bar = document.getElementById('progress-bar');",
            "        if(bar) {",
            "            value = Math.min(1, Math.max(0, value));",
            "            bar.style.width = value * 100 + '%';",
            "        }",
            "    };",
            "",
            "    var createCss = function () {",
            "        var css = [",
            "            'body {',",
            "            '    background-color: #283538;',",
            "            '}',",
            "            '#application-splash {',",
            "            '    position: absolute;',",
            "            '    top: calc(50% - 28px);',",
            "            '    width: 264px;',",
            "            '    left: calc(50% - 132px);',",
            "            '}',",
            "",
            "            '#application-splash img {',",
            "            '    width: 100%;',",
            "            '}',",
            "            ",
            "            '#progress-bar-container {', ",
            "            '    margin: 20px auto 0 auto;',",
            "            '    height: 2px;',",
            "            '    width: 100%;', ",
            "            '    background-color: #1d292c;',",
            "            '}',",
            "           ",
            "            '#progress-bar {',",
            "            '    width: 0%;',",
            "            '    height: 100%;',",
            "            '    background-color: #f60;',",
            "            '}',",
            "            '@media (max-width: 480px) {',",
            "            '    #application-splash {',",
            "            '        width: 170px;',",
            "            '        left: calc(50% - 85px);',",
            "            '    }',",
            "            '}'",
            "            ",
            "        ].join(\"\\n\");",
            "",
            "        var style = document.createElement('style');",
            "        style.type = 'text/css';",
            "        if (style.styleSheet) {",
            "          style.styleSheet.cssText = css;",
            "        } else {",
            "          style.appendChild(document.createTextNode(css));",
            "        }",
            "",
            "        document.head.appendChild(style);",
            "    };",
            "",
            "",
            "    createCss();",
            "",
            "    showSplash();",
            "        ",
            "    app.on('preload:end', function () {",
            "        app.off('preload:progress');",
            "    });",
            "    app.on('preload:progress', setProgress);",
            "    app.on('start', hideSplash);",
            "});"
        ].join('\n');
    });
});

/* editor/sourcefiles/sourcefiles-attributes-scan.js */
editor.once('load', function () {
    var VALID_TYPES = [
        'number',
        'string',
        'boolean',
        'asset',
        'rgb',
        'rgba',
        'vector',
        'enumeration',
        'entity',
        'curve',
        'colorcurve'
    ];

    var REGEX_GUID = /^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$/i;
    var REGEX_COLOR_CURVE = /^((r((gba?)?))|g|b|a)$/; // r or g or b or rgb or rgba

    var validators = {
        'number': function (url, attribute) {
            validateValue(url, attribute, 'number', 0);
        },

        'string': function (url, attribute) {
            validateValue(url, attribute, 'string', '');

            if (attribute.defaultValue.length > 512) {
                throw attributeErrorMsg(url, attribute, "Value exceeds 512 characters");
            }
        },


        'boolean': function (url, attribute) {
            validateValue(url, attribute, 'boolean', false);
        },

        'asset': function (url, attribute) {
            // TODO check max array length
            validateArrayValue(url, attribute, [], -1, 'number');
        },

        'vector': function (url, attribute) {
            validateArrayValue(url, attribute, [0,0,0], 3, 'number');
        },

        'rgb': function (url, attribute) {
            validateArrayValue(url, attribute, [0,0,0], 3, 'number');
        },

        'rgba': function (url, attribute) {
            validateArrayValue(url, attribute, [0,0,0,1], 4, 'number');
        },

        'enumeration': function (url, attribute) {
            if (attribute.options &&
                attribute.options.enumerations &&
                pc.type(attribute.options.enumerations) === 'array' &&
                attribute.options.enumerations.length) {

                var valueType;
                var enumerations = attribute.options.enumerations;
                // TODO check enumerations max length
                for (var i=0; i<enumerations.length; i++) {
                    if (pc.type(enumerations[i]) !== 'object') {
                        throw attributeErrorMsg(url, attribute, "Each enumeration must be an object with this form: {name: '...', value: ...}");
                    } else {
                        if (pc.type(enumerations[i].name) !== 'string' ||
                            enumerations[i].name.length === 0 ||
                            pc.type(enumerations[i].value) === 'undefined') {

                            throw attributeErrorMsg(url, attribute, "Each enumeration must be an object with this form: {name: '...', value: ...}");
                        } else {
                            if (!valueType) {
                                valueType = pc.type(enumerations[i].value);
                            } else {
                                if (valueType !== pc.type(enumerations[i].value)) {
                                    throw attributeErrorMsg(url, attribute, "All enumerations values must be the same type");
                                }
                            }
                        }
                    }
                }

                validateValue(url, attribute, valueType, enumerations[0].value);

                var isValueInEnumerations = false;
                for (var i = 0; i < enumerations.length; i++) {
                    if (enumerations[i].value === attribute.defaultValue) {
                        isValueInEnumerations = true;
                        break;
                    }
                }

                if (!isValueInEnumerations) {
                    throw attributeErrorMsg(url, attribute, "Value is not one of the possible enumerations");
                }
            } else {
                throw attributeErrorMsg(url, attribute, "Missing enumerations from attribute options");
            }
        },

        'entity': function (url, attribute) {
            validateValue(url, attribute, 'string', null);

            if (attribute.defaultValue && !REGEX_GUID.test(attribute.defaultValue)) {
                throw attributeErrorMsg(url, attribute, "Value is not a valid Entity resource id");
            }
        },

        'curve': function (url, attribute) {
            if (!attribute.options)
                attribute.options = {};

            if (!attribute.options.curves) {
                attribute.options.curves = ['Value'];
            } else {
                if (!attribute.options.curves.length) {
                    throw attributeErrorMsg(url, attribute, "Curves option must be a non-empty string array");
                } else if (attribute.options.curves.length > 4) {
                    throw attributeErrorMsg(url, attribute, "Curves option cannot exceed 4 elements");
                }
            }

            if (attribute.defaultValue !== null && attribute.defaultValue !== undefined) {
                if (typeof attribute.defaultValue !== 'object' || attribute.defaultValue instanceof Array)
                    throw attributeErrorMsg(url, attribute, "Invalid default value for curve attribute");

                var validData = {
                    type: attribute.defaultValue.type,
                    keys: attribute.defaultValue.keys
                };

                attribute.defaultValue = validData;

                if (validData.type !== undefined) {
                    if (validData.type !== 0 && validData.type !== 1 && validData.type !== 2) {
                        throw attributeErrorMsg(url, attribute, "Invalid type. Needs to be one of: 0, 1, 2");
                    }
                }

                if (!(validData.keys instanceof Array)) {
                    throw attributeErrorMsg(url, attribute, "Invalid keys. Needs to be an array");
                }

                if (attribute.options.curves.length > 1) {
                    if (validData.keys.length !== 0 && validData.keys.length !== attribute.options.curves.length) {
                        throw attributeErrorMsg(url, attribute, 'Invalid keys. Needs to be an array of ' + attribute.options.curves.length + ' arrays');
                    } else {
                        for (var i = 0, len = validData.keys.length; i < len; i++) {
                            if (!(validData.keys[i] instanceof Array)) {
                                throw attributeErrorMsg(url, attribute, 'Invalid keys. Needs to be an array of ' + len + ' arrays');
                            } else {
                                var len2 = validData.keys[i].length;
                                if (len2 % 2 !== 0)
                                    throw attributeErrorMsg(url, attribute, 'Invalid keys. Array must hold an even amount of numbers');

                                for (var j = 0; j < len2; j++) {
                                    if (typeof validData.keys[i][j] !== 'number')
                                        throw attributeErrorMsg(url, attribute, 'Invalid keys. Array values must be numbers');
                                }
                            }
                        }
                    }
                } else {
                    if (attribute.options.curves.length === 1) {
                        if (validData.keys.length % 2 !== 0)
                            throw attributeErrorMsg(url, attribute, 'Invalid keys. Array must hold an even amount of numbers');

                        for (var i = 0, len = validData.keys.length; i < len; i++) {
                            if (typeof validData.keys[i] !== 'number')
                                throw attributeErrorMsg(url, attribute, 'Invalid keys. Array values must be numbers');
                        }
                    }
                }
            } else {
                attribute.defaultValue = {
                    type: 1,
                    keys: []
                };

                if (attribute.options.curves.length === 1)
                    attribute.defaultValue.keys = [0, 0];
                else {
                    for (var i = 0; i < attribute.options.curves.length; i++) {
                        attribute.defaultValue.keys.push([0, 0]);
                    }
                }
            }
        },

        'colorcurve': function (url, attribute) {
            if (!attribute.options)
                attribute.options = {};

            if (!attribute.options.type) {
                attribute.options.type = 'rgb';
            } else {
                if (!REGEX_COLOR_CURVE.test(attribute.options.type)) {
                    throw attributeErrorMsg(url, attribute, "Color curve type can be one of 'r', 'g', 'b', 'a', 'rgb', 'rgba'");
                }
            }

            if (attribute.defaultValue !== null && attribute.defaultValue !== undefined) {
                if (typeof attribute.defaultValue !== 'object' || attribute.defaultValue instanceof Array)
                    throw attributeErrorMsg(url, attribute, "Invalid default value for curve attribute");

                var validData = {
                    type: attribute.defaultValue.type,
                    keys: attribute.defaultValue.keys
                };

                attribute.defaultValue = validData;

                if (validData.type !== undefined) {
                    if (validData.type !== 0 && validData.type !== 1 && validData.type !== 2) {
                        throw attributeErrorMsg(url, attribute, "Invalid type. Needs to be one of: 0, 1, 2");
                    }
                }

                if (!(validData.keys instanceof Array)) {
                    throw attributeErrorMsg(url, attribute, "Invalid keys. Needs to be an array");
                }

                if (attribute.options.type.length > 1) {
                    if (validData.keys.length !== 0 && validData.keys.length !== attribute.options.type.length) {
                        throw attributeErrorMsg(url, attribute, 'Invalid keys. Needs to be an array of ' + attribute.options.type.length + ' arrays');
                    } else {
                        for (var i = 0, len = validData.keys.length; i < len; i++) {
                            if (!(validData.keys[i] instanceof Array)) {
                                throw attributeErrorMsg(url, attribute, 'Invalid keys. Needs to be an array of ' + len + ' arrays');
                            } else {
                                var len2 = validData.keys[i].length;
                                if (len2 % 2 !== 0)
                                    throw attributeErrorMsg(url, attribute, 'Invalid keys. Array must hold an even amount of numbers');

                                for (var j = 0; j < len2; j++) {
                                    if (typeof validData.keys[i][j] !== 'number')
                                        throw attributeErrorMsg(url, attribute, 'Invalid keys. Array values must be numbers');
                                }
                            }
                        }
                    }
                } else {
                    if (attribute.options.type.length === 1) {
                        if (validData.keys.length % 2 !== 0)
                            throw attributeErrorMsg(url, attribute, 'Invalid keys. Array must hold an even amount of numbers');

                        for (var i = 0, len = validData.keys.length; i < len; i++) {
                            if (typeof validData.keys[i] !== 'number')
                                throw attributeErrorMsg(url, attribute, 'Invalid keys. Array values must be numbers');
                        }
                    }
                }
            } else {
                attribute.defaultValue = {
                    type: 1,
                    keys: []
                };

                if (attribute.options.type.length === 1)
                    attribute.defaultValue.keys = [0, 0];
                else {
                    for (var i = 0; i < attribute.options.type.length; i++) {
                        attribute.defaultValue.keys.push([0, 0]);
                    }
                }
            }
        }
    };

    var validateValue = function (url, attribute, correctType, valueIfUndefined) {
        var type = pc.type(attribute.defaultValue);
        if (type === 'undefined' || type === 'null') {
            attribute.defaultValue = valueIfUndefined;
        } else if (type !== correctType) {
            throw attributeErrorMsg(url, attribute, 'Value is not of type ' + correctType);
        }
    };

    var validateArrayValue = function (url, attribute, valueIfUndefined, correctLength, typeofElements) {
        validateValue(url, attribute, 'array', valueIfUndefined);

        if (correctLength >= 0 && attribute.defaultValue.length !== correctLength) {
            throw attributeErrorMsg(url, attribute, pc.string.format('Value must be an array with {0} elements of type {1}', correctLength, typeofElements));
        } else {
            for (var i=0; i<attribute.defaultValue.length; i++) {
                if (typeof attribute.defaultValue[i] !== typeofElements) {
                    throw attributeErrorMsg(url, attribute, pc.string.format('Value must be an array with elements of type {0}', typeofElements));
                }
            }
        }
    };

    var attributeErrorMsg = function (url, attribute, error) {
        return pc.string.format("Attribute '{0}' of script {1} is invalid: {2}", attribute.name, url, error);
    };

    var validateScriptAttributes = function (url, data) {
        var hasErrors = false;
        var validated = {
            name: data.name,
            attributes: {},
            attributesOrder: []
        };

        data.values.forEach(function (attr) {
            try {
                // check if name is valid
                if (typeof attr.name !== 'string' || !attr.name) {
                    throw pc.string.format("Validation error in {0}: Missing attribute name", url);
                }

                if (attr.name.length > 128) {
                    throw pc.string.format(pc.string.format("Validation error in {0}: Attribute name exceeds 128 characters", url));
                }

                // check if type is valid
                if (typeof attr.type === 'undefined') {
                    throw attributeErrorMsg(url, attr, "Missing attribute type");
                }

                if (VALID_TYPES.indexOf(attr.type) < 0) {
                    throw attributeErrorMsg(url, attr, pc.string.format("{0} is not a valid attribute type", attr.type));
                }

                if (attr.options) {
                    if (attr.options.displayName) {
                        if (typeof attr.options.displayName !== 'string') {
                            throw attributeErrorMsg(url, attr, "Display name of attribute must be a string");
                        }

                        if (attr.options.displayName.length > 128) {
                            throw attributeErrorMsg(url, attr, "Display name of attribute cannot exceed 128 characters");
                        }
                    }

                    if (attr.options.description) {
                        if (typeof attr.options.description !== 'string') {
                            throw attributeErrorMsg(url, attr, "Description of attribute must be a string");
                        }

                        if (attr.options.description.length > 1024) {
                            throw attributeErrorMsg(url, attr, "Description of attribute cannot exceed 1024 characters");
                        }
                    }
                }

                // type-specific validations
                validators[attr.type](url, attr);

                if (validated.attributes[attr.name]) {
                    throw attributeErrorMsg(url, attr, 'Duplicate attribute');
                }

                validated.attributesOrder.push(attr.name);

                validated.attributes[attr.name] = {
                    name: attr.name,
                    displayName: attr.options && attr.options.displayName ? attr.options.displayName : attr.name,
                    description: attr.options ? attr.options.description : undefined,
                    defaultValue: attr.defaultValue,
                    value: attr.defaultValue,
                    type: attr.type,
                    options: attr.options ? {
                        // Only allowed options
                        max: attr.options.max,
                        min: attr.options.min,
                        step: attr.options.step,
                        type: attr.options.type,
                        decimalPrecision: attr.options.decimalPrecision,
                        enumerations: attr.options.enumerations,
                        curves: attr.options.curves,
                        color: attr.options.color
                    } : {}
                };
            } catch (e) {
                hasErrors = true;
                console.error(e);
            }
        });

        if (hasErrors) {
            editor.call('status:error', 'Error while parsing script attributes. Open browser console for details.');
            validated = null;
        }

        return validated;
    };

    // only allow scrpts from playcanvas, code.playcanvas.com and localhost:51000 to be parsed
    var REGEX_ALLOWED = new RegExp('^((http(s)?:\/\/)((code.playcanvas.com)|(localhost:51000)))|(' + config.url.api + ')');

    /**
    * Starts a web worker which scans the specified URL
    * for script attributes, then validates the result and passes it to
    * the success callback
    */
    editor.method('sourcefiles:scan', function (url, success) {
        if (!REGEX_ALLOWED.test(url)) {
            success({});
            return;
        }

        var worker = new Worker("/editor/scene/js/editor/sourcefiles/sourcefiles-attributes-parser.js");
        worker.postMessage({
            url: url
        });

        worker.onmessage = function (e) {
            if (e.data) {
                if (typeof e.data.error !== 'undefined') {
                    editor.call('status:error', pc.string.format("Could not parse {0} - {1}", url, e.data.error));
                } else {
                    var result = validateScriptAttributes(url, e.data);
                    if (result) {
                        success(result);
                    }
                }
            }
        };
    });
});


/* editor/storage/localstorage.js */
editor.once('load', function () {
    // Get a key from the local storage
    editor.method('localStorage:get', function (key) {
        var value = localStorage.getItem(key);
        if (value) {
            try {
                value = JSON.parse(value);
            } catch (e) {
                console.error(e);
            }
        }

        return value;
    });

    // Set a key-value pair in localStorage
    editor.method('localStorage:set', function (key, value) {
        localStorage.setItem(key, JSON.stringify(value));
    });

    // Returns true if the key exists in the local storage
    editor.method('localStorage:has', function (key) {
        return !!localStorage.getItem(key);
    });

});

/* editor/entities/entities.js */
editor.once('load', function() {
    'use strict';

    var entities = new ObserverList({
        index: 'resource_id'
    });

    var entityRoot = null;

    // on adding
    entities.on('add', function(entity) {
        editor.emit('entities:add', entity);
    });

    // on removing
    entities.on('remove', function(entity) {
        editor.emit('entities:remove', entity);
        entity.destroy();
    });


    // allow adding entity
    editor.method('entities:add', function(entity) {
        if (! entity.get('parent'))
            entityRoot = entity;

        entities.add(entity);
    });

    // allow remove entity
    editor.method('entities:remove', function(entity) {
        entities.remove(entity);
    });

    // remove all entities
    editor.method('entities:clear', function () {
        entities.clear();
    });

    // get entity
    editor.method('entities:get', function(resourceId) {
        return entities.get(resourceId);
    });


    // list entities
    editor.method('entities:list', function() {
        return entities.array();
    });


    // get root entity
    editor.method('entities:root', function () {
        return entityRoot;
    });

});


/* editor/entities/entities-selection.js */
editor.once('load', function() {
    'use strict';

    // returns all selected entities
    editor.method('entities:selection', function () {
        if (editor.call('selector:type') !== 'entity')
            return [ ];

        return editor.call('selector:items').slice(0);
    });

    // returns first selected entity
    editor.method('entities:selectedFirst', function () {
        var selection = editor.call('entities:selection');
        if (selection.length) {
            return selection[0];
        } else {
            return null;
        }
    });
});




/* editor/entities/entities-edit.js */
editor.once('load', function() {
    'use strict';

    // index
    var childToParent = { };

    var deletedCache = { };

    // add
    editor.on('entities:add', function(entity) {
        var children = entity.get('children');
        for(var i = 0; i < children.length; i++) {
            childToParent[children[i]] = entity.get('resource_id');
        }

        entity.on('children:insert', function(value) {
            childToParent[value] = this.get('resource_id');
        });
        entity.on('children:remove', function(value) {
            delete childToParent[value];
        });
    });


    // new entity
    editor.method('entities:new', function (raw) {
        // get root if parent is null
        raw = raw || { };
        var parent = raw.parent || editor.call('entities:root');

        var data = {
            name: raw.name || 'New Entity',
            enabled: true,
            resource_id: pc.guid.create(),
            parent: parent.get('resource_id'),
            children: [ ],
            position: [ 0, 0, 0 ],
            rotation: [ 0, 0, 0 ],
            scale: [ 1, 1, 1 ],
            components: raw.components || { }
        };

        var selectorType = editor.call('selector:type');
        var selectorItems = editor.call('selector:items');
        if (selectorType === 'entity') {
            for(var i = 0; i < selectorItems.length; i++)
                selectorItems[i] = selectorItems[i].get('resource_id');
        }

        // create new Entity data
        var entity = new Observer(data);
        childToParent[entity.get('resource_id')] = parent.get('resource_id');
        addEntity(entity, parent, true);

        // history
        var resourceId = entity.get('resource_id');
        var parentId = parent.get('resource_id');

        editor.call('history:add', {
            name: 'new entity ' + resourceId,
            undo: function() {
                var entity = editor.call('entities:get', resourceId);
                if (! entity)
                    return;

                removeEntity(entity);

                if (selectorType === 'entity' && selectorItems.length) {
                    var items = [ ];
                    for(var i = 0; i < selectorItems.length; i++) {
                        var item = editor.call('entities:get', selectorItems[i]);
                        if (item)
                            items.push(item);
                    }

                    if (items.length) {
                        editor.call('selector:history', false);
                        editor.call('selector:set', selectorType, items);
                        editor.once('selector:change', function() {
                            editor.call('selector:history', true);
                        });
                    }
                }
            },
            redo: function() {
                var parent = editor.call('entities:get', parentId);
                if (! parent)
                    return;

                var entity = new Observer(data);
                childToParent[entity.get('resource_id')] = parent.get('resource_id');
                addEntity(entity, parent, true);
            }
        });

        return entity;
    });

    var addEntity = function(entity, parent, select, ind) {
        var children = entity.get('children');
        if (children.length)
            entity.set('children', [ ]);

        // call add event
        editor.call('entities:add', entity);

        // sharejs
        editor.call('realtime:scene:op', {
            p: [ 'entities', entity.get('resource_id') ],
            oi: entity.json()
        });

        // this is necessary for the entity to be added to the tree view
        parent.history.enabled = false;
        parent.insert('children', entity.get('resource_id'), ind);
        parent.history.enabled = true;

        if (select) {
            setTimeout(function() {
                editor.call('selector:history', false);
                editor.call('selector:set', 'entity', [ entity ]);
                editor.once('selector:change', function() {
                    editor.call('selector:history', true);
                });
            }, 0);
        }

        // add children too
        children.forEach(function(childId) {
            var data = deletedCache[childId];
            if (! data)
                return;

            var child = new Observer(data);
            childToParent[child.get('resource_id')] = entity.get('resource_id');
            addEntity(child, entity);
        });
    };

    var removeEntity = function(entity) {
        deletedCache[entity.get('resource_id')] = entity.json();

        // remove children
        entity.get('children').forEach(function (child) {
            var entity = editor.call('entities:get', child);
            if (! entity)
                return;

            removeEntity(entity);
        });

        if (editor.call('selector:type') === 'entity' && editor.call('selector:items').indexOf(entity) !== -1) {
            editor.call('selector:history', false);
            editor.call('selector:remove', entity);
            editor.once('selector:change', function() {
                editor.call('selector:history', true);
            });
        }

        // remove from parent
        var parentId = childToParent[entity.get('resource_id')];
        if (parentId) {
            var parent = editor.call('entities:get', parentId);
            if (parent) {
                parent.history.enabled = false;
                parent.removeValue('children', entity.get('resource_id'));
                parent.history.enabled = true;
            }
        }

        // call remove method
        editor.call('entities:remove', entity);

        // sharejs
        editor.call('realtime:scene:op', {
            p: [ 'entities', entity.get('resource_id') ],
            od: { }
        });
    };

    var duplicateEntity = function(entity, parent, ind) {
        var resourceId = entity.get('resource_id');
        var data = entity.json();
        var children = data.children;

        data.children = [ ];
        data.resource_id = pc.guid.create();
        data.parent = parent.get('resource_id');

        entity = new Observer(data);
        childToParent[entity.get('resource_id')] = parent.get('resource_id');

        // call add event
        editor.call('entities:add', entity);

        // sharejs
        editor.call('realtime:scene:op', {
            p: [ 'entities', entity.get('resource_id') ],
            oi: entity.json()
        });

        // this is necessary for the entity to be added to the tree view
        parent.history.enabled = false;
        parent.insert('children', entity.get('resource_id'), ind);
        parent.history.enabled = true;

        // add children too
        children.forEach(function(childId) {
            duplicateEntity(editor.call('entities:get', childId), entity);
        });

        return entity;
    };

    // duplicate entity
    editor.method('entities:duplicate', function (entity) {
        var resourceId = entity.get('resource_id');
        var parentId = childToParent[resourceId];
        var parent = editor.call('entities:get', parentId);

        var ind = parent.get('children').indexOf(resourceId);

        var entityNew = duplicateEntity(entity, parent, ind + 1);
        var data = entityNew.json();

        var selectorType = editor.call('selector:type');
        var selectorItems = editor.call('selector:items');
        if (selectorType === 'entity') {
            for(var i = 0; i < selectorItems.length; i++)
                selectorItems[i] = selectorItems[i].get('resource_id');
        }

        setTimeout(function() {
            editor.call('selector:history', false);
            editor.call('selector:set', 'entity', [ entityNew ]);
            editor.once('selector:change', function() {
                editor.call('selector:history', true);
            });
        }, 0);

        editor.call('history:add', {
            name: 'duplicate entity ' + resourceId,
            undo: function() {
                var entity = editor.call('entities:get', data.resource_id);
                if (! entity)
                    return;

                removeEntity(entity);

                if (selectorType === 'entity' && selectorItems.length) {
                    var items = [ ];
                    for(var i = 0; i < selectorItems.length; i++) {
                        var item = editor.call('entities:get', selectorItems[i]);
                        if (item)
                            items.push(item);
                    }

                    if (items.length) {
                        editor.call('selector:history', false);
                        editor.call('selector:set', selectorType, items);
                        editor.once('selector:change', function() {
                            editor.call('selector:history', true);
                        });
                    }
                }
            },
            redo: function() {
                var parent = editor.call('entities:get', parentId);
                if (! parent)
                    return;

                var entity = new Observer(data);
                childToParent[entity.get('resource_id')] = parent.get('resource_id');
                addEntity(entity, parent, true, ind + 1);
            }
        });
    });

    // delete entity
    editor.method('entities:delete', function (items) {
        var records = [ ];
        var itemsToDelete = [ ];

        // index items
        var itemsIds = { };
        for(var i = 0; i < items.length; i++) {
            itemsIds[items[i].get('resource_id')] = items[i];
        }

        // find out if item has ancestor
        for(var i = 0; i < items.length; i++) {
            var child = false;
            var parent = childToParent[items[i].get('resource_id')];
            while(! child && parent) {
                if (itemsIds[parent]) {
                    child = true;
                } else {
                    parent = childToParent[parent]
                }
            }

            if (! child)
                itemsToDelete.push(items[i]);
        }

        // delete only non-childed items
        items = itemsToDelete;

        for(var i = 0; i < items.length; i++) {
            var resourceId = items[i].get('resource_id');
            var parentId = childToParent[resourceId];
            var ind;
            if (parentId) {
                var parent = editor.call('entities:get', parentId);
                if (parent)
                    ind = parent.get('children').indexOf(resourceId);
            }

            records.push({
                resourceId: resourceId,
                parentId: parentId,
                ind: ind,
                data: items[i].json()
            });
        }

        for(var i = 0; i < items.length; i++) {
            removeEntity(items[i]);
        }

        editor.call('history:add', {
            name: 'delete entities',
            undo: function() {
                var items = [ ];
                var i = records.length;
                while(i--) {
                    var parent = editor.call('entities:get', records[i].parentId);
                    if (! parent)
                        return;

                    var entity = new Observer(records[i].data);
                    items.push(entity);
                    childToParent[entity.get('resource_id')] = parent.get('resource_id');
                    addEntity(entity, parent, false, records[i].ind);
                }

                setTimeout(function() {
                    editor.call('selector:history', false);
                    editor.call('selector:set', 'entity', items);
                    editor.once('selector:change', function() {
                        editor.call('selector:history', true);
                    });
                }, 0);
            },
            redo: function() {
                for(var i = 0; i < records.length; i++) {
                    var entity = editor.call('entities:get', records[i].resourceId);
                    if (! entity)
                        return;

                    removeEntity(entity);
                }
            }
        });
    });

    // copy entity to local storage
    editor.method('entities:copy', function (entity) {
        var data = {
            project: config.project.id,
            hierarchy: {}
        };

        // gather all dependencies of this entity
        var gatherDependencies = function (entity) {
            var resourceId = entity.get('resource_id');
            if (! data.hierarchy[resourceId]) {
                data.hierarchy[resourceId] = entity.json();
            }

            var children = entity.get('children');
            for (var i = 0; i < children.length; i++) {
                gatherDependencies(editor.call('entities:get', children[i]));
            }
        };

        gatherDependencies(entity);

        // remove parent from copied entity
        data.hierarchy[entity.get('resource_id')].parent = null;

        // save to local storage
        editor.call('entities:clipboard:set', data);
    });

    // paste entity in local storage under parent
    editor.method('entities:paste', function (parent) {
        // parse data from local storage
        var data = editor.call('entities:clipboard:get');
        if (! data)
            return;

        // check it's the same project
        if (data.project !== config.project.id)
            return;

        // change resource ids
        var mapping = {};

        var remapResourceIds = function (entity) {
            var resourceId = entity.get('resource_id');

            // create new resource id for entity
            if (! mapping[resourceId]) {
                mapping[resourceId] = pc.guid.create();
            }

            var newResourceId = mapping[resourceId];
            entity.set('resource_id', newResourceId);

            // set new resource id for parent
            var parentId = entity.get('parent');
            if (parentId) {
                if (! mapping[parentId]) {
                    mapping[parentId] = pc.guid.create();
                }

                entity.set('parent', mapping[parentId]);
            } else {
                entity.set('parent', parent.get('resource_id'));
            }

            childToParent[newResourceId] = entity.get('parent');

            // set children to empty array because these
            // are going to get added later on
            entity.set('children', []);
        };

        // add all entities with different resource ids
        var newEntity = null;
        var newEntities = [];

        for (var resourceId in data.hierarchy) {
            // create new entity
            var entity = new Observer(data.hierarchy[resourceId]);

            // find root of pasted hierarchy
            if (!entity.get('parent'))
                newEntity = entity;

            // change resource ids
            remapResourceIds(entity);

            // add it
            editor.call('entities:add', entity);
            newEntities.push(entity);
        }

        // reparent children correctly
        for (var i = 0; i < newEntities.length; i++) {
            var entity = newEntities[i];
            var parentEntity = editor.call('entities:get', entity.get('parent'));

            // sharejs
            editor.call('realtime:scene:op', {
                p: [ 'entities', entity.get('resource_id') ],
                oi: entity.json()
            });

            // this is necessary for the entity to be added to the tree view
            parentEntity.history.enabled = false;
            parentEntity.insert('children', entity.get('resource_id'));
            parentEntity.history.enabled = true;
        }

        // select pasted entity
        setTimeout(function() {
            editor.call('selector:history', false);
            editor.call('selector:set', 'entity', [ newEntity ]);
            editor.once('selector:change', function() {
                editor.call('selector:history', true);
            });
        }, 0);

        // get final raw json for pasted entity
        var pastedData = newEntity.json();

        // add history
        editor.call('history:add', {
            name: 'paste entity ' + pastedData.resource_id,
            undo: function() {
                var entity = editor.call('entities:get', pastedData.resource_id);
                if (! entity)
                    return;

                removeEntity(entity);

                var selectorType = editor.call('selector:type');
                var selectorItems = editor.call('selector:items');
                if (selectorType === 'entity' && selectorItems.length) {
                    var items = [ ];
                    for(var i = 0; i < selectorItems.length; i++) {
                        var item = editor.call('entities:get', selectorItems[i]);
                        if (item)
                            items.push(item);
                    }

                    if (items.length) {
                        editor.call('selector:history', false);
                        editor.call('selector:set', selectorType, items);
                        editor.once('selector:change', function() {
                            editor.call('selector:history', true);
                        });
                    }
                }
            },
            redo: function() {
                var parentEntity = editor.call('entities:get', parent.get('resource_id'));
                if (! parentEntity)
                    return;

                var entity = new Observer(pastedData);
                childToParent[entity.get('resource_id')] = parentEntity.get('resource_id');
                addEntity(entity, parentEntity, true);
            }
        });
    });
});


/* editor/entities/entities-panel.js */
editor.once('load', function() {
    'use strict'

    // hierarchy index
    var uiItemIndex = { };
    var awaitingParent = { };

    var panel = editor.call('layout.left');

    // list
    var hierarchy = new ui.Tree();
    hierarchy.allowRenaming = true;
    hierarchy.class.add('hierarchy');
    panel.append(hierarchy);

    var resizeTree = function() {
        hierarchy.element.style.width = '';
        hierarchy.element.style.width = (panel.innerElement.scrollWidth - 5) + 'px';
    };
    panel.on('resize', resizeTree);
    hierarchy.on('open', resizeTree);
    hierarchy.on('close', resizeTree);
    setInterval(resizeTree, 500);


    // return hirarchy
    editor.method('entities:hierarchy', function () {
        return hierarchy;
    });

    // list item selected
    hierarchy.on('select', function(item) {
        // open items till parent
        var parent = item.parent;
        while(parent && parent instanceof ui.TreeItem) {
            parent.open = true;
            parent = parent.parent;
        }
        // focus
        item.elementTitle.focus();
        // add selection
        editor.call('selector:add', 'entity', item.entity);
    });

    // list item deselected
    hierarchy.on('deselect', function(item) {
        editor.call('selector:remove', item.entity);
    });


    // scrolling on drag
    var dragScroll = 0;
    var dragTimer;
    var dragLastEvt;
    var dragEvt = function(evt) {
        if (! hierarchy._dragging) {
            clearInterval(dragTimer);
            window.removeEventListener('mousemove', dragEvt);
            return;
        }
        var rect = panel.innerElement.getBoundingClientRect();

        if ((evt.clientY - rect.top) < 32 && panel.innerElement.scrollTop > 0) {
            dragScroll = -1;
        } else if ((rect.bottom - evt.clientY) < 32 && (panel.innerElement.scrollHeight - (rect.height + panel.innerElement.scrollTop)) > 0) {
            dragScroll = 1;
        } else {
            dragScroll = 0;
        }
    };
    hierarchy.on('dragstart', function() {
        dragTimer = setInterval(function() {
            if (dragScroll === 0)
                return;

            panel.innerElement.scrollTop += dragScroll * 8;
            hierarchy._dragOver = null;
            hierarchy._updateDragHandle();
        }, 1000 / 60);

        dragScroll = 0;
        window.addEventListener('mousemove', dragEvt, false);

        var resourceId = hierarchy._dragItems[0].entity.get('resource_id');
        editor.call('drop:set', 'entity', { resource_id: resourceId });
        editor.call('drop:activate', true);
    });

    hierarchy.on('dragend', function() {
        editor.call('drop:activate', false);
        editor.call('drop:set');
    });


    var target = editor.call('drop:target', {
        ref: panel.innerElement,
        type: 'entity',
        hole: true,
        passThrough: true
    });
    target.element.style.outline = 'none';


    // reparenting
    hierarchy.on('reparent', function(item, parentOld) {
        var parent = item.parent.entity;
        var entity = item.entity;
        parentOld = parentOld.entity;

        var resourceId = entity.get('resource_id');
        var parentId = parent.get('resource_id');
        var parentIdOld = parentOld.get('resource_id');

        // no need to reparent
        if (entity.reparenting)
            return;

        entity.reparenting = true;

        parent.history.enabled = false;
        parentOld.history.enabled = false;
        entity.history.enabled = false;

        // relative entity
        var indOld = parentOld.get('children').indexOf(entity.get('resource_id'));
        var ind = parent.get('children').indexOf(entity.get('resource_id'));
        var indNew = -1;

        if (item.next && item.next.entity) {
            indNew = parent.get('children').indexOf(item.next.entity.get('resource_id'));

            if (parent === parentOld && ind < indNew)
                indNew--;
        }

        if (parent === parentOld) {
            // move
            parent.move('children', ind, indNew);

        } else {
            // reparenting

            // remove from old parent
            parentOld.remove('children', indOld);

            // add to new parent children
            if (indNew !== -1) {
                // before other item
                parent.insert('children', entity.get('resource_id'), indNew);
            } else {
                // at the end
                parent.insert('children', entity.get('resource_id'));
            }

            // set parent
            entity.set('parent', parent.get('resource_id'));
        }

        parent.history.enabled = true;
        parentOld.history.enabled = true;
        entity.history.enabled = true;

        editor.call('history:add', {
            name: 'reparent entity ' + resourceId,
            undo: function() {
                var parentOld = editor.call('entities:get', parentIdOld);
                var parent = editor.call('entities:get', parentId);
                var entity = editor.call('entities:get', resourceId);
                if (! parentOld || ! parent || ! entity)
                    return;

                parent.history.enabled = false;
                parent.removeValue('children', resourceId);
                parent.history.enabled = true;

                parentOld.history.enabled = false;
                parentOld.insert('children', resourceId, indOld === -1 ? undefined : indOld);
                parentOld.history.enabled = true;

                entity.history.enabled = false;
                entity.set('parent', parentIdOld);
                entity.history.enabled = true;
            },
            redo: function() {
                var parentOld = editor.call('entities:get', parentIdOld);
                var parent = editor.call('entities:get', parentId);
                var entity = editor.call('entities:get', resourceId);
                if (! parentOld || ! parent || ! entity)
                    return;

                parentOld.history.enabled = false;
                parentOld.removeValue('children', resourceId);
                parentOld.history.enabled = true;

                parent.history.enabled = false;
                parent.insert('children', resourceId, indNew === -1 ? undefined : indNew);
                parent.history.enabled = true;

                entity.history.enabled = false;
                entity.set('parent', parentId);
                entity.history.enabled = true;
            }
        });

        entity.reparenting = false;
        resizeTree();
    });


    // selector add
    editor.on('selector:add', function(entity, type) {
        if (type !== 'entity')
            return;

        uiItemIndex[entity.get('resource_id')].selected = true;
    });
    // selector remove
    editor.on('selector:remove', function(entity, type) {
        if (type !== 'entity')
            return;

        uiItemIndex[entity.get('resource_id')].selected = false;
    });
    // selector change
    editor.on('selector:change', function(type, items) {
        if (type !== 'entity') {
            hierarchy.clear();
        } else {
            var selected = hierarchy.selected;
            var ids = { };

            // build index of selected items
            for(var i = 0; i < items.length; i++) {
                ids[items[i].get('resource_id')] = true;
            };

            // deselect unselected items
            for(var i = 0; i < selected.length; i++) {
                if (! ids[selected[i].entity.get('resource_id')])
                    selected[i].selected = false;
            }
        }
    });


    // entity removed
    editor.on('entities:remove', function(entity) {
        uiItemIndex[entity.get('resource_id')].destroy();
        resizeTree();
    });


    var componentList;


    // entity added
    editor.on('entities:add', function(entity) {
        var element = new ui.TreeItem({
            text: entity.get('name')
        });

        element.entity = entity;
        element.enabled = entity.get('enabled');

        if (! componentList)
            componentList = editor.call('components:list');

        // icon
        var components = Object.keys(entity.get('components'));
        for(var i = 0; i < components.length; i++) {
            element.class.add('c-' + components[i]);
        }
        var watchComponent = function(component) {
            entity.on('components.' + component + ':set', function() {
                element.class.add('c-' + component);
            });
            entity.on('components.' + component + ':unset', function() {
                element.class.remove('c-' + component);
            });
        };
        for(var i = 0; i < componentList.length; i++) {
            watchComponent(componentList[i]);
        }

        entity.reparenting = false;

        // index
        uiItemIndex[entity.get('resource_id')] = element;

        // name change
        entity.on('name:set', function(value) {
            element.text = value;
            resizeTree();
        });

        entity.on('enabled:set', function(value) {
            element.enabled = value;
        });

        entity.on('children:move', function(value, ind, indOld) {
            var item = uiItemIndex[value];
            if (! item || item.entity.reparenting)
                return;

            element.remove(item);

            var next = uiItemIndex[entity.get('children.' + (ind + 1))];
            var after = null;
            if (next === item) {
                next = null;

                if (ind > 0)
                    after = uiItemIndex[entity.get('children.' + ind)]
            }

            if (item.parent)
                item.parent.remove(item);

            if (next) {
                element.appendBefore(item, next);
            } else if (after) {
                element.appendAfter(item, after);
            } else {
                element.append(item);
            }
        });

        // remove children
        entity.on('children:remove', function(value) {
            var item = uiItemIndex[value];
            if (! item || item.entity.reparenting)
                return;

            element.remove(item);
        });

        // add children
        entity.on('children:insert', function(value, ind) {
            var item = uiItemIndex[value];

            if (! item || item.entity.reparenting)
                return;

            if (item.parent)
                item.parent.remove(item);

            var next = uiItemIndex[entity.get('children.' + (ind + 1))];
            if (next) {
                element.appendBefore(item, next);
            } else {
                element.append(item);
            }
        });

        resizeTree();
    });


    // append all treeItems according to child order
    editor.on('entities:load', function() {
        var entities = editor.call('entities:list');

        for(var i = 0; i < entities.length; i++) {
            var entity = entities[i];
            var element = uiItemIndex[entity.get('resource_id')];

            if (! entity.get('parent')) {
                // root
                hierarchy.append(element);
                element.open = true;
            }

            var children = entity.get('children');
            if (children.length) {
                for(var c = 0; c < children.length; c++) {
                    var child = uiItemIndex[children[c]];
                    element.append(child);
                }
            }
        }
    });


    // deleting entity
    editor.on('entity:delete', function(entity) {
        editor.call('entities:remove', entity);
    });

    // get entity item
    editor.method('entities:panel:get', function (resourceId) {
        return uiItemIndex[resourceId];
    });

    // highlight entity
    editor.method('entities:panel:highlight', function (resourceId, highlight) {
        var item = uiItemIndex[resourceId];
        if (!item) return;

        if (highlight)
            item.class.add('highlight');
        else
            item.class.remove('highlight');
    });

});


/* editor/entities/entities-menu.js */
editor.once('load', function() {
    'use strict';

    var componentsLogos = {
        'animation': '&#57875;',
        'audiolistener': '&#57750;',
        'audiosource': '&#57751;',
        'camera': '&#57874;',
        'collision': '&#57735;',
        'directional': '&#57746;',
        'point': '&#57745;',
        'spot': '&#57747;',
        'model': '&#57736;',
        'particlesystem': '&#57753;',
        'rigidbody': '&#57737;',
        'script': '&#57910;'
    };

    editor.method('menu:entities:new', function (getParentFn) {
        if (! getParentFn)
            getParentFn = function () {return editor.call('entities:selectedFirst');};

        return {
            'add-new-entity': {
                title: 'Entity',
                icon: '&#57632;',
                select: function() {
                    editor.call('entities:new', {parent: getParentFn()});
                }
            },
            'add-new-listener': {
                title: 'Audio Listener',
                icon: componentsLogos.audiolistener,
                select: function() {
                    editor.call('entities:new', {
                        name: 'Audio Listener',
                        parent: getParentFn(),
                        components: {
                            audiolistener: editor.call('components:getDefault', 'audiolistener')
                        }
                    });
                }
            },
            'add-new-audiosource': {
                title: 'Audio Source',
                icon: componentsLogos.audiosource,
                select: function() {
                    editor.call('entities:new', {
                        name: 'Audio Source',
                        parent: getParentFn(),
                        components: {
                            audiosource: editor.call('components:getDefault', 'audiosource')
                        }
                    });
                }
            },
            'add-new-camera': {
                title: 'Camera',
                icon: componentsLogos.camera,
                select: function() {
                    editor.call('entities:new', {
                        name: 'Camera',
                        parent: getParentFn(),
                        components: {
                            camera: editor.call('components:getDefault', 'camera')
                        }
                    });
                }
            },
            'add-new-box': {
                title: 'Box',
                icon: componentsLogos.model,
                select: function() {
                    var component = editor.call('components:getDefault', 'model');
                    component.type = 'box';

                    editor.call('entities:new', {
                        name: 'Box',
                        parent: getParentFn(),
                        components: {
                            model: component
                        }
                    });
                }
            },
            'add-new-capsule': {
                title: 'Capsule',
                icon: componentsLogos.model,
                select: function() {
                    var component = editor.call('components:getDefault', 'model');
                    component.type = 'capsule';

                    editor.call('entities:new', {
                        name: 'Capsule',
                        parent: getParentFn(),
                        components: {
                            model: component
                        }
                    });
                }
            },
            'add-new-cone': {
                title: 'Cone',
                icon: componentsLogos.model,
                select: function() {
                    var component = editor.call('components:getDefault', 'model');
                    component.type = 'cone';

                    editor.call('entities:new', {
                        name: 'Cone',
                        parent: getParentFn(),
                        components: {
                            model: component
                        }
                    });
                }
            },
            'add-new-cylinder': {
                title: 'Cylinder',
                icon: componentsLogos.model,
                select: function() {
                    var component = editor.call('components:getDefault', 'model');
                    component.type = 'cylinder';

                    editor.call('entities:new', {
                        name: 'Cylinder',
                        parent: getParentFn(),
                        components: {
                            model: component
                        }
                    });
                }
            },
            'add-new-model': {
                title: 'Model',
                icon: componentsLogos.model,
                select: function() {
                    var component = editor.call('components:getDefault', 'model');
                    component.type = 'asset';

                    editor.call('entities:new', {
                        name: 'Model',
                        parent: getParentFn(),
                        components: {
                            model: component
                        }
                    });
                }
            },
            'add-new-plane': {
                title: 'Plane',
                icon: componentsLogos.model,
                select: function() {
                    var component = editor.call('components:getDefault', 'model');
                    component.type = 'plane';

                    editor.call('entities:new', {
                        name: 'Plane',
                        parent: getParentFn(),
                        components: {
                            model: component
                        }
                    });
                }
            },
            'add-new-sphere': {
                title: 'Sphere',
                icon: componentsLogos.model,
                select: function() {
                    var component = editor.call('components:getDefault', 'model');
                    component.type = 'sphere';

                    editor.call('entities:new', {
                        name: 'Sphere',
                        parent: getParentFn(),
                        components: {
                            model: component
                        }
                    });
                }
            },
            'add-new-directional': {
                title: 'Directional Light',
                icon: componentsLogos.directional,
                select: function() {
                    var component = editor.call('components:getDefault', 'light');
                    component.type = 'directional';

                    editor.call('entities:new', {
                        name: 'Directional Light',
                        parent: getParentFn(),
                        components: {
                            light: component
                        }
                    });
                }
            },
            'add-new-point': {
                title: 'Point Light',
                icon: componentsLogos.point,
                select: function() {
                    var component = editor.call('components:getDefault', 'light');
                    component.type = 'point';
                    component.shadowResolution = 256;

                    editor.call('entities:new', {
                        name: 'Point Light',
                        parent: getParentFn(),
                        components: {
                            light: component
                        }
                    });
                }
            },
            'add-new-spot': {
                title: 'Spot Light',
                icon: componentsLogos.spot,
                select: function() {
                    var component = editor.call('components:getDefault', 'light');
                    component.type = 'spot';

                    editor.call('entities:new', {
                        name: 'Spot Light',
                        parent: getParentFn(),
                        components: {
                            light: component
                        }
                    });
                }
            },
            'add-new-particles': {
                title: 'Particle System',
                icon: componentsLogos.particlesystem,
                select: function() {
                    editor.call('entities:new', {
                        name: 'Particle System',
                        parent: getParentFn(),
                        components: {
                            particlesystem: editor.call('components:getDefault', 'particlesystem')
                        }
                    });
                }
            }
        };
    });
});

/* editor/entities/entities-control.js */
editor.once('load', function() {
    'use strict'

    var root = editor.call('layout.root');
    var panel = editor.call('layout.left');

    // controls
    var controls = new ui.Panel();
    controls.class.add('hierarchy-controls');
    controls.parent = panel;
    panel.headerAppend(controls);
    // panel.element.appendChild(controls.element);


    // controls delete
    var btnDelete = new ui.Button({
        text: '&#57636;'
    });
    btnDelete.class.add('delete');
    btnDelete.style.fontWeight = 200;
    btnDelete.on('click', function() {
        var type = editor.call('selector:type');

        if (type !== 'entity')
            return;

        editor.call('entities:delete', editor.call('selector:items'));
    });
    controls.append(btnDelete);

    var tooltipDelete = Tooltip.attach({
        target: btnDelete.element,
        text: 'Delete Entity',
        align: 'top',
        root: root
    });
    tooltipDelete.class.add('innactive');


    // controls duplicate
    var btnDuplicate = new ui.Button({
        text: '&#57638;'
    });
    btnDuplicate.disabled = true;
    btnDuplicate.class.add('duplicate');
    btnDuplicate.on('click', function() {
        var type = editor.call('selector:type');
        var items = editor.call('selector:items');

        if (type === 'entity' && items.length)
            editor.call('entities:duplicate', items[0]);
    });
    controls.append(btnDuplicate);

    var tooltipDuplicate = Tooltip.attach({
        target: btnDuplicate.element,
        text: 'Duplicate Entity',
        align: 'top',
        root: root
    });
    tooltipDuplicate.class.add('innactive');

    var menuEntities = ui.Menu.fromData(editor.call('menu:entities:new'));
    root.append(menuEntities);

    // controls add
    var btnAdd = new ui.Button({
        text: '&#57632;'
    });
    btnAdd.class.add('add');
    btnAdd.on('click', function() {
        menuEntities.open = true;
        var rect = btnAdd.element.getBoundingClientRect();
        menuEntities.position(rect.left, rect.top);
    });
    controls.append(btnAdd);

    Tooltip.attach({
        target: btnAdd.element,
        text: 'Add Entity',
        align: 'top',
        root: root
    });


    editor.on('attributes:clear', function() {
        btnDuplicate.disabled = true;
        btnDelete.disabled = true;
        tooltipDelete.class.add('innactive');
        tooltipDuplicate.class.add('innactive');
    });

    editor.on('attributes:inspect[*]', function(type, items) {
        var root = editor.call('entities:root');

        if (type === 'entity' && items[0] !== root) {
            btnDelete.enabled = true;
            btnDuplicate.enabled = true;
            tooltipDelete.class.remove('innactive');
            tooltipDuplicate.class.remove('innactive');
        } else {
            btnDelete.enabled = false;
            btnDuplicate.enabled = false;
            tooltipDelete.class.add('innactive');
            tooltipDuplicate.class.add('innactive');
        }
    });
});


/* editor/entities/entities-load.js */
editor.on('load', function() {
    var hierarchyOverlay = new ui.Panel();
    hierarchyOverlay.class.add('overlay');
    editor.call('layout.left').append(hierarchyOverlay);

    var p = new ui.Progress();
    p.on('progress:100', function() {
        hierarchyOverlay.hidden = true;
    });
    hierarchyOverlay.append(p);
    p.hidden = true;

    var loadedEntities = false;

    editor.on('scene:raw', function(data) {
        // check if we're reloading the scene
        if (loadedEntities) {
            editor.call('selector:clear');
            editor.call('entities:clear');
        }

        var start = Date.now();

        var total = Object.keys(data.entities).length;
        var i = 0;

        // list
        for(var key in data.entities) {
            editor.call('entities:add', new Observer(data.entities[key]));

            p.progress = (++i / total) * .8 + .1;
        }

        p.progress = 1;

        loadedEntities = true;
        editor.emit('entities:load');
    });


    editor.call('attributes:clear');

    editor.on('scene:unload', function () {
        editor.call('entities:clear');
        editor.call('attributes:clear');
    });

    editor.on('scene:beforeload', function () {
        hierarchyOverlay.hidden = false;
        p.hidden = false;
        p.progress = .1;
    });

});


/* editor/entities/entities-history.js */
editor.once('load', function() {
    'use strict';

    editor.on('entities:add', function(entity) {
        if (entity.history)
            return;

        var resourceId = entity.get('resource_id');

        entity.history = new ObserverHistory({
            item: entity,
            prefix: 'entity.' + resourceId + '.',
            getItemFn: function () {
                return editor.call('entities:get', resourceId);
            }
        });

        // record history
        entity.history.on('record', function(action, data) {
            editor.call('history:' + action, data);
        });
    });
});


/* editor/entities/entities-sync.js */
editor.once('load', function() {
    'use strict';


    var syncPaths = [
        'name',
        'parent',
        'children',
        'position',
        'rotation',
        'scale',
        'enabled',
        'components'
    ];



    editor.on('entities:add', function(entity) {
        if (entity.sync)
            return;

        entity.sync = new ObserverSync({
            item: entity,
            prefix: [ 'entities', entity.get('resource_id') ],
            paths: syncPaths
        });

        // client > server
        entity.sync.on('op', function(op) {
            editor.call('realtime:scene:op', op);
        });
    });


    // server > client
    editor.on('realtime:scene:op:entities', function(op) {
        var entity = null;
        if (op.p[1])
            entity = editor.call('entities:get', op.p[1]);

        if (op.p.length === 2) {
            if (op.hasOwnProperty('od')) {
                // delete entity
                if (entity) {
                    editor.call('entities:remove', entity);
                } else {
                    console.log('delete operation entity not found', op);
                }
            } else if (op.hasOwnProperty('oi')) {
                // new entity
                editor.call('entities:add', new Observer(op.oi));
            } else {
                console.log('unknown operation', op);
            }
        } else if (entity) {
            // write operation
            entity.sync.write(op);
        } else {
            console.log('unknown operation', op);
        }
    });
});


/* editor/entities/entities-hotkeys.js */
editor.once('load', function() {
    'use strict';

    // new
    editor.call('hotkey:register', 'entity:new', {
        key: 'n',
        ctrl: true,
        callback: function() {
            if (! editor.call('permissions:write'))
                return;

            var type = editor.call('selector:type');
            var items = editor.call('selector:items');

            if (type === 'entity') {
                if (items.length !== 1)
                    return;

                editor.call('entities:new', {
                    parent: items[0]
                });
            } else {
                editor.call('entities:new');
            }
        }
    });


    // duplicate
    editor.call('hotkey:register', 'entity:duplicate', {
        key: 'd',
        ctrl: true,
        callback: function() {
            if (! editor.call('permissions:write'))
                return;

            var type = editor.call('selector:type');

            var items = editor.call('selector:items');
            if (items.length !== 1)
                return;

            if (type === 'entity') {
                if (items[0] !== editor.call('entities:root'))
                    editor.call('entities:duplicate', items[0]);
            } else if (type === 'asset') {
                if (items[0].get('type') !== 'material')
                    return;

                editor.call('assets:duplicate', items[0]);
            }
        }
    });

    // delete
    var deleteCallback = function() {
        if (! editor.call('permissions:write'))
            return;

        var type = editor.call('selector:type');
        if (type !== 'entity')
            return;

        var root = editor.call('entities:root');
        var items = editor.call('selector:items');

        if (items.indexOf(root) !== -1)
            return;

        editor.call('entities:delete', items);
    };
    // delete
    editor.call('hotkey:register', 'entity:delete', {
        key: 'delete',
        callback: deleteCallback
    });
    // ctrl + backspace
    editor.call('hotkey:register', 'entity:delete', {
        ctrl: true,
        key: 'backspace',
        callback: deleteCallback
    });

    // copy
    editor.call('hotkey:register', 'entity:copy', {
        key: 'c',
        ctrl: true,
        skipPreventDefault: true,
        callback: function () {
            // write permissions only (perhaps we could also allow read permissions)
            if (! editor.call('permissions:write'))
                return;

            var type = editor.call('selector:type');
            if (type !== 'entity')
                return;

            var items = editor.call('selector:items');
            if (items.length !== 1)
                return;

            editor.call('entities:copy', items[0]);
        }
    });

    // paste
    editor.call('hotkey:register', 'entity:paste', {
        key: 'v',
        ctrl: true,
        callback: function () {
            // write permissions only (perhaps we could also allow read permissions)
            if (! editor.call('permissions:write'))
                return;

            var type = editor.call('selector:type');
            if (type !== 'entity')
                return;

            var items = editor.call('selector:items');
            if (items.length !== 1)
                return;

            editor.call('entities:paste', items[0]);
        }
    });
});


/* editor/entities/entities-context-menu.js */
editor.once('load', function() {
    'use strict';

    var entity = null;
    var items = [ ];
    var root = editor.call('layout.root');

    // create data for entity menu
    var menu;

    var componentsLogos = {
        'animation': '&#57875;',
        'audiolistener': '&#57750;',
        'audiosource': '&#57751;',
        'camera': '&#57874;',
        'collision': '&#57735;',
        'light': '&#57748;',
        'model': '&#57736;',
        'particlesystem': '&#57753;',
        'rigidbody': '&#57737;',
        'script': '&#57910;'
    };


    var getSelection = function() {
        var selection = editor.call('selector:items');

        if (selection.indexOf(entity) !== -1) {
            return selection;
        } else {
            return [ entity ];
        }
    };

    var addComponent = function (entity, component) {
        var componentData = editor.call('components:getDefault', component);
        entity.set('components.' + component, componentData);

        // if it's a collision or rigidbody component then enable physics
        if (component === 'collision' || component === 'rigidbody')
            editor.call('project:enablePhysics');
    };

    var hasScript = function (entity, url) {
        var scriptComponent = entity.get('components.script');
        if (scriptComponent) {
            for (var i = 0; i < scriptComponent.scripts.length; i++) {
                if (scriptComponent.scripts[i].url === url) {
                    return true;
                }
            }
        }

        return false;
    };

    var addBultinScript = function (entity, url) {
        var resourceId = entity.get('resource_id');

        var addedComponent = false;

        var action = {
            name: 'entity.' + resourceId + '.builtinscript',
            combine: false,
            undo: function () {
                var e = editor.call('entities:get', resourceId);
                if (! e) return;

                var history = e.history.enabled;
                e.history.enabled = false;

                if (addedComponent) {
                    e.unset('components.script');
                } else {
                    var scripts = e.get('components.script.scripts');
                    if (scripts) {
                        for (var i = 0; i < scripts.length; i++) {
                            if (scripts[i].url === url) {
                                e.remove('components.script.scripts', i);
                                break;
                            }
                        }
                    }
                }

                e.history.enabled = history;
            },
            redo: function () {
                var e = editor.call('entities:get', resourceId);
                if (! e) return;

                var history = e.history.enabled;
                e.history.enabled = false;

                if (!e.get('components.script')) {
                    addComponent(e, 'script');
                    addedComponent = true;
                }

                // add script
                var script = new Observer({
                    url: url
                });
                e.insert('components.script.scripts', script);

                e.history.enabled = history;

                // scan script
                editor.call('sourcefiles:scan', url, function (data) {
                    e.history.enabled = false;

                    data.url = url;
                    script.patch(data);

                    e.history.enabled = history;
                });
            }
        };

        // perform action
        action.redo();

        // raise history event
        entity.history.emit('record', 'add', action);
    };

    var setField = function(field, value) {
        var records = [ ];

        for(var i = 0; i < items.length; i++) {
            records.push({
                get: items[i].history._getItemFn,
                value: value,
                valueOld: items[i].get(field)
            });

            items[i].history.enabled = false;
            items[i].set(field, value);
            items[i].history.enabled = true;
        }

        editor.call('history:add', {
            name: 'entities.set[' + field + ']',
            undo: function() {
                for(var i = 0; i < records.length; i++) {
                    var item = records[i].get();
                    if (! item)
                        continue;

                    item.history.enabled = false;
                    item.set(field, records[i].valueOld);
                    item.history.enabled = true;
                }
            },
            redo: function() {
                for(var i = 0; i < records.length; i++) {
                    var item = records[i].get();
                    if (! item)
                        continue;

                    item.history.enabled = false;
                    item.set(field, records[i].value);
                    item.history.enabled = true;
                }
            }
        });
    };

    // wait until all entities are loaded
    // before creating the menu to make sure
    // that the menu data for entities have been created
    editor.once('entities:load', function () {
        var menuData = { };

        menuData['new-entity'] = {
            title: 'New Entity',
            filter: function() {
                return items.length === 1;
            },
            select: function () {
                editor.call('entities:new', {parent: items[0]});
            },
            items: editor.call('menu:entities:new', function () {return items[0];})
        };

        menuData['add-component'] = {
            title: 'Add Component',
            filter: function() {
                return items.length === 1;
            },
            items: { }
        };

        menuData['add-builtin-script'] = {
            title: 'Add Built-In Script',
            filter: function () {
                return items.length === 1;
            },
            items: {
                'post-effects': {
                    title: 'Post-Effects',
                    filter: function () {
                        return items.length === 1;
                    },
                    items: { }
                },
                'camera-scripts': {
                    title: 'Camera',
                    filter: function () {
                        return items.length === 1;
                    },
                    items: { }
                }
            }
        };

        menuData['enable'] = {
            title: 'Enable',
            icon: '&#58421;',
            hide: function () {
                if (items.length === 1) {
                    return items[0].get('enabled');
                } else {
                    var enabled = items[0].get('enabled');
                    for(var i = 1; i < items.length; i++) {
                        if (enabled !== items[i].get('enabled'))
                            return false;
                    }
                    return enabled;
                }
            },
            select: function() {
                setField('enabled', true);
            }
        };

        menuData['disable'] = {
            title: 'Disable',
            icon: '&#57650;',
            hide: function () {
                if (items.length === 1) {
                    return ! items[0].get('enabled');
                } else {
                    var disabled = items[0].get('enabled');
                    for(var i = 1; i < items.length; i++) {
                        if (disabled !== items[i].get('enabled'))
                            return false;
                    }
                    return ! disabled;
                }
            },
            select: function() {
                setField('enabled', false);
            }
        };

        menuData['copy'] = {
            title: 'Copy',
            icon: '&#58193;',
            filter: function() {
                return items.length === 1;
            },
            select: function() {
                editor.call('entities:copy', entity);
            }
        };

        menuData['paste'] = {
            title: 'Paste',
            icon: '&#58184;',
            filter: function () {
                return items.length === 1 && ! editor.call('entities:clipboard:empty');
            },
            select: function() {
                editor.call('entities:paste', entity);
            }
        };

        menuData['duplicate'] = {
            title: 'Duplicate',
            icon: '&#57638;',
            filter: function () {
                return items.length === 1 && entity !== editor.call('entities:root');
            },
            select: function() {
                editor.call('entities:duplicate', entity);
            }
        };

        menuData['delete'] = {
            title: 'Delete',
            icon: '&#57636;',
            filter: function () {
                var root = editor.call('entities:root');
                for(var i = 0; i < items.length; i++) {
                    if (items[i] === root)
                        return false;
                }
                return true;
            },
            select: function() {
                editor.call('entities:delete', items);
            }
        };

        var makeMenuComponentItem = function(key) {
            return {
                title: components[key].title,
                icon: componentsLogos[key],
                filter: function() {
                    if (items.length !== 1)
                        return false;

                    return ! items[0].has('components.' + key);
                },
                select: function() {
                    if (items.length !== 1)
                        return false;

                    var entity = items[0];
                    var component = this._value;

                    addComponent(entity, component);
                }
            }
        };

        var components = editor.call('components:schema');
        var list = editor.call('components:list');
        for(var i = 0; i < list.length; i++) {
            var key = list[i];
            menuData['add-component'].items[key] = makeMenuComponentItem(key);
        }

        var builtInScripts = [{
            group: 'post-effects',
            title: 'Bloom',
            name: 'posteffect-bloom',
            url: 'https://code.playcanvas.com/posteffects/posteffect_bloom.js',
            requires: 'camera'
        }, {
            group: 'post-effects',
            title: 'Bloom',
            name: 'posteffect-bloom',
            url: 'https://code.playcanvas.com/posteffects/posteffect_bloom.js',
            requires: 'camera'
        }, {
            group: 'post-effects',
            title: 'Bloom',
            name: 'posteffect-bloom',
            url: 'https://code.playcanvas.com/posteffects/posteffect_bloom.js',
            requires: 'camera'
        }, {
            group: 'post-effects',
            title: 'Brightness-Contrast',
            name: 'posteffect-brightnesscontrast',
            url: 'https://code.playcanvas.com/posteffects/posteffect_brightnesscontrast.js',
            requires: 'camera'
        }, {
            group: 'post-effects',
            title: 'Hue-Saturation',
            name: 'posteffect-huesaturation',
            url: 'https://code.playcanvas.com/posteffects/posteffect_huesaturation.js',
            requires: 'camera'
        }, {
            group: 'post-effects',
            title: 'FXAA',
            name: 'posteffect-fxaa',
            url: 'https://code.playcanvas.com/posteffects/posteffect_fxaa.js',
            requires: 'camera'
        }, {
            group: 'post-effects',
            title: 'Sepia',
            name: 'posteffect-sepia',
            url: 'https://code.playcanvas.com/posteffects/posteffect_sepia.js',
            requires: 'camera'
        }, {
            group: 'post-effects',
            title: 'Vignette',
            name: 'posteffect-vignette',
            url: 'https://code.playcanvas.com/posteffects/posteffect_vignette.js',
            requires: 'camera'
        }, {
            group: 'camera-scripts',
            title: 'Fly Camera',
            name: 'camera-fly',
            url: 'https://code.playcanvas.com/camera/camera_fly.js',
            requires: 'camera'
        }];

        builtInScripts.forEach(function (data) {
            menuData['add-builtin-script'].items[data.group].items[data.name] = {
                title: data.title,
                filter: function () {
                    return items.length === 1 &&
                           editor.call('permissions:write') &&
                           !hasScript(items[0], data.url) &&
                           (!data.requires || items[0].get('components.' + data.requires));
                },
                select: function () {
                    addBultinScript(items[0], data.url);
                }
            };
        });

        // menu
        menu = ui.Menu.fromData(menuData);
        root.append(menu);
    });

    // for each entity added
    editor.on('entities:add', function(item) {
        // get tree item
        var treeItem = editor.call('entities:panel:get', item.get('resource_id'));
        if (! treeItem) return;

        // attach contextmenu event
        treeItem.element.addEventListener('contextmenu', function(evt) {
            if (! menu || ! editor.call('permissions:write')) return;

            entity = item;
            items = getSelection();

            menu.open = true;
            menu.position(evt.clientX + 1, evt.clientY);

            evt.preventDefault();
            evt.stopPropagation();
        });
    });
});


/* editor/entities/entities-pick.js */
editor.once('load', function() {
    'use strict';

    editor.on('viewport:pick:clear', function() {
        if (! editor.call('hotkey:ctrl'))
            editor.call('selector:clear');
    });

    editor.on('viewport:pick:node', function(node, picked) {
        // icon
        if (node._icon) {
            node = node._getEntity();
            if (! node) return;
        }

        // get entity
        var entity = editor.call('entities:get', node.getGuid());
        if (! entity) return;

        // get selector data
        var type = editor.call('selector:type');
        var items = editor.call('selector:items');

        if (type === 'entity' && items.length === 1 && items.indexOf(entity) !== -1 && ! editor.call('hotkey:ctrl')) {
            // if entity already selected
            // try selecting model asset
            // with highlighting mesh instance
            if (node.model && node.model.type === 'asset' && node.model.model) {
                var meshInstances = node.model.model.meshInstances;

                for(var i = 0; i < meshInstances.length; i++) {
                    var instance = meshInstances[i];
                    if (instance !== picked)
                        continue;

                    var index = i;

                    // if the model component has a material mapping then
                    // open the model component otherwise go to the model asset
                    if (node.model.mapping && node.model.mapping[i] !== undefined) {
                        editor.call('selector:set', 'entity', [entity]);
                    } else {
                        // get model asset
                        var asset = editor.call('assets:get', node.model.asset);
                        if (! asset) break;

                        // select model asset
                        editor.call('selector:set', 'asset', [ asset ]);
                    }

                    // highlight selected node
                    setTimeout(function() {
                        var node = editor.call('attributes.rootPanel').element.querySelector('.field-asset.node-' + index);
                        if (node) {
                            node.classList.add('active');
                            var field = node.querySelector('.ui-image-field');
                            field.focus();
                            field.blur();
                        }
                    }, 0);

                    break;
                }
            }
        } else {
            // select entity
            if (type === 'entity' && editor.call('hotkey:ctrl')) {
                // with ctrl
                if (items.indexOf(entity) !== -1) {
                    // deselect
                    editor.call('selector:remove', entity);
                } else {
                    // add to selection
                    editor.call('selector:add', 'entity', entity);
                }
            } else {
                // set selection
                editor.call('selector:set', 'entity', [ entity ]);
            }
        }
    })
});


/* editor/entities/entities-icons.js */
editor.once('load', function() {
    'use strict';

    var app;
    var iconsEntity;
    var textureNames = [ 'animation', 'audiolistener', 'audiosource', 'camera', 'collision', 'light-point', 'light-directional', 'light-spot', 'particlesystem', 'rigidbody', 'script', 'unknown' ];
    var components = [ 'camera', 'light', 'audiolistener', 'audiosource', 'particlesystem', 'script', 'animation', 'collision', 'rigidbody', 'model' ];
    var icons = [ ];
    var pool = [ ];
    var dirtifyKeys = [
        'enabled:set',
        'components.model.type:set',
        'components.model.asset:set',
    ];
    var dirtifyLocalKeys = {
        'light': [
            'components.light.color.0:set',
            'components.light.color.1:set',
            'components.light.color.2:set',
            'components.light.type:set'
        ]
    };
    var material = null;
    var materialBehind = null;
    var iconColor = new pc.Color(1, 1, 1, 1);
    var textures = { };
    var scale = .5;
    var cameraRotation = new pc.Quat();
    var rotateMatrix = new pc.Mat4().setFromAxisAngle(pc.Vec3.LEFT, -90);
    var quadMaterial = new pc.Material();
    var selectedIds = { };


    // icon class
    function Icon() {
        var self = this;
        this.entity = new pc.Entity(app);
        this.entity._icon = true;
        this.entity._getEntity = function() {
            return self._link && self._link.entity || null;
        };
        this.entity.addComponent('model', {
            type: 'plane'
        });

        this.behind = new pc.Entity(app);
        this.behind._icon = true;
        this.behind._getEntity = this.entity._getEntity;
        this.entity.addChild(this.behind);
        this.behind.addComponent('model', {
            type: 'plane'
        });
        this.behind.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        this.behind.model.model.meshInstances[0].pick = false;

        this.color = new pc.Color();

        this._link = null;
        this.events = [ ];
        this.eventsLocal = [ ];
        this.local = '';
        this.dirty = true;
        this.dirtify = function() {
            self.dirty = true;
        };
    }
    Icon.prototype.update = function() {
        if (! this._link || ! this._link.entity)
            return;

        // don't render if selected or disabled
        if (selectedIds[this._link.get('resource_id')] || ! this._link.entity.enabled || scale === 0) {
            this.entity.enabled = false;
            this.dirty = true;
            return;
        }

        // position
        this.entity.setPosition(this._link.entity.getPosition());
        this.entity.setLocalScale(scale, scale, scale);
        this.entity.setRotation(cameraRotation);
        this.entity.rotateLocal(90, 0, 0);


        if (! this.dirty) return;
        this.dirty = false;

        // hide icon if model is set
        if (this._link.has('components.model') && this._link.get('components.model.enabled') && (this._link.get('components.model.type') !== 'asset' || this._link.get('components.model.asset'))) {
            this.entity.enabled = false;
            return;
        }

        var component = '';
        for(var i = 0; i < components.length; i++) {
            if (! this._link.has('components.' + components[i]))
                continue;

            component = components[i];
            break;
        }

        if (component) {
            this.entity.enabled = true;
            this.entity.model.material = material;
            this.behind.model.material = materialBehind;

            this.color.copy(iconColor);
            var textureName = components[i];
            if (components[i] === 'light') {
                textureName += '-' + this._link.entity.light.type;
                this.color.copy(this._link.entity.light.color);
            }

            if (! textureName || ! textures[textureName])
                textureName = 'unknown';

            this.entity.model.model.meshInstances[0].setParameter('texture_diffuseMap', textures[textureName]);
            this.entity.model.model.meshInstances[0].setParameter('uColor', this.color.data);

            this.color.a = 0.25;
            this.behind.model.model.meshInstances[0].setParameter('texture_diffuseMap', textures[textureName]);
            this.behind.model.model.meshInstances[0].setParameter('uColor', this.color.data);

            if (this.local !== components[i]) {
                // clear local binds
                for(var n = 0; n < this.eventsLocal.length; n++)
                    this.eventsLocal[n].unbind();
                this.eventsLocal = [ ];

                // add local binds
                if (dirtifyLocalKeys[components[i]]) {
                    for(var n = 0; n < dirtifyLocalKeys[components[i]].length; n++)
                        this.eventsLocal.push(this._link.on(dirtifyLocalKeys[components[i]][n], this.dirtify));
                }
            }
        } else {
            this.entity.enabled = false;
        }
    };
    Icon.prototype.link = function(obj) {
        this.unlink();

        this._link = obj;
        for(var i = 0; i < dirtifyKeys.length; i++)
            this.events.push(obj.on(dirtifyKeys[i], this.dirtify));

        for(var i = 0; i < components.length; i++) {
            this.events.push(obj.on('components.' + components[i] + ':set', this.dirtify));
            this.events.push(obj.on('components.' + components[i] + ':unset', this.dirtify));
        }

        var self = this;
        this.events.push(obj.once('destroy', function() {
            self.unlink();
        }));

        icons.push(this);
        iconsEntity.addChild(this.entity);
        this.dirty = true;
    };
    Icon.prototype.unlink = function() {
        if (! this._link)
            return;

        for(var i = 0; i < this.events.length; i++)
            this.events[i].unbind();

        this.entity.enabled = false;
        this.events = [ ];
        this._link = null;

        var ind = icons.indexOf(this);
        icons.splice(ind, 1);
        pool.push(this);

        iconsEntity.removeChild(this.entity);
    };

    editor.once('viewport:load', function() {
        app = editor.call('viewport:framework');

        material = new pc.BasicMaterial();
        material.updateShader = function(device) {
            this.shader = new pc.Shader(device, {
                attributes: {
                    vertex_position: 'POSITION'
                },
                vshader: ' \
                    attribute vec3 vertex_position;\n \
                    uniform mat4 matrix_model;\n \
                    uniform mat4 matrix_viewProjection;\n \
                    varying vec2 vUv0;\n \
                    void main(void)\n \
                    {\n \
                        mat4 modelMatrix = matrix_model;\n \
                        vec4 positionW = modelMatrix * vec4(vertex_position, 1.0);\n \
                        gl_Position = matrix_viewProjection * positionW;\n \
                        vUv0 = vertex_position.xz + vec2(0.5);\n \
                        vUv0.y = 1.0 - vUv0.y;\n \
                    }\n',
                fshader: ' \
                    precision highp float;\n \
                    uniform vec4 uColor;\n \
                    varying vec2 vUv0;\n \
                    uniform sampler2D texture_diffuseMap;\n \
                    void main(void)\n \
                    {\n \
                        float alpha = texture2D(texture_diffuseMap, vUv0).b;\n \
                        if (alpha < 0.5) discard;\n \
                        gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\n \
                    }\n',
            });
        };
        material.update();

        materialBehind = new pc.BasicMaterial();
        materialBehind.blend = true;
        materialBehind.blendSrc = pc.BLENDMODE_SRC_ALPHA;
        materialBehind.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
        materialBehind.updateShader = material.updateShader;
        materialBehind.update();

        iconsEntity = new pc.Entity(app);
        app.root.addChild(iconsEntity);

        for(var i = 0; i < textureNames.length; i++) {
            textures[textureNames[i]] = new pc.Texture(app.graphicsDevice, {
                width: 64,
                height: 64
            });
            textures[textureNames[i]].anisotropy = 16;
            textures[textureNames[i]].addressU = pc.ADDRESS_CLAMP_TO_EDGE;
            textures[textureNames[i]].addressV = pc.ADDRESS_CLAMP_TO_EDGE;

            var img = new Image();
            img.textureName = textureNames[i];
            img.onload = function() {
                textures[this.textureName].setSource(this);
            };
            img.src = '/editor/scene/img/entity-icons/' + textureNames[i] + '.png';
        }

        editor.on('entities:add', function(obj) {
            var icon = pool.shift();
            if (! icon)
                icon = new Icon();

            icon.link(obj);
        });
    });

    editor.on('selector:change', function(type, items) {
        selectedIds = { };

        if (type !== 'entity')
            return;

        for(var i = 0; i < items.length; i++)
            selectedIds[items[i].get('resource_id')] = true;
    });

    editor.on('viewport:postUpdate', function() {
        if (app) cameraRotation.copy(app.activeCamera.getRotation());

        for(var i = 0; i < icons.length; i++)
            icons[i].update();
    });

    editor.method('viewport:icons:size', function(size) {
        if (size === undefined)
            return scale;

        scale = size;
        editor.call('viewport:render');
    });

    var designerSettings = editor.call('designerSettings');
    editor.call('viewport:icons:size', designerSettings.get('icons_size'));
    designerSettings.on('icons_size:set', function(size) {
        editor.call('viewport:icons:size', size);
    });
});


/* editor/entities/entities-gizmo-translate.js */
editor.once('load', function() {
    'use strict';

    var events = [ ];
    var items = [ ];
    var quat = new pc.Quat();
    var vecA = new pc.Vec3();
    var vecB = new pc.Vec3();
    var vecC = new pc.Vec3();
    var startPosition = new pc.Vec3();
    var timeoutUpdatePosition, timeoutUpdateRotation;
    var coordSystem = 'world';
    var app;
    var gizmoMoving = false;
    var gizmoAxis, gizmoPlane;
    var movingStart = new pc.Vec3();
    var linesColorActive = new pc.Color(1, 1, 1, 1);
    var linesColor = new pc.Color(1, 1, 1, .2);
    var linesColorBehind = new pc.Color(1, 1, 1, .05);

    editor.on('gizmo:coordSystem', function(system) {
        if (coordSystem === system)
            return;

        coordSystem = system;

        var pos = getGizmoPosition();
        if (pos)
            editor.call('gizmo:translate:position', pos.x, pos.y, pos.z);

        var rot = getGizmoRotation();
        if (rot)
            editor.call('gizmo:translate:rotation', rot[0], rot[1], rot[2]);

        editor.call('viewport:render');
    });

    // get position of gizmo based on selected entities
    var getGizmoPosition = function() {
        if (! items.length)
            return;

        if (items.length === 1) {
            vecA.copy(items[0].obj.entity.getPosition());
        } else if (coordSystem === 'local') {
            var reference = items[items.length - 1];
            var parent = reference.parent;
            while(parent) {
                reference = parent;
                parent = parent.parent;
            }
            vecA.copy(reference.obj.entity.getPosition());
        } else {
            var selection = editor.call('selection:aabb');
            if (! selection) return;
            vecA.copy(selection.center);
        }

        return vecA;
    };

    var getGizmoRotation = function() {
        if (! items.length)
            return;

        if (coordSystem === 'local') {
            var reference = items[items.length - 1];
            var parent = reference.parent;
            while(parent) {
                reference = parent;
                parent = parent.parent;
            }
            var rot = reference.obj.entity.getEulerAngles()
            return [ rot.x, rot.y, rot.z ];
        } else {
            return [ 0, 0, 0 ];
        }
    };

    // update gizmo position
    var updateGizmoPosition = function() {
        if (! items.length || timeoutUpdatePosition || gizmoMoving)
            return;

        timeoutUpdatePosition = true;

        setTimeout(function() {
            timeoutUpdatePosition = false;

            var vec = getGizmoPosition();
            if (vec)
                editor.call('gizmo:translate:position', vec.x, vec.y, vec.z);
        });
    };

    // update gizmo position
    var updateGizmoRotation = function() {
        if (! items.length || timeoutUpdateRotation)
            return;

        timeoutUpdateRotation = true;

        setTimeout(function() {
            timeoutUpdateRotation = false;

            var vec = getGizmoRotation();
            if (vec)
                editor.call('gizmo:translate:rotation', vec[0], vec[1], vec[2]);
        });
    };

    // start translating
    var onGizmoStart = function(axis, plane) {
        gizmoAxis = axis;
        gizmoPlane = plane;
        gizmoMoving = true;

        movingStart.copy(getGizmoPosition());

        for(var i = 0; i < items.length; i++) {
            var pos = items[i].obj.entity.getPosition();
            items[i].start[0] = pos.x;
            items[i].start[1] = pos.y;
            items[i].start[2] = pos.z;
            items[i].pos = items[i].start.slice(0);

            pos = items[i].obj.get('position');
            items[i].startLocal[0] = pos[0];
            items[i].startLocal[1] = pos[1];
            items[i].startLocal[2] = pos[2];

            items[i].obj.history.enabled = false;
        }
    };

    // end translating
    var onGizmoEnd = function() {
        gizmoMoving = false;
        var records = [ ];

        for(var i = 0; i < items.length; i++) {
            items[i].obj.history.enabled = true;

            records.push({
                get: items[i].obj.history._getItemFn,
                valueOld: items[i].startLocal.slice(0),
                value: items[i].obj.get('position')
            });
        }

        editor.call('history:add', {
            name: 'entities.translate',
            undo: function() {
                for(var i = 0; i < records.length; i++) {
                    var item = records[i].get();
                    if (! item)
                        continue;

                    item.history.enabled = false;
                    item.set('position', records[i].valueOld);
                    item.history.enabled = true;
                }
            },
            redo: function() {
                for(var i = 0; i < records.length; i++) {
                    var item = records[i].get();
                    if (! item)
                        continue;

                    item.history.enabled = false;
                    item.set('position', records[i].value);
                    item.history.enabled = true;
                }
            }
        });
    };

    // translated
    var onGizmoOffset = function(x, y, z) {
        timeoutUpdateRotation = true;

        for(var i = 0; i < items.length; i++) {
            if (items[i].child)
                continue;

            var entity = items[i].obj.entity;

            if (coordSystem === 'local') {
                vecA.set(x, y, z);
                quat.copy(entity.getLocalRotation()).transformVector(vecA, vecA);
                entity.setLocalPosition(items[i].startLocal[0] + vecA.x, items[i].startLocal[1] + vecA.y, items[i].startLocal[2] + vecA.z);
            } else {
                entity.setPosition(items[i].start[0] + x, items[i].start[1] + y, items[i].start[2] + z);
            }

            // if (entity.collision) {
            //     app.systems.collision.onTransformChanged(entity.collision, entity.getPosition(), entity.getRotation(), entity.getLocalScale());
            // }

            var pos = entity.getLocalPosition();
            items[i].obj.set('position', [ pos.x, pos.y, pos.z ]);
        }

        timeoutUpdateRotation = false;

        var pos = getGizmoPosition();
        editor.call('gizmo:translate:position', pos.x, pos.y, pos.z);
    };

    var onRender = function() {
        if (! gizmoMoving && items.length) {
            var dirty = false;
            for(var i = 0; i < items.length; i++) {
                if (! items[i].obj.entity)
                    continue;

                var pos = items[i].obj.entity.getPosition();
                if (pos.x !== items[i].pos[0] || pos.y !== items[i].pos[1] || pos.z !== items[i].pos[2]) {
                    dirty = true;
                    items[i].pos[0] = pos.x;
                    items[i].pos[1] = pos.y;
                    items[i].pos[2] = pos.z;
                }
            }

            if (dirty) {
                var pos = getGizmoPosition();
                editor.call('gizmo:translate:position', pos.x, pos.y, pos.z);
            }
        }

        if (gizmoMoving && items.length) {
            var camera = app.activeCamera;
            var pos;

            var len = coordSystem === 'local' ? items.length : 1;
            for(var i = 0; i < len; i++) {
                if (items[i].child)
                    continue;

                if (coordSystem === 'local') {
                    pos = items[i].obj.entity.getPosition();
                    quat.copy(items[i].obj.entity.getRotation());
                } else {
                    pos = editor.call('gizmo:translate:position');
                    quat.setFromEulerAngles(0, 0, 0);
                }

                // x
                vecB.set(camera.camera.farClip * 2, 0, 0);
                quat.transformVector(vecB, vecB).add(pos);
                vecC.set(camera.camera.farClip * -2, 0, 0);
                quat.transformVector(vecC, vecC).add(pos);
                app.renderLine(vecB, vecC, linesColorBehind, pc.LINEBATCH_GIZMO);
                if ((gizmoAxis === 'x' && ! gizmoPlane) || (gizmoPlane && (gizmoAxis === 'y' || gizmoAxis === 'z'))) {
                    app.renderLine(vecB, vecC, linesColorActive);
                } else {
                    app.renderLine(vecB, vecC, linesColor);
                }

                // y
                vecB.set(0, camera.camera.farClip * 2, 0);
                quat.transformVector(vecB, vecB).add(pos);
                vecC.set(0, camera.camera.farClip * -2, 0);
                quat.transformVector(vecC, vecC).add(pos);
                app.renderLine(vecB, vecC, linesColorBehind, pc.LINEBATCH_GIZMO);
                if ((gizmoAxis === 'y' && ! gizmoPlane) || (gizmoPlane && (gizmoAxis === 'x' || gizmoAxis === 'z'))) {
                    app.renderLine(vecB, vecC, linesColorActive);
                } else {
                    app.renderLine(vecB, vecC, linesColor);
                }

                // z
                vecB.set(0, 0, camera.camera.farClip * 2);
                quat.transformVector(vecB, vecB).add(pos);
                vecC.set(0, 0, camera.camera.farClip * -2);
                quat.transformVector(vecC, vecC).add(pos);
                app.renderLine(vecB, vecC, linesColorBehind, pc.LINEBATCH_GIZMO);
                if ((gizmoAxis === 'z' && ! gizmoPlane) || (gizmoPlane && (gizmoAxis === 'x' || gizmoAxis === 'y'))) {
                    app.renderLine(vecB, vecC, linesColorActive);
                } else {
                    app.renderLine(vecB, vecC, linesColor);
                }
            }
        }
    };

    editor.once('viewport:load', function() {
        app = editor.call('viewport:framework');
    });

    var updateChildRelation = function() {
        var itemIds = { };
        for(var i = 0; i < items.length; i++) {
            itemIds[items[i].obj.get('resource_id')] = items[i];
        }

        for(var i = 0; i < items.length; i++) {
            var child = false;
            var parent = items[i].obj.entity._parent;
            var id = '';
            while(! child && parent) {
                id = parent.getGuid();
                if (itemIds[id]) {
                    parent = itemIds[id];
                    child = true;
                    break;
                }
                parent = parent._parent;
            }
            items[i].child = child;
            items[i].parent = child ? parent : null;
        }
    };

    var updateGizmo = function() {
        if (! editor.call('permissions:write'))
            return;

        var objects = editor.call('selector:items');

        for(var i = 0; i < events.length; i++)
            events[i].unbind();
        events = [ ];
        items = [ ];

        if (editor.call('selector:type') === 'entity' && editor.call('gizmo:type') === 'translate') {
            for(var i = 0; i < objects.length; i++) {
                if (! objects[i].entity)
                    continue;

                var pos = objects[i].entity.getPosition();

                items.push({
                    obj: objects[i],
                    pos: [ pos.x, pos.y, pos.z ],
                    start: [ 0, 0, 0 ],
                    startLocal: [ 0, 0, 0 ]
                });

                // position
                events.push(objects[i].on('position:set', updateGizmoPosition));
                // position.*
                for(var n = 0; n < 3; n++)
                    events.push(objects[i].on('position.' + n + ':set', updateGizmoPosition));

                // rotation
                events.push(objects[i].on('rotation:set', updateGizmoRotation));
                // rotation.*
                for(var n = 0; n < 3; n++)
                    events.push(objects[i].on('rotation.' + n + ':set', updateGizmoRotation));

                events.push(objects[i].on('parent:set', updateChildRelation));
            }

            if (! items.length)
                return;

            updateChildRelation();

            var rot = getGizmoRotation();
            editor.call('gizmo:translate:rotation', rot[0], rot[1], rot[2]);

            // gizmo start
            events.push(editor.on('gizmo:translate:start', onGizmoStart));
            // gizmo end
            events.push(editor.on('gizmo:translate:end', onGizmoEnd));
            // gizmo offset
            events.push(editor.on('gizmo:translate:offset', onGizmoOffset));

            // position gizmo
            var pos = getGizmoPosition();
            editor.call('gizmo:translate:position', pos.x, pos.y, pos.z);
            // show gizmo
            editor.call('gizmo:translate:toggle', true);
            // on render
            events.push(editor.on('gizmo:translate:render', onRender));
            // render
            editor.call('viewport:render');
        } else {
            // hide gizmo
            editor.call('gizmo:translate:toggle', false);
            // render
            editor.call('viewport:render');
        }
    };

    editor.on('gizmo:type', updateGizmo);
    editor.on('selector:change', updateGizmo);
});


/* editor/entities/entities-gizmo-scale.js */
editor.once('load', function() {
    'use strict';

    var events = [ ];
    var items = [ ];
    var quat = new pc.Quat();
    var vecA = new pc.Vec3();
    var vecB = new pc.Vec3();
    var vecC = new pc.Vec3();
    var startPosition = new pc.Vec3();
    var timeoutUpdatePosition, timeoutUpdateRotation;
    var app;
    var gizmoMoving = false;
    var gizmoAxis, gizmoMiddle;
    var linesColorActive = new pc.Color(1, 1, 1, 1);
    var linesColor = new pc.Color(1, 1, 1, .2);
    var linesColorBehind = new pc.Color(1, 1, 1, .05);

    // get position of gizmo based on selected entities
    var getGizmoPosition = function() {
        if (! items.length)
            return;

        var reference = items[items.length - 1];
        var parent = reference.parent;
        while(parent) {
            reference = parent;
            parent = parent.parent;
        }
        vecA.copy(reference.obj.entity.getPosition());

        return vecA;
    };

    var getGizmoRotation = function() {
        if (! items.length)
            return;

        var reference = items[items.length - 1];
        var parent = reference.parent;
        while(parent) {
            reference = parent;
            parent = parent.parent;
        }
        var rot = reference.obj.entity.getEulerAngles();

        return [ rot.x, rot.y, rot.z ];
    };

    // update gizmo position
    var updateGizmoPosition = function() {
        if (! items.length || timeoutUpdatePosition)
            return;

        timeoutUpdatePosition = true;

        setTimeout(function() {
            timeoutUpdatePosition = false;

            var vec = getGizmoPosition();
            if (vec)
                editor.call('gizmo:scale:position', vec.x, vec.y, vec.z);
        });
    };

    // update gizmo position
    var updateGizmoRotation = function() {
        if (! items.length || timeoutUpdateRotation)
            return;

        timeoutUpdateRotation = true;

        setTimeout(function() {
            timeoutUpdateRotation = false;

            var vec = getGizmoRotation();
            if (vec)
                editor.call('gizmo:scale:rotation', vec[0], vec[1], vec[2]);
        });
    };

    // start translating
    var onGizmoStart = function(axis, middle) {
        gizmoAxis = axis;
        gizmoMiddle = middle;
        gizmoMoving = true;

        for(var i = 0; i < items.length; i++) {
            var scale = items[i].obj.get('scale');
            items[i].start[0] = scale[0];
            items[i].start[1] = scale[1];
            items[i].start[2] = scale[2];
            items[i].pos = items[i].start.slice(0);
            items[i].obj.history.enabled = false;
        }
    };

    // end translating
    var onGizmoEnd = function() {
        gizmoMoving = false;
        var records = [ ];

        for(var i = 0; i < items.length; i++) {
            items[i].obj.history.enabled = true;

            records.push({
                get: items[i].obj.history._getItemFn,
                valueOld: items[i].start.slice(0),
                value: items[i].obj.get('scale')
            });
        }

        editor.call('history:add', {
            name: 'entities.scale',
            undo: function() {
                for(var i = 0; i < records.length; i++) {
                    var item = records[i].get();
                    if (! item)
                        continue;

                    item.history.enabled = false;
                    item.set('scale', records[i].valueOld);
                    item.history.enabled = true;
                }
            },
            redo: function() {
                for(var i = 0; i < records.length; i++) {
                    var item = records[i].get();
                    if (! item)
                        continue;

                    item.history.enabled = false;
                    item.set('scale', records[i].value);
                    item.history.enabled = true;
                }
            }
        });
    };

    // scaled
    var onGizmoOffset = function(x, y, z) {
        for(var i = 0; i < items.length; i++) {
            if (items[i].child)
                continue;

            items[i].obj.set('scale', [ items[i].start[0] * x, items[i].start[1] * y, items[i].start[2] * z ]);
        }
    };

    var onRender = function() {
        if (gizmoMoving) {
            var camera = app.activeCamera;

            for(var i = 0; i < items.length; i++) {
                if (items[i].child)
                    continue;

                vecA.copy(items[i].obj.entity.getPosition());
                quat.copy(items[i].obj.entity.getRotation());

                if (gizmoAxis === 'x' || gizmoMiddle) {
                    vecB.set(camera.camera.farClip * 2, 0, 0);
                    quat.transformVector(vecB, vecB).add(vecA);
                    vecC.set(camera.camera.farClip * -2, 0, 0);
                    quat.transformVector(vecC, vecC).add(vecA);
                    app.renderLine(vecB, vecC, linesColorBehind, pc.LINEBATCH_GIZMO);
                    app.renderLine(vecB, vecC, linesColorActive);
                }
                if (gizmoAxis === 'y' || gizmoMiddle) {
                    vecB.set(0, camera.camera.farClip * 2, 0);
                    quat.transformVector(vecB, vecB).add(vecA);
                    vecC.set(0, camera.camera.farClip * -2, 0);
                    quat.transformVector(vecC, vecC).add(vecA);
                    app.renderLine(vecB, vecC, linesColorBehind, pc.LINEBATCH_GIZMO);
                    app.renderLine(vecB, vecC, linesColorActive);
                }
                if (gizmoAxis === 'z' || gizmoMiddle) {
                    vecB.set(0, 0, camera.camera.farClip * 2);
                    quat.transformVector(vecB, vecB).add(vecA);
                    vecC.set(0, 0, camera.camera.farClip * -2);
                    quat.transformVector(vecC, vecC).add(vecA);
                    app.renderLine(vecB, vecC, linesColorBehind, pc.LINEBATCH_GIZMO);
                    app.renderLine(vecB, vecC, linesColorActive);
                }
            }
        } else {
            var dirty = false;
            for(var i = 0; i < items.length; i++) {
                if (! items[i].obj.entity)
                    continue;

                var pos = items[i].obj.entity.getPosition();
                if (pos.x !== items[i].pos[0] || pos.y !== items[i].pos[1] || pos.z !== items[i].pos[2]) {
                    dirty = true;
                    items[i].pos[0] = pos.x;
                    items[i].pos[1] = pos.y;
                    items[i].pos[2] = pos.z;
                }
            }

            if (dirty) {
                var pos = getGizmoPosition();
                editor.call('gizmo:scale:position', pos.x, pos.y, pos.z);
            }
        }
    };

    editor.once('viewport:load', function() {
        app = editor.call('viewport:framework');
    });

    var updateChildRelation = function() {
        var itemIds = { };
        for(var i = 0; i < items.length; i++) {
            itemIds[items[i].obj.get('resource_id')] = items[i];
        }

        for(var i = 0; i < items.length; i++) {
            var child = false;
            var parent = items[i].obj.entity._parent;
            var id = '';
            while(! child && parent) {
                id = parent.getGuid();
                if (itemIds[id]) {
                    parent = itemIds[id];
                    child = true;
                    break;
                }
                parent = parent._parent;
            }
            items[i].child = child;
            items[i].parent = child ? parent : null;
        }
    };

    var updateGizmo = function() {
        if (! editor.call('permissions:write'))
            return;

        var objects = editor.call('selector:items');

        for(var i = 0; i < events.length; i++)
            events[i].unbind();
        events = [ ];
        items = [ ];

        if (editor.call('selector:type') === 'entity' && editor.call('gizmo:type') === 'scale') {
            for(var i = 0; i < objects.length; i++) {
                if (! objects[i].entity)
                    continue;

                var pos = objects[i].entity.getPosition();

                items.push({
                    obj: objects[i],
                    pos: [ pos.x, pos.y, pos.z ],
                    start: [ 1, 1, 1 ]
                });

                // position
                events.push(objects[i].on('position:set', updateGizmoPosition));
                // position.*
                for(var n = 0; n < 3; n++)
                    events.push(objects[i].on('position.' + n + ':set', updateGizmoPosition));

                // rotation
                events.push(objects[i].on('rotation:set', updateGizmoRotation));
                // rotation.*
                for(var n = 0; n < 3; n++)
                    events.push(objects[i].on('rotation.' + n + ':set', updateGizmoRotation));

                events.push(objects[i].on('parent:set', updateChildRelation));
            }

            if (! items.length)
                return;

            updateChildRelation();

            var rot = getGizmoRotation();
            editor.call('gizmo:scale:rotation', rot[0], rot[1], rot[2]);

            // gizmo start
            events.push(editor.on('gizmo:scale:start', onGizmoStart));
            // gizmo end
            events.push(editor.on('gizmo:scale:end', onGizmoEnd));
            // gizmo offset
            events.push(editor.on('gizmo:scale:offset', onGizmoOffset));

            // position gizmo
            var pos = getGizmoPosition();
            editor.call('gizmo:scale:position', pos.x, pos.y, pos.z);
            // show gizmo
            editor.call('gizmo:scale:toggle', true);
            // on render
            events.push(editor.on('gizmo:scale:render', onRender));
            // render
            editor.call('viewport:render');
        } else {
            // hide gizmo
            editor.call('gizmo:scale:toggle', false);
            // render
            editor.call('viewport:render');
        }
    };

    editor.on('gizmo:type', updateGizmo);
    editor.on('selector:change', updateGizmo);
});


/* editor/entities/entities-gizmo-rotate.js */
editor.once('load', function() {
    'use strict';

    var events = [ ];
    var items = [ ];
    var quat = new pc.Quat();
    var quatB = new pc.Quat();
    var vecA = new pc.Vec3();
    var vecB = new pc.Vec3();
    var vecC = new pc.Vec3();
    var startPosition = new pc.Vec3();
    var timeoutUpdatePosition, timeoutUpdateRotation;
    var coordSystem = 'world';
    var app;
    var gizmoPos = new pc.Vec3();
    var gizmoMoving = false;
    var gizmoAxis;
    var linesColorActive = new pc.Color(1, 1, 1, 1);
    var linesColor = new pc.Color(1, 1, 1, .2);
    var linesColorBehind = new pc.Color(1, 1, 1, .05);

    editor.on('gizmo:coordSystem', function(system) {
        if (coordSystem === system)
            return;

        coordSystem = system;

        var rot = getGizmoRotation();
        if (rot)
            editor.call('gizmo:rotate:rotation', rot[0], rot[1], rot[2]);

        var vec = getGizmoPosition();
        if (vec)
            editor.call('gizmo:rotate:position', vec.x, vec.y, vec.z);

        editor.call('viewport:render');
    });

    // get position of gizmo based on selected entities
    var getGizmoPosition = function() {
        if (! items.length)
            return;

        if (items.length === 1) {
            vecA.copy(items[0].obj.entity.getPosition());
        } else if (coordSystem === 'local') {
            var reference = items[items.length - 1];
            var parent = reference.parent;
            while(parent) {
                reference = parent;
                parent = parent.parent;
            }
            vecA.copy(reference.obj.entity.getPosition());
        } else {
            var selection = editor.call('selection:aabb');
            if (! selection) return;
            vecA.copy(selection.center);
        }

        return vecA;
    };

    var getGizmoRotation = function() {
        if (! items.length)
            return;

        if (coordSystem === 'local') {
            var reference = items[items.length - 1];
            var parent = reference.parent;
            while(parent) {
                reference = parent;
                parent = parent.parent;
            }
            var rot = reference.obj.entity.getEulerAngles();

            return [ rot.x, rot.y, rot.z ];
        } else {
            return [ 0, 0, 0 ];
        }
    };

    // update gizmo position
    var updateGizmoPosition = function() {
        if (! items.length || timeoutUpdatePosition || gizmoMoving)
            return;

        timeoutUpdatePosition = true;

        setTimeout(function() {
            timeoutUpdatePosition = false;

            var vec = getGizmoPosition();
            if (vec)
                editor.call('gizmo:rotate:position', vec.x, vec.y, vec.z);
        });
    };

    // update gizmo position
    var updateGizmoRotation = function() {
        if (! gizmoMoving)
            updateGizmoPosition();

        if (! items.length || timeoutUpdateRotation)
            return;

        timeoutUpdateRotation = true;

        setTimeout(function() {
            timeoutUpdateRotation = false;

            var vec = getGizmoRotation();
            if (vec)
                editor.call('gizmo:rotate:rotation', vec[0], vec[1], vec[2]);
        });
    };

    // start translating
    var onGizmoStart = function(axis) {
        gizmoAxis = axis;
        gizmoMoving = true;

        gizmoPos.copy(editor.call('gizmo:rotate:position'));

        for(var i = 0; i < items.length; i++) {
            var rot = items[i].obj.entity.getEulerAngles();
            items[i].start[0] = rot.x;
            items[i].start[1] = rot.y;
            items[i].start[2] = rot.z;
            items[i].pos = items[i].start.slice(0);

            var posLocal = items[i].obj.entity.getLocalPosition();

            items[i].startPosLocal[0] = posLocal.x;
            items[i].startPosLocal[1] = posLocal.y;
            items[i].startPosLocal[2] = posLocal.z;

            var pos = items[i].obj.entity.getPosition();

            items[i].offset[0] = pos.x - gizmoPos.x;
            items[i].offset[1] = pos.y - gizmoPos.y;
            items[i].offset[2] = pos.z - gizmoPos.z;

            rot = items[i].obj.get('rotation');
            items[i].startLocal[0] = rot[0];
            items[i].startLocal[1] = rot[1];
            items[i].startLocal[2] = rot[2];

            items[i].startLocalQuat.copy(items[i].obj.entity.getLocalRotation());
            items[i].startQuat.copy(items[i].obj.entity.getRotation());

            items[i].obj.history.enabled = false;
        }
    };

    // end translating
    var onGizmoEnd = function() {
        gizmoMoving = false;
        var records = [ ];

        for(var i = 0; i < items.length; i++) {
            items[i].obj.history.enabled = true;

            records.push({
                get: items[i].obj.history._getItemFn,
                valueRotOld: items[i].startLocal.slice(0),
                valueRot: items[i].obj.get('rotation'),
                valuePosOld: items[i].startPosLocal.slice(0),
                valuePos: items[i].obj.get('position')
            });
        }

        editor.call('history:add', {
            name: 'entities.rotate',
            undo: function() {
                for(var i = 0; i < records.length; i++) {
                    var item = records[i].get();
                    if (! item)
                        continue;

                    item.history.enabled = false;
                    item.set('position', records[i].valuePosOld);
                    item.set('rotation', records[i].valueRotOld);
                    item.history.enabled = true;
                }
            },
            redo: function() {
                for(var i = 0; i < records.length; i++) {
                    var item = records[i].get();
                    if (! item)
                        continue;

                    item.history.enabled = false;
                    item.set('position', records[i].valuePos);
                    item.set('rotation', records[i].valueRot);
                    item.history.enabled = true;
                }
            }
        });

        var pos = getGizmoPosition();
        editor.call('gizmo:rotate:position', pos.x, pos.y, pos.z);
    };

    // translated
    var onGizmoOffset = function(angle, point) {
        timeoutUpdateRotation = true;

        for(var i = 0; i < items.length; i++) {
            if (items[i].child)
                continue;

            vecA.set(0, 0, 0);
            vecA[gizmoAxis] = 1;

            quat.setFromAxisAngle(vecA, angle);

            if (coordSystem === 'local') {
                quatB.copy(items[i].startLocalQuat).mul(quat);
                items[i].obj.entity.setLocalRotation(quatB);
            } else if (items.length === 1) {
                quatB.copy(quat).mul(items[i].startQuat);
                items[i].obj.entity.setRotation(quatB);
            } else {
                vecA.set(items[i].offset[0], items[i].offset[1], items[i].offset[2]);
                quat.transformVector(vecA, vecA);
                quatB.copy(quat).mul(items[i].startQuat);
                items[i].obj.entity.setRotation(quatB);
                items[i].obj.entity.setPosition(vecA.add(gizmoPos));

                var pos = items[i].obj.entity.getLocalPosition();
                items[i].obj.set('position', [ pos.x, pos.y, pos.z ]);
            }

            var angles = items[i].obj.entity.getLocalEulerAngles();
            items[i].obj.set('rotation', [ angles.x, angles.y, angles.z ]);
        }

        timeoutUpdateRotation = false;

        if (items.length > 1 || coordSystem === 'local') {
            var rot = getGizmoRotation();
            editor.call('gizmo:rotate:rotation', rot[0], rot[1], rot[2]);
        }
    };

    var onRender = function() {
        if (! gizmoMoving && items.length) {
            var dirty = false;
            for(var i = 0; i < items.length; i++) {
                if (! items[i].obj.entity)
                    continue;

                var pos = items[i].obj.entity.getPosition();
                if (pos.x !== items[i].pos[0] || pos.y !== items[i].pos[1] || pos.z !== items[i].pos[2]) {
                    dirty = true;
                    items[i].pos[0] = pos.x;
                    items[i].pos[1] = pos.y;
                    items[i].pos[2] = pos.z;
                }
            }

            if (dirty) {
                var pos = getGizmoPosition();
                editor.call('gizmo:translate:position', pos.x, pos.y, pos.z);
            }
        }

        if (items.length > 1 && ! coordSystem === 'world') {
            var rot = getGizmoRotation();
            editor.call('gizmo:rotate:rotation', rot[0], rot[1], rot[2]);
        }
    };

    editor.once('viewport:load', function() {
        app = editor.call('viewport:framework');
    });

    var updateChildRelation = function() {
        var itemIds = { };
        for(var i = 0; i < items.length; i++) {
            itemIds[items[i].obj.get('resource_id')] = items[i];
        }

        for(var i = 0; i < items.length; i++) {
            var child = false;
            var parent = items[i].obj.entity._parent;
            var id = '';
            while(! child && parent) {
                id = parent.getGuid();
                if (itemIds[id]) {
                    parent = itemIds[id];
                    child = true;
                    break;
                }
                parent = parent._parent;
            }
            items[i].child = child;
            items[i].parent = child ? parent : null;
        }

        updateGizmoPosition();
    };

    var updateGizmo = function() {
        if (! editor.call('permissions:write'))
            return;

        var objects = editor.call('selector:items');

        for(var i = 0; i < events.length; i++)
            events[i].unbind();
        events = [ ];
        items = [ ];

        if (editor.call('selector:type') === 'entity' && editor.call('gizmo:type') === 'rotate') {
            for(var i = 0; i < objects.length; i++) {
                if (! objects[i].entity)
                    continue;

                var pos = objects[i].entity.getPosition();

                items.push({
                    obj: objects[i],
                    startLocalQuat: objects[i].entity.getLocalRotation().clone(),
                    startQuat: objects[i].entity.getRotation().clone(),
                    pos: [ pos.x, pos.y, pos.z ],
                    offset: [ 0, 0, 0 ],
                    start: [ 0, 0, 0 ],
                    startLocal: [ 0, 0, 0 ],
                    startPosLocal: [ 0, 0, 0 ]
                });

                // position
                events.push(objects[i].on('position:set', updateGizmoPosition));
                // position.*
                for(var n = 0; n < 3; n++)
                    events.push(objects[i].on('position.' + n + ':set', updateGizmoPosition));

                // rotation
                events.push(objects[i].on('rotation:set', updateGizmoRotation));
                // rotation.*
                for(var n = 0; n < 3; n++)
                    events.push(objects[i].on('rotation.' + n + ':set', updateGizmoRotation));

                events.push(objects[i].on('parent:set', updateChildRelation));
            }

            if (! items.length)
                return;

            updateChildRelation();

            // gizmo start
            events.push(editor.on('gizmo:rotate:start', onGizmoStart));
            // gizmo end
            events.push(editor.on('gizmo:rotate:end', onGizmoEnd));
            // gizmo offset
            events.push(editor.on('gizmo:rotate:offset', onGizmoOffset));

            // rotation gizmo
            var rot = getGizmoRotation();
            editor.call('gizmo:rotate:rotation', rot[0], rot[1], rot[2]);
            // position gizmo
            var pos = getGizmoPosition();
            editor.call('gizmo:rotate:position', pos.x, pos.y, pos.z);
            // show gizmo
            editor.call('gizmo:rotate:toggle', true);
            // on render
            events.push(editor.on('gizmo:rotate:render', onRender));
            // render
            editor.call('viewport:render');
        } else {
            // hide gizmo
            editor.call('gizmo:rotate:toggle', false);
            // render
            editor.call('viewport:render');
        }
    };

    editor.on('gizmo:type', updateGizmo);
    editor.on('selector:change', updateGizmo);
});


/* editor/entities/entities-clipboard.js */
editor.once('load', function () {
    var CLIPBOARD_NAME = 'playcanvas_editor_clipboard';
    var CLIPBOARD_META = CLIPBOARD_NAME + '_meta';

    // get current clipboard value
    editor.method('entities:clipboard:get', function () {
        return editor.call('localStorage:get', CLIPBOARD_NAME);
    });

    // set current clipboard value
    editor.method('entities:clipboard:set', function (data) {
        editor.call('localStorage:set', CLIPBOARD_META, {project: config.project.id});
        editor.call('localStorage:set', CLIPBOARD_NAME, data);
    });

    // return true if there is no data in the clipboard
    editor.method('entities:clipboard:empty', function () {
        var metaData = editor.call('localStorage:get', CLIPBOARD_META);
        return !metaData || metaData.project !== config.project.id;
    });
});

/* editor/components/components-schema.js */
editor.once('load', function() {
    'use strict';

    var schema = {
        animation: {
            title: 'Animation',
            default: {
                enabled: true,
                assets: [],
                speed: 1,
                loop: true,
                activate: true
            }
        },

        light: {
            title: 'Light',
            default: {
                enabled: true,
                type: 'directional',
                color: [1, 1, 1],
                intensity: 1,
                castShadows: false,
                shadowDistance: 40,
                shadowResolution: 1024,
                shadowBias: 0.05,
                normalOffsetBias: 0,
                range: 10,
                falloffMode: 0,
                innerConeAngle: 40,
                outerConeAngle: 45
            },
            types: {
                color: 'rgb'
            }
        },

        audiolistener: {
            title: 'Audio Listener',
            default: {
                enabled: true
            }
        },

        audiosource: {
            title: 'Audio Source',
            default: {
                enabled: true,
                assets: [],
                volume: 1,
                pitch: 1,
                loop: false,
                activate: true,
                '3d': true,
                minDistance: 1,
                maxDistance: 10000,
                rollOffFactor: 1
            }
        },

        camera: {
            title: 'Camera',
            default: {
                enabled: true,
                clearColorBuffer: true,
                clearColor: [0.722, 0.722, 0.722, 1],
                clearDepthBuffer: true,
                projection: 0,
                fov: 45,
                frustumCulling: true,
                orthoHeight: 100,
                nearClip: 0.3,
                farClip: 1000,
                priority: 0,
                rect: [0, 0, 1, 1]
            },
            types: {
                clearColor: 'rgb',
                rect: 'vec4'
            }
        },

        collision: {
            title: 'Collision',
            default: {
                enabled: true,
                type: 'box',
                halfExtents: [0.5,  0.5, 0.5],
                radius: 0.5,
                axis: 1,
                height: 2,
                asset: null
            },
            types: {
                halfExtents: 'vec3'
            }
        },

        model: {
            title: 'Model',
            default: {
                enabled: true,
                type: 'asset',
                asset: null,
                materialAsset: null,
                castShadows: false,
                receiveShadows: true,
            }
        },

        particlesystem: {
            title: 'Particle System',
            default: {
                enabled: true,
                autoPlay: true,
                numParticles: 30,
                lifetime: 5,
                rate: 0.1,
                rate2: 0.1,
                startAngle: 0,
                startAngle2: 0,
                loop: true,
                preWarm: false,
                lighting: false,
                halfLambert: false,
                intensity: 1,
                depthWrite: false,
                depthSoftening: 0,
                sort: 0,
                blendType: 2,
                stretch: 0,
                alignToMotion: false,
                emitterShape: 0,
                emitterExtents: [0, 0, 0],
                emitterRadius: 0,
                initialVelocity: 0,
                animTilesX: 1,
                animTilesY: 1,
                animNumFrames: 1,
                animSpeed: 1,
                animLoop: true,
                wrap: false,
                wrapBounds: [0,0,0],
                colorMapAsset: null,
                normalMapAsset: null,
                mesh: null,
                localVelocityGraph: {
                    type: 1,
                    keys: [[0, 0], [0, 0], [0, 0]],
                    betweenCurves: false
                },
                localVelocityGraph2: {
                    type: 1,
                    keys: [[0, 0], [0, 0], [0, 0]]
                },
                velocityGraph: {
                    type: 1,
                    keys: [[0, -1], [0, -1], [0, -1]],
                    betweenCurves: true
                },
                velocityGraph2: {
                    type: 1,
                    keys: [[0, 1], [0, 1], [0, 1]]
                },
                rotationSpeedGraph: {
                    type: 1,
                    keys: [0, 0],
                    betweenCurves: false
                },
                rotationSpeedGraph2: {
                    type: 1,
                    keys: [0, 0]
                },
                scaleGraph: {
                    type: 1,
                    keys: [0, 0.1],
                    betweenCurves: false
                },
                scaleGraph2: {
                    type: 1,
                    keys: [0, 0.1]
                },
                colorGraph: {
                    type: 1,
                    keys: [[0, 1], [0, 1], [0, 1]],
                    betweenCurves: false
                },
                alphaGraph: {
                    type: 1,
                    keys: [0, 1],
                    betweenCurves: false
                },
                alphaGraph2: {
                    type: 1,
                    keys: [0, 1]
                }
            },
            types: {
                emitterExtents: 'vec3',
                localVelocityGraph: 'curveset',
                localVelocityGraph2: 'curveset',
                velocityGraph: 'curveset',
                velocityGraph2: 'curveset',
                rotationSpeedGraph: 'curve',
                rotationSpeedGraph2: 'curve',
                scaleGraph: 'curve',
                scaleGraph2: 'curve',
                colorGraph: 'curveset',
                alphaGraph: 'curve',
                alphaGraph2: 'curve'
            }
        },

        rigidbody: {
            title: 'Rigid Body',
            default: {
                enabled: true,
                type: 'static',
                mass: 1,
                linearDamping: 0,
                angularDamping: 0,
                linearFactor: [1, 1, 1],
                angularFactor: [1, 1, 1],
                friction: 0.5,
                restitution: 0.5
            },
            types: {
                linearFactor: 'vec3',
                angularFactor: 'vec3'
            }
        },

        script: {
            title: 'Script',
            default: {
                enabled: true,
                scripts: [ ]
            }
        }
    };

    var list = Object.keys(schema).sort(function(a, b) {
        if (a > b) {
            return 1;
        } else if (a < b) {
            return -1;
        } else {
            return 0;
        }
    });

    editor.method('components:convertValue', function (component, property, value) {
        var result = value;

        if (value) {
            var data = schema[component];
            if (data && data.types) {
                var type = data.types[property];
                switch (type) {
                    case 'rgb':
                        result = new pc.Color(value[0], value[1], value[2]);
                        break;
                    case 'rgba':
                        result = new pc.Color(value[0], value[1], value[2], value[3]);
                        break;
                    case 'vec3':
                        result = new pc.Vec3(value[0], value[1], value[2]);
                        break;
                    case 'vec4':
                        result = new pc.Vec4(value[0], value[1], value[2], value[3]);
                        break;
                    case 'curveset':
                        result = new pc.CurveSet(value.keys);
                        result.type = value.type;
                        break;
                    case 'curve':
                        result = new pc.Curve(value.keys);
                        result.type = value.type;
                        break;
                }
            }
        }

        return result;
    });

    editor.method('components:list', function () {
        return list.slice(0);
    });

    editor.method('components:schema', function () {
        return schema;
    });

    editor.method('components:getDefault', function (component) {
        return utils.deepCopy(schema[component].default);
    });

});




/* editor/gizmo/gizmo.js */
editor.once('load', function() {
    'use strict';

    var gizmoType = 'translate';
    var coordSystem = 'world';
    var snap = false;
    var snapToggle = false;
    var snapShift = false;
    var snapIncrement = 1;

    editor.method('gizmo:type', function(type) {
        if (type === undefined)
            return gizmoType;

        if (gizmoType === type)
            return;

        gizmoType = type;

        editor.emit('gizmo:type', type);
    });

    editor.method('gizmo:coordSystem', function(system) {
        if (system === undefined)
            return coordSystem;

        if (coordSystem === system)
            return;

        coordSystem = system;

        editor.emit('gizmo:coordSystem', system);
    });

    var checkSnap = function() {
        var state = (snapToggle || snapShift) && (snapToggle !== snapShift);
        if (snap === state)
            return;

        snap = state;
        editor.emit('gizmo:snap', snap, snapIncrement);
    };

    editor.method('gizmo:snap', function(state) {
        if (snapToggle === state)
            return;

        snapToggle = state;
        checkSnap();
    });

    var designerSettings = editor.call('designerSettings');
    designerSettings.on('snap_increment:set', function(value) {
        if (snapIncrement === (value || 1))
            return;

        snapIncrement = value || 1;
        editor.emit('gizmo:snap', snap, snapIncrement);
    });
    snapIncrement = designerSettings.get('snap_increment') || 1;

    editor.on('hotkey:shift', function(state) {
        if (snapShift === state)
            return;

        snapShift = state;
        checkSnap();
    });

    editor.once('viewport:load', function() {
        var app = editor.call('viewport:framework');

        // clear depth buffer before gizmo layer
        app.scene.drawCalls.push(new pc.scene.Command(pc.LAYER_GIZMO, pc.BLEND_NONE, function() {
            app.graphicsDevice.clear({
                flags: pc.CLEARFLAG_DEPTH
            });
        }));
    })
});


/* editor/gizmo/gizmo-translate.js */
editor.once('load', function() {
    'use strict';

    var gizmo = null;
    var visible = true;
    var moving = false;
    var mouseTap = null;
    var mouseTapMoved = false;
    var posCameraLast = new pc.Vec3();
    var visible = true;
    var hover = false;
    var hoverAxis = '';
    var hoverPlane = false;
    var hoverEntity = null;
    var gizmoSize = .4;
    var arrowRadius = .4;
    var vecA = new pc.Vec3();
    var vecB = new pc.Vec3();
    var vecC = new pc.Vec3();
    var vecD = new pc.Vec3();
    var quat = new pc.Quat();
    var evtTapStart;
    var evtTapMove;
    var evtTapEnd;
    var pickStart = new pc.Vec3();

    var snap = false;
    var snapIncrement = 1;
    editor.on('gizmo:snap', function(state, increment) {
        snap = state;
        snapIncrement = increment;
    });

    // enable/disable gizmo
    editor.method('gizmo:translate:toggle', function(state) {
        if (! gizmo)
            return;

        if (! editor.call('permissions:write'))
            return;

        gizmo.root.enabled = state;

        visible = true;
    });

    // show/hide gizmo
    editor.method('gizmo:translate:visible', function(state) {
        if (! gizmo)
            return;

        visible = state;

        for(var i = 0; i < gizmo.hoverable.length; i++) {
            if (! gizmo.hoverable[i].model)
                continue;

            gizmo.hoverable[i].model.enabled = state;
        }

        editor.call('viewport:render');
    });

    // position gizmo
    editor.method('gizmo:translate:position', function(x, y, z) {
        if (x === undefined)
            return gizmo.root.getPosition();

        gizmo.root.setPosition(x, y, z);

        if (gizmo.root.enabled)
            editor.call('viewport:render');
    });

    // rotate gizmo
    editor.method('gizmo:translate:rotation', function(pitch, yaw, roll) {
        gizmo.root.setEulerAngles(pitch, yaw, roll);

        if (gizmo.root.enabled)
            editor.call('viewport:render');
    });

    // initialize gizmo
    editor.once('viewport:load', function() {
        var app = editor.call('viewport:framework');

        gizmo = createEntity();
        gizmo.root.enabled = false;
        app.root.addChild(gizmo.root);

        // on picker hover
        editor.on('viewport:pick:hover', function(node, picked) {
            var match = gizmo.hoverable.indexOf(node) !== -1;
            if (! hover && match) {
                // hover
                hover = true;
            } else if (hover && ! match) {
                // unhover
                hover = false;
            }

            if (hover) {
                hoverEntity = node;

                if (node.axis && (hoverAxis !== node.axis || hoverPlane !== node.plane)) {
                    // set normal material
                    if (hoverAxis) {
                        if (hoverPlane) {
                            gizmo.plane[hoverAxis].model.material = gizmo.plane[hoverAxis].mat;
                        } else {
                            gizmo.arrow[hoverAxis].model.material = gizmo.arrow[hoverAxis].mat;
                        }
                    }

                    if (! hoverAxis && ! evtTapStart)
                        evtTapStart = editor.on('viewport:tap:start', onTapStart);

                    hoverAxis = node.axis;
                    hoverPlane = node.plane;

                    // set active material
                    if (hoverPlane) {
                        gizmo.plane[hoverAxis].model.material = gizmo.matActiveTransparent;
                    } else {
                        gizmo.arrow[hoverAxis].model.material = gizmo.matActive;
                    }
                }
            } else {
                if (hoverAxis) {
                    if (hoverPlane) {
                        gizmo.plane[hoverAxis].model.material = gizmo.plane[hoverAxis].mat;
                    } else {
                        gizmo.arrow[hoverAxis].model.material = gizmo.arrow[hoverAxis].mat;
                    }
                }

                hoverAxis = '';

                if (evtTapStart) {
                    evtTapStart.unbind();
                    evtTapStart = null;
                }
            }
        });

        // update gizmo
        editor.on('viewport:postUpdate', function(dt) {
            if (gizmo.root.enabled) {
                var camera = app.activeCamera;
                var posCamera = camera.getPosition();

                quat.copy(gizmo.root.getRotation()).invert();

                if (moving && (vecA.copy(posCameraLast).sub(posCamera).length() > 0.01 || mouseTapMoved)) {
                    var point = pickPlane(mouseTap.x, mouseTap.y);
                    if (point) {
                        point.sub(pickStart);
                        if (snap) {
                            point.scale(1 / snapIncrement);
                            point.x = Math.round(point.x);
                            point.y = Math.round(point.y);
                            point.z = Math.round(point.z);
                            point.scale(snapIncrement);
                        }
                        editor.emit('gizmo:translate:offset', point.x, point.y, point.z);
                    }
                }

                editor.emit('gizmo:translate:render', dt);

                posCameraLast.copy(posCamera);

                var posGizmo = gizmo.root.getPosition();
                var scale = 1;

                // scale to screen space
                if (camera.camera.projection === pc.PROJECTION_PERSPECTIVE) {
                    var dot = vecA.copy(posGizmo).sub(posCamera).dot(camera.forward);
                    var denom = 1280 / Math.tan(camera.camera.fov * pc.math.DEG_TO_RAD);
                    scale = Math.max(0.0001, (dot / denom) * 150) * gizmoSize;
                } else {
                    scale = camera.camera.orthoHeight / 3 * gizmoSize;
                }
                gizmo.root.setLocalScale(scale, scale, scale);

                // calculate viewing angle
                vecA
                .copy(posCamera)
                .sub(posGizmo)
                .normalize();

                // rotate vector by gizmo rotation
                quat.transformVector(vecA, vecA);

                // swap sides to face camera
                // x
                gizmo.plane.x.setLocalPosition(0, (vecA.y > 0) ? .4 : -.4, (vecA.z > 0) ? .4 : -.4);
                gizmo.line.x.setLocalPosition((vecA.x > 0) ? 1.5 : 1.1, 0, 0);
                gizmo.line.x.setLocalScale(arrowRadius, (vecA.x > 0) ? 1 : 1.8, arrowRadius);
                // y
                gizmo.plane.y.setLocalPosition((vecA.x > 0) ? .4 : -.4, 0, (vecA.z > 0) ? .4 : -.4);
                gizmo.line.y.setLocalPosition(0, (vecA.y > 0) ? 1.5 : 1.1, 0);
                gizmo.line.y.setLocalScale(arrowRadius, (vecA.y > 0) ? 1 : 1.8, arrowRadius);
                // z
                gizmo.plane.z.setLocalPosition((vecA.x > 0) ? .4 : -.4, (vecA.y > 0) ? .4 : -.4, 0);
                gizmo.line.z.setLocalPosition(0, 0, (vecA.z > 0) ? 1.5 : 1.1);
                gizmo.line.z.setLocalScale(arrowRadius, (vecA.z > 0) ? 1 : 1.8, arrowRadius);

                // hide plane if viewed from very angle
                gizmo.plane.x.model.enabled = Math.abs(vecA.x) > 0.15 && visible;
                gizmo.plane.y.model.enabled = Math.abs(vecA.y) > 0.15 && visible;
                gizmo.plane.z.model.enabled = Math.abs(vecA.z) > 0.15 && visible;

                quat.invert();

                // plane x lines
                if (gizmo.plane.x.model.enabled) {
                    vecB.set(0, 0, (vecA.z > 0) ? scale * .8 : -scale * .8);
                    vecC.set(0, (vecA.y > 0) ? scale * .8 : -scale * .8, (vecA.z > 0) ? scale * .8 : -scale * .8);
                    vecD.set(0, (vecA.y > 0) ? scale * .8 : -scale * .8, 0);
                    quat.transformVector(vecB, vecB).add(gizmo.root.getPosition());
                    quat.transformVector(vecC, vecC).add(gizmo.root.getPosition());
                    quat.transformVector(vecD, vecD).add(gizmo.root.getPosition());
                    var clr = (hoverAxis === 'x' && hoverPlane) ? gizmo.matActive.color : gizmo.arrow.x.mat.color;
                    app.renderLines([ vecB, vecC, vecC, vecD ], clr, pc.LINEBATCH_GIZMO);
                }
                // plane y lines
                if (gizmo.plane.y.model.enabled) {
                    vecB.set((vecA.x > 0) ? scale * .8 : -scale * .8, 0, 0);
                    vecC.set((vecA.x > 0) ? scale * .8 : -scale * .8, 0, (vecA.z > 0) ? scale * .8 : -scale * .8);
                    vecD.set(0, 0, (vecA.z > 0) ? scale * .8 : -scale * .8);
                    quat.transformVector(vecB, vecB).add(gizmo.root.getPosition());
                    quat.transformVector(vecC, vecC).add(gizmo.root.getPosition());
                    quat.transformVector(vecD, vecD).add(gizmo.root.getPosition());
                    var clr = (hoverAxis === 'y' && hoverPlane) ? gizmo.matActive.color : gizmo.arrow.y.mat.color;
                    app.renderLines([ vecB, vecC, vecC, vecD ], clr, pc.LINEBATCH_GIZMO);
                }
                // plane z lines
                if (gizmo.plane.z.model.enabled) {
                    vecB.set((vecA.x > 0) ? scale * .8 : -scale * .8, 0, 0);
                    vecC.set((vecA.x > 0) ? scale * .8 : -scale * .8, (vecA.y > 0) ? scale * .8 : -scale * .8, 0);
                    vecD.set(0, (vecA.y > 0) ? scale * .8 : -scale * .8, 0);
                    quat.transformVector(vecB, vecB).add(gizmo.root.getPosition());
                    quat.transformVector(vecC, vecC).add(gizmo.root.getPosition());
                    quat.transformVector(vecD, vecD).add(gizmo.root.getPosition());
                    var clr = (hoverAxis === 'z' && hoverPlane) ? gizmo.matActive.color : gizmo.arrow.z.mat.color;
                    app.renderLines([ vecB, vecC, vecC, vecD ], clr, pc.LINEBATCH_GIZMO);
                }

                // hide lines and arrows if viewed from very angle
                gizmo.line.x.model.enabled = gizmo.arrow.x.model.enabled = ! (Math.abs(vecA.z) <= 0.15 && Math.abs(vecA.y) <= 0.15) && visible;
                gizmo.line.y.model.enabled = gizmo.arrow.y.model.enabled = ! (Math.abs(vecA.x) <= 0.15 && Math.abs(vecA.z) <= 0.15) && visible;
                gizmo.line.z.model.enabled = gizmo.arrow.z.model.enabled = ! (Math.abs(vecA.x) <= 0.15 && Math.abs(vecA.y) <= 0.15) && visible;

                // draw axes lines
                // line x
                if (gizmo.line.x.model.enabled) {
                    vecB.set(((vecA.x > 0) ? scale * 1 : scale * .2), 0, 0);
                    quat.transformVector(vecB, vecB).add(gizmo.root.getPosition());
                    vecC.set(scale * 2, 0, 0);
                    quat.transformVector(vecC, vecC).add(gizmo.root.getPosition());
                    app.renderLine(vecB, vecC, gizmo.arrow.x.model.material.color, pc.LINEBATCH_GIZMO);
                }
                // line y
                if (gizmo.line.y.model.enabled) {
                    vecB.set(0, ((vecA.y > 0) ? scale * 1 : scale * .2), 0);
                    quat.transformVector(vecB, vecB).add(gizmo.root.getPosition());
                    vecC.set(0, scale * 2, 0);
                    quat.transformVector(vecC, vecC).add(gizmo.root.getPosition());
                    app.renderLine(vecB, vecC, gizmo.arrow.y.model.material.color, pc.LINEBATCH_GIZMO);
                }
                // line z
                if (gizmo.line.z.model.enabled) {
                    vecB.set(0, 0, ((vecA.z > 0) ? scale * 1 : scale * .2));
                    quat.transformVector(vecB, vecB).add(gizmo.root.getPosition());
                    vecC.set(0, 0, scale * 2);
                    quat.transformVector(vecC, vecC).add(gizmo.root.getPosition());
                    app.renderLine(vecB, vecC, gizmo.arrow.z.model.material.color, pc.LINEBATCH_GIZMO);
                }
            }

            mouseTapMoved = false
        });

        var pickPlane = function(x, y) {
            var camera = app.activeCamera;

            var mouseWPos = camera.camera.screenToWorld(x, y, 1);
            var posCamera = camera.getPosition();
            var posGizmo = gizmo.root.getPosition();
            var mouseDir = vecA.copy(mouseWPos).sub(posCamera).normalize();

            // vector based on selected axis
            vecB.set(0, 0, 0);
            vecB[hoverAxis] = 1;
            // rotate vector by gizmo rotation
            quat.copy(gizmo.root.getRotation()).transformVector(vecB, vecB);

            // single axis
            if (! hoverPlane) {
                vecC
                .copy(posCamera)
                .sub(posGizmo)
                .normalize();
                vecB.copy(vecC.sub(vecB.scale(vecB.dot(vecC))).normalize());
            }

            var rayPlaneDot = vecB.dot(mouseDir);
            var planeDist = posGizmo.dot(vecB);
            var pointPlaneDist = (vecB.dot(posCamera) - planeDist) / rayPlaneDot;
            var pickedPos = mouseDir.scale(-pointPlaneDist).add(posCamera);

            if (! hoverPlane) {
                // single axis
                vecB.set(0, 0, 0);
                vecB[hoverAxis] = 1;
                quat.transformVector(vecB, vecB);
                pickedPos.copy(vecB.scale(vecB.dot(pickedPos)));
            }

            quat.invert().transformVector(pickedPos, pickedPos);

            if (! hoverPlane) {
                var v = pickedPos[hoverAxis];
                pickedPos.set(0, 0, 0);
                pickedPos[hoverAxis] = v;
            }

            return pickedPos;
        };

        var onTapStart = function(tap) {
            if (moving)
                return;

            editor.emit('camera:toggle', false);

            moving = true;
            mouseTap = tap;

            if (gizmo.root.enabled)
                pickStart.copy(pickPlane(tap.x, tap.y));

            editor.emit('gizmo:translate:start', hoverAxis, hoverPlane);
            editor.call('gizmo:translate:visible', false);
        };

        var onTapMove = function(tap) {
            if (! moving)
                return;

            mouseTap = tap;
            mouseTapMoved = true;
        };

        var onTapEnd = function(tap) {
            editor.emit('camera:toggle', true);

            if (! moving)
                return;

            moving = false;
            mouseTap = tap;

            editor.emit('gizmo:translate:end');
            editor.call('gizmo:translate:visible', true);
        };

        editor.on('viewport:hover', function(state) {
            if (state || ! moving)
                return;

            moving = false;

            editor.emit('gizmo:translate:end');
            editor.call('gizmo:translate:visible', true);
        });

        evtTapMove = editor.on('viewport:tap:move', onTapMove);
        evtTapEnd = editor.on('viewport:tap:end', onTapEnd);
    });

    var createMaterial = function(color) {
        var mat = new pc.BasicMaterial();
        mat.color = color;
        if (color.a !== 1) {
            mat.blend = true;
            mat.blendSrc = pc.BLENDMODE_SRC_ALPHA;
            mat.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
        }
        mat.update();
        return mat;
    };

    var createEntity = function() {
        var obj = {
            root: null,
            plane: {
                x: null,
                y: null,
                z: null
            },
            line: {
                x: null,
                y: null,
                z: null
            },
            arrow: {
                x: null,
                y: null,
                z: null
            },
            hoverable: [ ],
            matActive: null,
            matActiveTransparent: null
        };

        // active mat
        obj.matActive = createMaterial(new pc.Color(1, 1, 1, 1));
        obj.matActiveTransparent = createMaterial(new pc.Color(1, 1, 1, .25));
        obj.matActiveTransparent.cull = pc.CULLFACE_NONE;

        // root entity
        var entity = obj.root = new pc.Entity();

        // plane x
        var planeX = obj.plane.x = new pc.Entity();
        obj.hoverable.push(planeX);
        planeX.axis = 'x';
        planeX.plane = true;
        planeX.addComponent('model', {
            type: 'plane'
        });
        planeX.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        entity.addChild(planeX);
        planeX.setLocalEulerAngles(90, -90, 0);
        planeX.setLocalScale(.8, .8, .8);
        planeX.setLocalPosition(0, .4, .4);
        planeX.mat = planeX.model.material = createMaterial(new pc.Color(1, 0, 0, .25));
        planeX.mat.cull = pc.CULLFACE_NONE;

        // plane y
        var planeY = obj.plane.y = new pc.Entity();
        obj.hoverable.push(planeY);
        planeY.axis = 'y';
        planeY.plane = true;
        planeY.addComponent('model', {
            type: 'plane'
        });
        planeY.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        entity.addChild(planeY);
        planeY.setLocalEulerAngles(0, 0, 0);
        planeY.setLocalScale(.8, .8, .8);
        planeY.setLocalPosition(-.4, 0, .4);
        planeY.mat = planeY.model.material = createMaterial(new pc.Color(0, 1, 0, .25));
        planeY.mat.cull = pc.CULLFACE_NONE;

        // plane z
        var planeZ = obj.plane.z = new pc.Entity();
        obj.hoverable.push(planeZ);
        planeZ.axis = 'z';
        planeZ.plane = true;
        planeZ.addComponent('model', {
            type: 'plane'
        });
        planeZ.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        entity.addChild(planeZ);
        planeZ.setLocalEulerAngles(90, 0, 0);
        planeZ.setLocalScale(.8, .8, .8);
        planeZ.setLocalPosition(-.4, .4, 0);
        planeZ.mat = planeZ.model.material = createMaterial(new pc.Color(0, 0, 1, .25));
        planeZ.mat.cull = pc.CULLFACE_NONE;

        // line x
        var lineX = obj.line.x = new pc.Entity();
        obj.hoverable.push(lineX);
        lineX.axis = 'x';
        lineX.addComponent('model', {
            type: 'cylinder'
        });
        lineX.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        entity.addChild(lineX);
        lineX.setLocalEulerAngles(90, 90, 0);
        lineX.setLocalPosition(1.6, 0, 0);
        lineX.setLocalScale(arrowRadius, .8, arrowRadius);
        lineX.mat = lineX.model.material = createMaterial(new pc.Color(1, 0, 0, 0));

        // line y
        var lineY = obj.line.y = new pc.Entity();
        obj.hoverable.push(lineY);
        lineY.axis = 'y';
        lineY.addComponent('model', {
            type: 'cylinder'
        });
        lineY.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        entity.addChild(lineY);
        lineY.setLocalEulerAngles(0, 0, 0);
        lineY.setLocalPosition(0, 1.6, 0);
        lineY.setLocalScale(arrowRadius, .8, arrowRadius);
        lineY.mat = lineY.model.material = createMaterial(new pc.Color(0, 1, 0, 0));

        // line z
        var lineZ = obj.line.z = new pc.Entity();
        obj.hoverable.push(lineZ);
        lineZ.axis = 'z';
        lineZ.addComponent('model', {
            type: 'cylinder'
        });
        lineZ.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        entity.addChild(lineZ);
        lineZ.setLocalEulerAngles(90, 0, 0);
        lineZ.setLocalPosition(0, 0, 1.6);
        lineZ.setLocalScale(arrowRadius, .8, arrowRadius);
        lineZ.mat = lineZ.model.material = createMaterial(new pc.Color(0, 0, 1, 0));

        // arrow x
        var arrowX = obj.arrow.x = new pc.Entity();
        obj.hoverable.push(arrowX);
        arrowX.axis = 'x';
        arrowX.addComponent('model', {
            type: 'cone'
        });
        arrowX.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        entity.addChild(arrowX);
        arrowX.setLocalEulerAngles(90, 90, 0);
        arrowX.setLocalPosition(2.3, 0, 0);
        arrowX.setLocalScale(arrowRadius, .6, arrowRadius);
        arrowX.mat = arrowX.model.material = createMaterial(new pc.Color(1, 0, 0, 1));

        // arrow y
        var arrowY = obj.arrow.y = new pc.Entity();
        obj.hoverable.push(arrowY);
        arrowY.axis = 'y';
        arrowY.addComponent('model', {
            type: 'cone'
        });
        arrowY.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        entity.addChild(arrowY);
        arrowY.setLocalEulerAngles(0, 0, 0);
        arrowY.setLocalPosition(0, 2.3, 0);
        arrowY.setLocalScale(arrowRadius, .6, arrowRadius);
        arrowY.mat = arrowY.model.material = createMaterial(new pc.Color(0, 1, 0, 1));

        // arrow z
        var arrowZ = obj.arrow.z = new pc.Entity();
        obj.hoverable.push(arrowZ);
        arrowZ.axis = 'z';
        arrowZ.addComponent('model', {
            type: 'cone'
        });
        arrowZ.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        entity.addChild(arrowZ);
        arrowZ.setLocalEulerAngles(90, 0, 0);
        arrowZ.setLocalPosition(0, 0, 2.3);
        arrowZ.setLocalScale(arrowRadius, .6, arrowRadius);
        arrowZ.mat = arrowZ.model.material = createMaterial(new pc.Color(0, 0, 1, 1));

        return obj;
    };
});


/* editor/gizmo/gizmo-scale.js */
editor.once('load', function() {
    'use strict';

    var gizmo = null;
    var visible = true;
    var moving = false;
    var mouseTap = null;
    var visible = true;
    var hover = false;
    var hoverAxis = '';
    var hoverMiddle = false;
    var hoverEntity = null;
    var gizmoSize = .4;
    var vecA = new pc.Vec3();
    var vecB = new pc.Vec3();
    var vecC = new pc.Vec3();
    var vecD = new pc.Vec3();
    var quat = new pc.Quat();
    var evtTapStart;
    var evtTapMove;
    var evtTapEnd;
    var pickStart = new pc.Vec3();

    var snap = false;
    var snapIncrement = 1;
    editor.on('gizmo:snap', function(state, increment) {
        snap = state;
        snapIncrement = increment;
    });

    // enable/disable gizmo
    editor.method('gizmo:scale:toggle', function(state) {
        if (! gizmo)
            return;

        if (! editor.call('permissions:write'))
            return;

        gizmo.root.enabled = state;

        visible = true;
    });

    // show/hide gizmo
    editor.method('gizmo:scale:visible', function(state) {
        if (! gizmo)
            return;

        visible = state;

        for(var i = 0; i < gizmo.hoverable.length; i++) {
            if (! gizmo.hoverable[i].model)
                continue;

            gizmo.hoverable[i].model.enabled = state;
        }

        editor.call('viewport:render');
    });

    // position gizmo
    editor.method('gizmo:scale:position', function(x, y, z) {
        gizmo.root.setPosition(x, y, z);

        if (gizmo.root.enabled)
            editor.call('viewport:render');
    });

    // rotate gizmo
    editor.method('gizmo:scale:rotation', function(pitch, yaw, roll) {
        gizmo.root.setEulerAngles(pitch, yaw, roll);

        if (gizmo.root.enabled)
            editor.call('viewport:render');
    });

    // initialize gizmo
    editor.once('viewport:load', function() {
        var app = editor.call('viewport:framework');

        gizmo = createEntity();
        gizmo.root.enabled = false;
        app.root.addChild(gizmo.root);

        // on picker hover
        editor.on('viewport:pick:hover', function(node, picked) {
            var match = gizmo.hoverable.indexOf(node) !== -1;
            if (! hover && match) {
                // hover
                hover = true;
            } else if (hover && ! match) {
                // unhover
                hover = false;
            }

            if (hover) {
                hoverEntity = node;

                if (node.axis && hoverAxis !== node.axis) {
                    // set normal material
                    if (hoverAxis) {
                        if (hoverMiddle) {
                            gizmo.box['x'].model.material = gizmo.box['x'].mat;
                            gizmo.box['y'].model.material = gizmo.box['y'].mat;
                            gizmo.box['z'].model.material = gizmo.box['z'].mat;
                        } else {
                            gizmo.box[hoverAxis].model.material = gizmo.box[hoverAxis].mat;
                        }
                    }

                    if (! hoverAxis && ! evtTapStart)
                        evtTapStart = editor.on('viewport:tap:start', onTapStart);

                    hoverAxis = node.axis;
                    hoverMiddle = node.middle;

                    // set active material
                    if (hoverMiddle) {
                        gizmo.box['x'].model.material = gizmo.matActive;
                        gizmo.box['y'].model.material = gizmo.matActive;
                        gizmo.box['z'].model.material = gizmo.matActive;
                    } else {
                        gizmo.box[hoverAxis].model.material = gizmo.matActive;
                    }
                }
            } else {
                if (hoverAxis) {
                    if (hoverMiddle) {
                        gizmo.box['x'].model.material = gizmo.box['x'].mat;
                        gizmo.box['y'].model.material = gizmo.box['y'].mat;
                        gizmo.box['z'].model.material = gizmo.box['z'].mat;
                    } else {
                        gizmo.box[hoverAxis].model.material = gizmo.box[hoverAxis].mat;
                    }
                }

                hoverAxis = '';

                if (evtTapStart) {
                    evtTapStart.unbind();
                    evtTapStart = null;
                }
            }
        });

        // update gizmo
        editor.on('viewport:postUpdate', function(dt) {
            if (gizmo.root.enabled) {
                editor.emit('gizmo:scale:render', dt);

                if (moving) {
                    var point = pickPlane(mouseTap.x, mouseTap.y);
                    if (point) {
                        point.sub(pickStart);
                        if (snap) {
                            point.scale(1 / snapIncrement);
                            point.x = Math.round(point.x);
                            point.y = Math.round(point.y);
                            point.z = Math.round(point.z);
                            point.scale(snapIncrement);
                        }
                        editor.emit('gizmo:scale:offset', point.x, point.y, point.z);
                    }
                }

                var camera = app.activeCamera;

                var posCamera = camera.getPosition();
                var posGizmo = gizmo.root.getPosition();
                var scale = 1;

                // scale to screen space
                if (camera.camera.projection === pc.PROJECTION_PERSPECTIVE) {
                    var dot = vecA.copy(posGizmo).sub(posCamera).dot(camera.forward);
                    var denom = 1280 * Math.tan(camera.camera.fov * pc.math.DEG_TO_RAD);
                    scale = Math.max(0.0001, (dot / denom) * 150) * gizmoSize;
                } else {
                    scale = camera.camera.orthoHeight / 3 * gizmoSize;
                }
                gizmo.root.setLocalScale(scale, scale, scale);

                // calculate viewing angle
                vecA
                .copy(posCamera)
                .sub(posGizmo)
                .normalize();

                // rotate vector by gizmo rotation
                quat
                .copy(gizmo.root.getRotation())
                .invert()
                .transformVector(vecA, vecA);

                quat.invert();

                // hide lines and boxes if viewed from very angle
                gizmo.line.x.model.enabled = gizmo.box.x.model.enabled = ! (Math.abs(vecA.z) <= 0.15 && Math.abs(vecA.y) <= 0.15) && visible;
                gizmo.line.y.model.enabled = gizmo.box.y.model.enabled = ! (Math.abs(vecA.x) <= 0.15 && Math.abs(vecA.z) <= 0.15) && visible;
                gizmo.line.z.model.enabled = gizmo.box.z.model.enabled = ! (Math.abs(vecA.x) <= 0.15 && Math.abs(vecA.y) <= 0.15) && visible;

                // draw axes lines
                // line x
                if (gizmo.line.x.model.enabled) {
                    vecB.set(scale * .5, 0, 0);
                    quat.transformVector(vecB, vecB).add(posGizmo);
                    vecC.set(scale * 2, 0, 0);
                    quat.transformVector(vecC, vecC).add(posGizmo);
                    app.renderLine(vecB, vecC, gizmo.box.x.model.material === gizmo.matActive ? gizmo.matActive.color : gizmo.box.x.color, pc.LINEBATCH_GIZMO);
                }
                // line y
                if (gizmo.line.y.model.enabled) {
                    vecB.set(0, scale * .5, 0);
                    quat.transformVector(vecB, vecB).add(posGizmo);
                    vecC.set(0, scale * 2, 0);
                    quat.transformVector(vecC, vecC).add(posGizmo);
                    app.renderLine(vecB, vecC, gizmo.box.y.model.material === gizmo.matActive ? gizmo.matActive.color : gizmo.box.y.color, pc.LINEBATCH_GIZMO);
                }
                // line z
                if (gizmo.line.z.model.enabled) {
                    vecB.set(0, 0, scale * .5);
                    quat.transformVector(vecB, vecB).add(posGizmo);
                    vecC.set(0, 0, scale * 2);
                    quat.transformVector(vecC, vecC).add(posGizmo);
                    app.renderLine(vecB, vecC, gizmo.box.z.model.material === gizmo.matActive ? gizmo.matActive.color : gizmo.box.z.color, pc.LINEBATCH_GIZMO);
                }
            }
        });

        var pickPlane = function(x, y) {
            var camera = app.activeCamera;
            var scale = 1;
            var mouseWPos = camera.camera.screenToWorld(x, y, 1);
            var posCamera = camera.getPosition();
            var posGizmo = gizmo.root.getPosition();
            var mouseDir = vecA.copy(mouseWPos).sub(posCamera).normalize();

            if (camera.camera.projection === pc.PROJECTION_PERSPECTIVE) {
                var dot = vecC.copy(posGizmo).sub(posCamera).dot(camera.forward);
                var denom = 1280 * Math.tan(camera.camera.fov * pc.math.DEG_TO_RAD);
                scale = Math.max(0.0001, (dot / denom) * 150) * gizmoSize;
            } else {
                scale = camera.camera.orthoHeight / 3 * gizmoSize;
            }

            quat.copy(gizmo.root.getRotation())

            // single axis
            if (! hoverMiddle) {
                // vector based on selected axis
                vecB.set(0, 0, 0);
                vecB[hoverAxis] = 1;
                // rotate vector by gizmo rotation
                quat.transformVector(vecB, vecB);

                vecC
                .copy(posCamera)
                .sub(posGizmo)
                .normalize();
                vecB.copy(vecC.sub(vecB.scale(vecB.dot(vecC))).normalize());
            } else {
                vecB
                .copy(posCamera)
                .sub(posGizmo)
                .normalize();
            }

            var rayPlaneDot = vecB.dot(mouseDir);
            var planeDist = posGizmo.dot(vecB);
            var pointPlaneDist = (vecB.dot(posCamera) - planeDist) / rayPlaneDot;
            var pickedPos = mouseDir.scale(-pointPlaneDist).add(posCamera);

            if (! hoverMiddle) {
                // single axis
                vecB.set(0, 0, 0);
                vecB[hoverAxis] = 1;
                quat.transformVector(vecB, vecB);
                pickedPos.copy(vecB.scale(vecB.dot(pickedPos)));
                quat.invert().transformVector(pickedPos, pickedPos);

                // calculate viewing angle
                vecC
                .copy(posCamera)
                .sub(posGizmo)
                .normalize();
                quat.transformVector(vecC, vecC);

                var v = pickedPos[hoverAxis];
                pickedPos.set(0, 0, 0);
                pickedPos[hoverAxis] = v / scale;
            } else {
                vecC.copy(pickedPos).sub(posGizmo).normalize();
                vecD.copy(camera.up).add(camera.right).normalize();

                var v = (pickedPos.sub(posGizmo).length() / scale / 2)  * vecC.dot(vecD);
                pickedPos.set(v, v, v);
            }

            return pickedPos;
        };

        var onTapStart = function(tap) {
            editor.emit('camera:toggle', false);

            moving = true;
            mouseTap = tap;

            if (gizmo.root.enabled) {
                pickStart.copy(pickPlane(tap.x, tap.y));
                pickStart.x -= 1;
                pickStart.y -= 1;
                pickStart.z -= 1;
            }

            editor.emit('gizmo:scale:start', hoverAxis, hoverMiddle);
            editor.call('gizmo:scale:visible', false);
        };

        var onTapMove = function(tap) {
            if (! moving)
                return;

            mouseTap = tap;
        };

        var onTapEnd = function(tap) {
            editor.emit('camera:toggle', true);

            if (! moving)
                return;

            moving = false;
            mouseTap = tap;

            editor.emit('gizmo:scale:end');
            editor.call('gizmo:scale:visible', true);
        };

        editor.on('viewport:hover', function(state) {
            if (state || ! moving)
                return;

            moving = false;

            editor.emit('gizmo:scale:end');
            editor.call('gizmo:scale:visible', true);
        });

        evtTapMove = editor.on('viewport:tap:move', onTapMove);
        evtTapEnd = editor.on('viewport:tap:end', onTapEnd);
    });

    var createMaterial = function(color) {
        var mat = new pc.BasicMaterial();
        mat.color = color;
        if (color.a !== 1) {
            mat.blend = true;
            mat.blendSrc = pc.BLENDMODE_SRC_ALPHA;
            mat.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
        }
        mat.cull = pc.CULLFACE_NONE;
        mat.update();
        return mat;
    };

    var createEntity = function() {
        var boxSize = .4;

        var obj = {
            root: null,
            middle: null,
            line: {
                x: null,
                y: null,
                z: null
            },
            box: {
                x: null,
                y: null,
                z: null
            },
            hoverable: [ ],
            matActive: null,
            matActiveTransparent: null
        };

        // active mat
        obj.matActive = createMaterial(new pc.Color(1, 1, 1, 1));
        obj.matActiveTransparent = createMaterial(new pc.Color(1, 1, 1, .25));
        obj.colorLineBehind = new pc.Color(1, 1, 1, 0.05);
        obj.colorLine = new pc.Color(1, 1, 1, .2);
        obj.colorLineActive = new pc.Color(1, 1, 1, 1);

        // root entity
        var entity = obj.root = new pc.Entity();

        // middle
        var middle = obj.middle = new pc.Entity();
        obj.hoverable.push(middle);
        middle.axis = 'xyz';
        middle.middle = true;
        middle.addComponent('model', {
            type: 'box'
        });
        middle.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        middle.model.material.id = 0xFFFFFFFF;
        entity.addChild(middle);
        middle.setLocalScale(boxSize * 1.5, boxSize * 1.5, boxSize * 1.5);
        middle.mat = middle.model.material = createMaterial(new pc.Color(1, 1, 1, 0.2));
        middle.mat.depthTest = false;

        // line x
        var lineX = obj.line.x = new pc.Entity();
        obj.hoverable.push(lineX);
        lineX.axis = 'x';
        lineX.addComponent('model', {
            type: 'cylinder'
        });
        lineX.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        entity.addChild(lineX);
        lineX.setLocalEulerAngles(90, 90, 0);
        lineX.setLocalPosition(1.25, 0, 0);
        lineX.setLocalScale(boxSize, 1.5, boxSize);
        lineX.mat = lineX.model.material = createMaterial(new pc.Color(1, 0, 0, 0));

        // line y
        var lineY = obj.line.y = new pc.Entity();
        obj.hoverable.push(lineY);
        lineY.axis = 'y';
        lineY.addComponent('model', {
            type: 'cylinder'
        });
        lineY.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        entity.addChild(lineY);
        lineY.setLocalEulerAngles(0, 0, 0);
        lineY.setLocalPosition(0, 1.25, 0);
        lineY.setLocalScale(boxSize, 1.5, boxSize);
        lineY.mat = lineY.model.material = createMaterial(new pc.Color(0, 1, 0, 0));

        // line z
        var lineZ = obj.line.z = new pc.Entity();
        obj.hoverable.push(lineZ);
        lineZ.axis = 'z';
        lineZ.addComponent('model', {
            type: 'cylinder'
        });
        lineZ.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        entity.addChild(lineZ);
        lineZ.setLocalEulerAngles(90, 0, 0);
        lineZ.setLocalPosition(0, 0, 1.25);
        lineZ.setLocalScale(boxSize, 1.5, boxSize);
        lineZ.mat = lineZ.model.material = createMaterial(new pc.Color(0, 0, 1, 0));

        // box x
        var boxX = obj.box.x = new pc.Entity();
        obj.hoverable.push(boxX);
        boxX.axis = 'x';
        boxX.addComponent('model', {
            type: 'box'
        });
        boxX.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        entity.addChild(boxX);
        boxX.setLocalPosition(2.2, 0, 0);
        boxX.setLocalScale(boxSize, boxSize, boxSize);
        boxX.mat = boxX.model.material = createMaterial(new pc.Color(1, 0, 0, 1.1));
        boxX.color = new pc.Color(1, 0, 0, 1);

        // box y
        var boxY = obj.box.y = new pc.Entity();
        obj.hoverable.push(boxY);
        boxY.axis = 'y';
        boxY.addComponent('model', {
            type: 'box'
        });
        boxY.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        entity.addChild(boxY);
        boxY.setLocalPosition(0, 2.2, 0);
        boxY.setLocalScale(boxSize, boxSize, boxSize);
        boxY.mat = boxY.model.material = createMaterial(new pc.Color(0, 1, 0, 1.1));
        boxY.color = new pc.Color(0, 1, 0, 1);

        // box z
        var boxZ = obj.box.z = new pc.Entity();
        obj.hoverable.push(boxZ);
        boxZ.axis = 'z';
        boxZ.addComponent('model', {
            type: 'box'
        });
        boxZ.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        entity.addChild(boxZ);
        boxZ.setLocalPosition(0, 0, 2.2);
        boxZ.setLocalScale(boxSize, boxSize, boxSize);
        boxZ.mat = boxZ.model.material = createMaterial(new pc.Color(0, 0, 1, 1.1));
        boxZ.color = new pc.Color(0, 0, 1, 1);

        return obj;
    };
});


/* editor/gizmo/gizmo-rotate.js */
editor.once('load', function() {
    'use strict';

    var gizmo = null;
    var visible = true;
    var moving = false;
    var mouseTap = null;
    var mouseTapMoved = false;
    var posCameraLast = new pc.Vec3();
    var visible = true;
    var hover = false;
    var hoverAxis = '';
    var hoverEntity = null;
    var gizmoSize = .4;
    var arrowRadius = .4;
    var vecA = new pc.Vec3();
    var vecB = new pc.Vec3();
    var vecC = new pc.Vec3();
    var vecD = new pc.Vec3();
    var quat = new pc.Quat();
    var evtTapStart;
    var evtTapMove;
    var evtTapEnd;
    var angleStart = 0;
    var startRotation = new pc.Quat();

    var snap = false;
    var snapIncrement = 5;
    editor.on('gizmo:snap', function(state, increment) {
        snap = state;
        snapIncrement = increment * 5;
    });

    // enable/disable gizmo
    editor.method('gizmo:rotate:toggle', function(state) {
        if (! gizmo)
            return;

        if (! editor.call('permissions:write'))
            return;

        gizmo.root.enabled = state;

        visible = true;

        editor.call('viewport:render');
    });

    // show/hide gizmo
    editor.method('gizmo:rotate:visible', function(state) {
        if (! gizmo)
            return;

        visible = state;

        for(var i = 0; i < gizmo.hoverable.length; i++) {
            if (! gizmo.hoverable[i].model)
                continue;

            gizmo.hoverable[i].model.enabled = state;
        }

        editor.call('viewport:render');
    });

    // position gizmo
    editor.method('gizmo:rotate:position', function(x, y, z) {
        if (x === undefined)
            return gizmo.root.getPosition();

        gizmo.root.setPosition(x, y, z);

        if (gizmo.root.enabled)
            editor.call('viewport:render');
    });

    // rotate gizmo
    editor.method('gizmo:rotate:rotation', function(pitch, yaw, roll) {
        gizmo.root.setEulerAngles(pitch, yaw, roll);

        if (gizmo.root.enabled)
            editor.call('viewport:render');
    });

    // initialize gizmo
    editor.once('viewport:load', function() {
        var app = editor.call('viewport:framework');

        gizmo = createEntity(app);
        gizmo.root.enabled = false;
        app.root.addChild(gizmo.root);

        // on picker hover
        editor.on('viewport:pick:hover', function(node, picked) {
            var match = gizmo.hoverable.indexOf(node) !== -1;
            if (! hover && match) {
                // hover
                hover = true;
            } else if (hover && ! match) {
                // unhover
                hover = false;
            }

            if (hover) {
                hoverEntity = node;

                if (node.axis && hoverAxis !== node.axis) {
                    // set normal material
                    if (hoverAxis)
                        gizmo.line[hoverAxis].material = gizmo.line[hoverAxis].mat;

                    if (! hoverAxis && ! evtTapStart)
                        evtTapStart = editor.on('viewport:tap:start', onTapStart);

                    hoverAxis = node.axis;

                    // set active material
                    gizmo.line[hoverAxis].material = gizmo.matActive;
                }
            } else {
                if (hoverAxis) {
                    gizmo.line[hoverAxis].material = gizmo.line[hoverAxis].mat;
                }

                hoverAxis = '';

                if (evtTapStart) {
                    evtTapStart.unbind();
                    evtTapStart = null;
                }
            }
        });

        var lastPoint = new pc.Vec3();

        // update gizmo
        editor.on('viewport:postUpdate', function(dt) {
            if (gizmo.root.enabled) {
                var camera = app.activeCamera;
                var posCamera = camera.getPosition();

                if (moving && (vecA.copy(posCameraLast).sub(posCamera).length() > 0.01 || mouseTapMoved)) {
                    var data = pickPlane(mouseTap.x, mouseTap.y);
                    lastPoint.copy(data.point);

                    if (snap) {
                        data.angle = Math.round((data.angle - angleStart) / snapIncrement) * snapIncrement;
                    } else {
                        data.angle -= angleStart;
                    }

                    editor.emit('gizmo:rotate:offset', data.angle, data.point);
                }

                var posGizmo = gizmo.root.getPosition();
                var scale = 1;

                // scale to screen space
                if (camera.camera.projection === pc.PROJECTION_PERSPECTIVE) {
                    var dot = vecA.copy(posGizmo).sub(posCamera).dot(camera.forward);
                    var denom = 1280 * Math.tan(camera.camera.fov * pc.math.DEG_TO_RAD);
                    scale = Math.max(0.0001, (dot / denom) * 150) * gizmoSize;
                } else {
                    scale = camera.camera.orthoHeight / 3 * gizmoSize;
                }
                gizmo.root.setLocalScale(scale, scale, scale);

                if (moving && lastPoint) {
                    vecC.copy(lastPoint).normalize().scale(2 * scale);
                    quat.copy(startRotation).transformVector(vecC, vecC);
                    // quat.invert().transformVector(vecC, vecC);
                    vecC.add(posGizmo);

                    app.renderLine(posGizmo, vecC, gizmo.colorActive, pc.LINEBATCH_GIZMO);
                }

                editor.emit('gizmo:rotate:render', dt);

                posCameraLast.copy(posCamera);

                // posGizmo = gizmo.root.getPosition();

                // calculate viewing angle
                vecA
                .copy(posCamera)
                .sub(posGizmo)
                .normalize();

                // rotate vector by gizmo rotation
                quat
                .copy(gizmo.root.getRotation())
                .invert()
                .transformVector(vecA, vecA);

                // hide plane if viewed from very angle
                gizmo.plane.x.model.enabled = Math.abs(vecA.x) > 0.15 && visible;
                gizmo.plane.y.model.enabled = Math.abs(vecA.y) > 0.15 && visible;
                gizmo.plane.z.model.enabled = Math.abs(vecA.z) > 0.15 && visible;

                var worldTransform = gizmo.root.getWorldTransform();

                // render lines
                // x
                if (moving && hoverAxis === 'x') {
                    // behind line
                    app.renderMesh(gizmo.line.x.mesh, gizmo.matBehindActive, worldTransform);
                } else {
                    // behind line
                    app.renderMesh(gizmo.line.x.mesh, gizmo.matBehindHover.x, worldTransform);
                    // front line
                    if (! moving && gizmo.plane.x.model.enabled) {
                        gizmo.line.x.node.worldTransform = worldTransform;
                        app.renderMeshInstance(gizmo.line.x);
                    }
                }
                // y
                if (moving && hoverAxis === 'y') {
                    // behind line
                    app.renderMesh(gizmo.line.y.mesh, gizmo.matBehindActive, worldTransform);
                } else {
                    // behind line
                    app.renderMesh(gizmo.line.y.mesh, gizmo.matBehindHover.y, worldTransform);
                    // front line
                    if (! moving && gizmo.plane.y.model.enabled) {
                        gizmo.line.y.node.worldTransform = worldTransform;
                        app.renderMeshInstance(gizmo.line.y);
                    }
                }
                // z
                if (moving && hoverAxis === 'z') {
                    // behind line
                    app.renderMesh(gizmo.line.z.mesh, gizmo.matBehindActive, worldTransform);
                } else {
                    // behind line
                    app.renderMesh(gizmo.line.z.mesh, gizmo.matBehindHover.z, worldTransform);
                    // front line
                    if (! moving && gizmo.plane.z.model.enabled) {
                        gizmo.line.z.node.worldTransform = worldTransform;
                        app.renderMeshInstance(gizmo.line.z);
                    }
                }

                // cull
                gizmo.line.cull.node.worldTransform = worldTransform;
                app.renderMeshInstance(gizmo.line.cull);
            }

            mouseTapMoved = false
        });

        var pickPlane = function(x, y) {
            var camera = app.activeCamera;

            var posCamera = camera.getPosition();
            var posGizmo = gizmo.root.getPosition();

            // ray from camera
            vecA
            .copy(camera.camera.screenToWorld(x, y, 1))
            .sub(posCamera)
            .normalize();

            // plane nomral based on selected axis
            vecB.set(0, 0, 0);
            vecB[hoverAxis] = 1;

            // rotate plane to local space
            quat
            .copy(startRotation)
            .transformVector(vecB, vecB);

            // pick the plane
            vecA
            .scale(-((vecB.dot(posCamera) - posGizmo.dot(vecB)) / vecB.dot(vecA)))
            .add(posCamera)
            .sub(posGizmo) // convert picked point to vector
            .normalize();

            // rotate vector to world space
            quat
            .invert()
            .transformVector(vecA, vecA);

            var angle = 0;
            if (hoverAxis === 'x') {
                angle = Math.atan2(vecA.z, vecA.y) / (Math.PI / 180);
            } else if (hoverAxis === 'y') {
                angle = Math.atan2(vecA.x, vecA.z) / (Math.PI / 180);
            } else if (hoverAxis === 'z') {
                angle = Math.atan2(vecA.y, vecA.x) / (Math.PI / 180);
            }

            return {
                angle: angle,
                point: vecA
            };
        };

        var onTapStart = function(tap) {
            if (moving)
                return;

            editor.emit('camera:toggle', false);

            moving = true;
            mouseTap = tap;
            mouseTapMoved = true;

            if (gizmo.root.enabled) {
                startRotation.copy(gizmo.root.getRotation());
                var data = pickPlane(tap.x, tap.y);
                angleStart = data.angle;
            }

            editor.emit('gizmo:rotate:start', hoverAxis);
        };

        var onTapMove = function(tap) {
            if (! moving)
                return;

            mouseTap = tap;
            mouseTapMoved = true;
        };

        var onTapEnd = function(tap) {
            editor.emit('camera:toggle', true);

            if (! moving)
                return;

            moving = false;
            mouseTap = tap;

            editor.emit('gizmo:rotate:end');
        };

        editor.on('viewport:hover', function(state) {
            if (state || ! moving)
                return;

            moving = false;

            editor.emit('gizmo:rotate:end');
            editor.call('gizmo:rotate:visible', true);
        });

        evtTapMove = editor.on('viewport:tap:move', onTapMove);
        evtTapEnd = editor.on('viewport:tap:end', onTapEnd);
    });

    var createMaterial = function(color) {
        var mat = new pc.BasicMaterial();
        mat.color = color;
        if (color.a !== 1) {
            mat.blend = true;
            mat.blendSrc = pc.BLENDMODE_SRC_ALPHA;
            mat.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
        }
        mat.update();
        return mat;
    };

    var createEntity = function(app) {
        var obj = {
            root: null,
            sphere: null,
            plane: {
                x: null,
                y: null,
                z: null
            },
            line: {
                x: null,
                y: null,
                z: null,
                cull: null
            },
            hoverable: [ ],
            matActive: null,
            matBehind: null,
            matBehindHover: { },
            matBehindActive: null
        };

        // materials
        obj.matBehind = createMaterial(new pc.Color(1, 1, 1, .1));
        obj.matBehind.depthTest = false;
        obj.matBehindHover.x = createMaterial(new pc.Color(1, 0, 0, .2));
        obj.matBehindHover.y = createMaterial(new pc.Color(0, 1, 0, .2));
        obj.matBehindHover.z = createMaterial(new pc.Color(0, 0, 1, .2));
        obj.matBehindHover.x.depthTest = false;
        obj.matBehindHover.y.depthTest = false;
        obj.matBehindHover.z.depthTest = false;
        obj.matBehindActive = createMaterial(new pc.Color(1, 1, 1, 1.1));
        obj.matBehindActive.depthTest = false;
        obj.colorActive = new pc.Color(1, 1, 1, 1);

        // root entity
        var entity = obj.root = new pc.Entity();

        // plane x
        var planeX = obj.plane.x = new pc.Entity();
        obj.hoverable.push(planeX);
        planeX.axis = 'x';
        planeX.plane = true;
        planeX.addComponent('model', {
            type: 'cylinder'
        });
        planeX.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        entity.addChild(planeX);
        planeX.setLocalEulerAngles(90, -90, 0);
        planeX.setLocalScale(4.1, 0.3, 4.1);
        planeX.mat = planeX.model.material = createMaterial(new pc.Color(1, 0, 0, 0));

        // plane y
        var planeY = obj.plane.y = new pc.Entity();
        obj.hoverable.push(planeY);
        planeY.axis = 'y';
        planeY.plane = true;
        planeY.addComponent('model', {
            type: 'cylinder'
        });
        planeY.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        entity.addChild(planeY);
        planeY.setLocalEulerAngles(0, 0, 0);
        planeY.setLocalScale(4.2, 0.3, 4.2);
        planeY.mat = planeY.model.material = createMaterial(new pc.Color(0, 1, 0, 0));

        // plane z
        var planeZ = obj.plane.z = new pc.Entity();
        obj.hoverable.push(planeZ);
        planeZ.axis = 'z';
        planeZ.plane = true;
        planeZ.addComponent('model', {
            type: 'cylinder'
        });
        planeZ.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        entity.addChild(planeZ);
        planeZ.setLocalEulerAngles(90, 0, 0);
        planeZ.setLocalScale(4, 0.3, 4);
        planeZ.mat = planeZ.model.material = createMaterial(new pc.Color(0, 0, 1, 0));

        // sphere
        var sphere = obj.sphere = new pc.Entity();
        sphere.addComponent('model', {
            type: 'sphere'
        });
        sphere.model.model.meshInstances[0].layer = pc.LAYER_GIZMO;
        entity.addChild(sphere);
        sphere.setLocalScale(3, 3, 3);
        sphere.mat = sphere.model.material = createMaterial(new pc.Color(1, 1, 1, 0));

        obj.matActive = createMaterial(new pc.Color(1, 1, 1, 1.1));

        var lines = createLinesModel(app);
        obj.line.x = lines[0];
        obj.line.y = lines[1];
        obj.line.z = lines[2];
        obj.line.cull = lines[3];

        return obj;
    };

    var createMeshInstance = function (node, mesh, material) {
        var result = new pc.MeshInstance(node, mesh, material);
        result.layer = pc.LAYER_GIZMO;
        result.updateKey();
        return result;
    };

    var createLinesModel = function(app) {
        // Create the rotate gizmo geometry
        var device = app.graphicsDevice;
        var axisSegments = 50;
        var numVerts = (axisSegments + 1);
        var angle = 0.0;
        var iterator;
        var sinAngle, cosAngle;
        var scale = 2;

        var vertexFormat = new pc.gfx.VertexFormat(app.graphicsDevice, [
            { semantic: pc.gfx.SEMANTIC_POSITION, components: 3, type: pc.gfx.ELEMENTTYPE_FLOAT32 }
        ]);

        var vertexBuffers = [];
        for (var axis = 0; axis < 3; axis++) {
            // Create a vertex buffer
            vertexBuffers.push(new pc.gfx.VertexBuffer(device, vertexFormat, numVerts));

            // Fill the vertex buffer
            iterator = new pc.gfx.VertexIterator(vertexBuffers[axis]);
            for (var seg = 0; seg <= axisSegments; seg++) {
                angle = 2 * Math.PI * (seg / axisSegments);
                sinAngle = Math.sin(angle);
                cosAngle = Math.cos(angle);
                if (axis === 0) {
                    iterator.element[pc.SEMANTIC_POSITION].set(0, sinAngle * scale, cosAngle * scale);
                } else if (axis === 1) {
                    iterator.element[pc.SEMANTIC_POSITION].set(sinAngle * scale, 0, cosAngle * scale);
                } else if (axis === 2) {
                    iterator.element[pc.SEMANTIC_POSITION].set(sinAngle * scale, cosAngle * scale, 0);
                }
                iterator.next();
            }
            iterator.end();
        }

        var node = new pc.GraphNode();
        var mesh, meshInstance;

        var meshInstances = [ ];
        var materials = [
            createMaterial(new pc.Color(1, 0, 0, 1.1)),
            createMaterial(new pc.Color(0, 1, 0, 1.1)),
            createMaterial(new pc.Color(0, 0, 1, 1.1))
        ];

        for (var i = 0; i < 3; i++) {
            mesh = new pc.Mesh();
            mesh.vertexBuffer = vertexBuffers[i];
            mesh.indexBuffer[0] = null;
            mesh.primitive[0].type = pc.PRIMITIVE_LINESTRIP;
            mesh.primitive[0].base = 0;
            mesh.primitive[0].count = vertexBuffers[i].getNumVertices();
            mesh.primitive[0].indexed = false;

            meshInstance = createMeshInstance(node, mesh, materials[i]);
            meshInstance.mat = materials[i];
            meshInstances.push(meshInstance);
        }

        mesh = pc.createSphere(device, {
            segments: 75,
            radius: 1.95
        });
        var material = createMaterial(new pc.Color(1, 1, 1, 0));
        material.update();
        meshInstance = createMeshInstance(node, mesh, material);
        meshInstances.push(meshInstance);

        return meshInstances;
    };
});


/* editor/gizmo/gizmo-camera.js */
editor.once('load', function () {
    'use strict';

    var app;
    // selected entity gizmos
    var entities = { };
    // pool of gizmos
    var pool = [ ];
    // colors
    var colorBehind = new pc.Color(1, 1, 1, .15);
    var colorPrimary = new pc.Color(1, 1, 1);

    // gizmo class
    function Gizmo() {
        this._link = null;
        this.lines = [ ];
        this.events = [ ];
        this.visible = false;

        for(var i = 0; i < 24; i++)
            this.lines.push(new pc.Vec3());
    }
    // update lines
    Gizmo.prototype.update = function() {
        if (! this._link || app.activeCamera === this._link.entity) {
            this.visible = false;
            return;
        }

        var camera = this._link.entity.camera;

        this.visible = this._link.entity.enabled && camera && camera.enabled && app.activeCamera !== this._link.entity;
        if (! this.visible)
            return;

        var nearClip = camera.nearClip;
        var farClip = camera.farClip;
        var fov = camera.fov * Math.PI / 180.0;
        var projection = camera.projection;

        var device = app.graphicsDevice;
        var rect = camera.rect;
        var aspectRatio = (device.width * rect.z) / (device.height * rect.w);

        var nx, ny, fx, fy;
        if (projection === pc.PROJECTION_PERSPECTIVE) {
            ny = Math.tan(fov / 2.0) * nearClip;
            fy = Math.tan(fov / 2.0) * farClip;
            nx = ny * aspectRatio;
            fx = fy * aspectRatio;
        } else {
            ny = camera.camera.getOrthoHeight();
            fy = ny;
            nx = ny * aspectRatio;
            fx = nx;
        }

        // near plane
        this.lines[0].set(nx, -ny, -nearClip);
        this.lines[1].set(nx, ny, -nearClip);
        this.lines[2].set(nx, ny, -nearClip);
        this.lines[3].set(-nx, ny, -nearClip);
        this.lines[4].set(-nx, ny, -nearClip);
        this.lines[5].set(-nx, -ny, -nearClip);
        this.lines[6].set(-nx, -ny, -nearClip);
        this.lines[7].set(nx, -ny, -nearClip);
        // far plane
        this.lines[8].set(fx, -fy, -farClip);
        this.lines[9].set(fx, fy, -farClip);
        this.lines[10].set(fx, fy, -farClip);
        this.lines[11].set(-fx, fy, -farClip);
        this.lines[12].set(-fx, fy, -farClip);
        this.lines[13].set(-fx, -fy, -farClip);
        this.lines[14].set(-fx, -fy, -farClip);
        this.lines[15].set(fx, -fy, -farClip);
        // parallel lines
        this.lines[16].set(nx, -ny, -nearClip);
        this.lines[17].set(fx, -fy, -farClip);
        this.lines[18].set(nx, ny, -nearClip);
        this.lines[19].set(fx, fy, -farClip);
        this.lines[20].set(-nx, ny, -nearClip);
        this.lines[21].set(-fx, fy, -farClip);
        this.lines[22].set(-nx, -ny, -nearClip);
        this.lines[23].set(-fx, -fy, -farClip);

        // transform lines according to camera transform
        var wtm = new pc.Mat4().setTRS(this._link.entity.getPosition(), this._link.entity.getRotation(), pc.Vec3.ONE);
        for(var i = 0; i < this.lines.length; i++)
            wtm.transformPoint(this.lines[i], this.lines[i]);

        this.visible = true;
    };
    // render lines
    Gizmo.prototype.render = function() {
        if (! this.visible)
            return;

        app.renderLines(this.lines, colorBehind, pc.LINEBATCH_GIZMO);
        app.renderLines(this.lines, colorPrimary, pc.LINEBATCH_WORLD);
    };
    // link to entity
    Gizmo.prototype.link = function(obj) {
        this.unlink();
        this._link = obj;

        var self = this;

        this.events.push(this._link.once('destroy', function() {
            self.unlink();
        }));
    };
    // unlink
    Gizmo.prototype.unlink = function() {
        if (! this._link)
            return;

        for(var i = 0; i < this.events.length; i++)
            this.events[i].unbind();

        this.events = [ ];
        this._link = null;
        this.visible = false;
    };

    editor.on('selector:change', function(type, items) {
        // clear gizmos
        if (type !== 'entity') {
            for(var key in entities) {
                entities[key].unlink();
                pool.push(entities[key]);
            }
            entities = { };
            return;
        }

        // index selection
        var ids = { };
        for(var i = 0; i < items.length; i++)
            ids[items[i].get('resource_id')] = items[i];

        var render = false;

        // remove
        for(var key in entities) {
            if (ids[key])
                continue;

            pool.push(entities[key]);
            entities[key].unlink();
            delete entities[key];
            render = true;
        }

        // add
        for(var key in ids) {
            if (entities[key])
                continue;

            var gizmo = pool.shift();
            if (! gizmo)
                gizmo = new Gizmo();

            gizmo.link(ids[key]);
            entities[key] = gizmo;
            render = true;
        }

        if (render)
            editor.call('viewport:render');
    });

    editor.once('viewport:load', function() {
        app = editor.call('viewport:framework');
    });

    editor.on('viewport:gizmoUpdate', function(dt) {
        for(var key in entities) {
            entities[key].update();
            entities[key].render();
        }
    });
});


/* editor/gizmo/gizmo-light.js */
editor.once('load', function () {
    'use strict';

    var app;
    // selected entity gizmos
    var entities = { };
    // pool of gizmos
    var pool = [ ];
    // colors
    var colorBehind = new pc.Color(1, 1, 1, .15);
    var colorPrimary = new pc.Color(1, 1, 1);
    var container;
    var vec = new pc.Vec3();
    var materialBehind = new pc.BasicMaterial();
    materialBehind.color = colorBehind;
    materialBehind.blend = true;
    materialBehind.blendSrc = pc.BLENDMODE_SRC_ALPHA;
    materialBehind.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
    materialBehind.depthTest = false;
    materialBehind.update();
    var materialSpot, materialSpotBehind;
    var models = { };
    var poolModels = { 'directional': [ ], 'point': [ ], 'point-close': [ ], 'spot': [ ] };

    // gizmo class
    function Gizmo() {
        this._link = null;
        this.lines = [ ];
        this.events = [ ];
        this.type = '';
        this.entity = null;
    }
    // update lines
    Gizmo.prototype.update = function() {
        if (! this._link)
            return;

        var light = this._link.entity.light;
        this.entity.enabled = this._link.entity.enabled && light && light.enabled;
        if (! this.entity.enabled)
            return;

        this.entity.setPosition(this._link.entity.getPosition());

        var type = light.type;

        // close point light, switch to triple circle
        if (type === 'point' && vec.copy(this.entity.getPosition()).sub(app.activeCamera.getPosition()).length() < light.range)
            type += '-close';

        if (this.type !== type) {
            this.type = type;

            // set new model based on type
            if (models[this.type]) {
                // get current model
                var model = this.entity.model.model;
                if (model) {
                    // put back in pool
                    app.scene.removeModel(model);
                    this.entity.removeChild(model.getGraph());
                    poolModels[model._type].push(model);
                }
                // get from pool
                model = poolModels[this.type].shift();
                if (! model) {
                    // no in pool
                    model = models[this.type].clone();
                    model._type = this.type;
                }
                // set to model
                this.entity.model.model = model;
                this.entity.setLocalScale(1, 1, 1);
                this.entity.setEulerAngles(0, 0, 0);
            } else {
                this.entity.model.model = null;
                this.entity.enabled = false;
                return;
            }
        }

        var material = materialBehind;

        switch(this.type) {
            case 'directional':
                this.entity.setRotation(this._link.entity.getRotation());
                break;
            case 'point':
                this.entity.setLocalScale(light.range, light.range, light.range);
                this.entity.lookAt(app.activeCamera.getPosition());
                break;
            case 'point-close':
                this.entity.setLocalScale(light.range, light.range, light.range);
                break;
            case 'spot':
                this.entity.setRotation(this._link.entity.getRotation());
                this.entity.model.model.meshInstances[0].setParameter('range', light.range);
                this.entity.model.model.meshInstances[0].setParameter('innerAngle', light.innerConeAngle);
                this.entity.model.model.meshInstances[0].setParameter('outerAngle', light.outerConeAngle);
                material = materialSpotBehind;
                break;
        }

        // render behind model
        if (this.entity.enabled && this.entity.model.model) {
            var instance = new pc.MeshInstance(this.entity, this.entity.model.model.meshInstances[0].mesh, material);
            if (this.type === 'spot') {
                instance.layer = pc.LAYER_GIZMO;
                instance.setParameter('range', light.range);
                instance.setParameter('innerAngle', light.innerConeAngle);
                instance.setParameter('outerAngle', light.outerConeAngle);
            }
            app.scene.immediateDrawCalls.push(instance);
        }
    };
    // link to entity
    Gizmo.prototype.link = function(obj) {
        this.unlink();
        this._link = obj;

        var self = this;

        this.events.push(this._link.once('destroy', function() {
            self.unlink();
        }));

        this.entity = new pc.Entity();
        this.entity.addComponent('model');

        container.addChild(this.entity);
    };
    // unlink
    Gizmo.prototype.unlink = function() {
        if (! this._link)
            return;

        for(var i = 0; i < this.events.length; i++)
            this.events[i].unbind();

        this.events = [ ];
        this._link = null;
        this.type = '';

        var model = this.entity.model.model;
        if (model) {
            // put back in pool
            app.scene.removeModel(model);
            this.entity.removeChild(model.getGraph());
            poolModels[model._type].push(model);
        }

        this.entity.destroy();
    };

    editor.on('selector:change', function(type, items) {
        // clear gizmos
        if (type !== 'entity') {
            for(var key in entities) {
                entities[key].unlink();
                pool.push(entities[key]);
            }
            entities = { };
            return;
        }

        // index selection
        var ids = { };
        for(var i = 0; i < items.length; i++)
            ids[items[i].get('resource_id')] = items[i];

        var render = false;

        // remove
        for(var key in entities) {
            if (ids[key])
                continue;

            pool.push(entities[key]);
            entities[key].unlink();
            delete entities[key];
            render = true;
        }

        // add
        for(var key in ids) {
            if (entities[key])
                continue;

            var gizmo = pool.shift();
            if (! gizmo)
                gizmo = new Gizmo();

            gizmo.link(ids[key]);
            entities[key] = gizmo;

            render = true;
        }

        if (render)
            editor.call('viewport:render');
    });

    editor.once('viewport:load', function() {
        app = editor.call('viewport:framework');

        container = new pc.Entity(app);
        app.root.addChild(container);

        // material
        var material = new pc.BasicMaterial();
        material.color = colorPrimary;
        material.update();

        materialSpot = new pc.BasicMaterial();
        materialSpot.updateShader = function(device) {
            this.shader = new pc.Shader(device, {
                attributes: {
                    vertex_position: 'POSITION',
                    outer: 'ATTR0'
                },
                vshader: ' \
                    attribute vec3 vertex_position;\n \
                    attribute float outer;\n \
                    uniform mat4 matrix_model;\n \
                    uniform mat4 matrix_viewProjection;\n \
                    uniform float range;\n \
                    uniform float innerAngle;\n \
                    uniform float outerAngle;\n \
                    void main(void)\n \
                    {\n \
                        mat4 modelMatrix = matrix_model;\n \
                        vec4 positionW = vec4(vertex_position, 1.0);\n \
                        float radius = (outer * (sin(radians(outerAngle)) * range)) + ((1.0 - outer) * (sin(radians(innerAngle)) * range));\n \
                        positionW.xz *= radius;\n \
                        positionW.y *= range * ((outer * cos(radians(outerAngle))) + ((1.0 - outer) * cos(radians(innerAngle))));\n \
                        positionW = modelMatrix * positionW;\n \
                        gl_Position = matrix_viewProjection * positionW;\n \
                    }\n',
                fshader: ' \
                    precision highp float;\n \
                    uniform vec4 uColor;\n \
                    void main(void)\n \
                    {\n \
                        gl_FragColor = uColor;\n \
                        gl_FragColor = clamp(gl_FragColor, 0.0, 1.0);\n \
                    }\n',
            });
        };
        materialSpot.color = colorPrimary;
        materialSpot.update();

        materialSpotBehind = new pc.BasicMaterial();
        materialSpotBehind.updateShader = materialSpot.updateShader;
        materialSpotBehind.color = colorBehind;
        materialSpotBehind.blend = true;
        materialSpotBehind.blendSrc = pc.BLENDMODE_SRC_ALPHA;
        materialSpotBehind.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
        materialSpotBehind.depthTest = false;
        materialSpotBehind.update();

        var buffer, iterator, size, length, node, mesh, material, meshInstance, model;
        var vertexFormat = new pc.gfx.VertexFormat(app.graphicsDevice, [
            { semantic: pc.gfx.SEMANTIC_POSITION, components: 3, type: pc.gfx.ELEMENTTYPE_FLOAT32 }
        ]);
        var vertexFormatSpot = new pc.gfx.VertexFormat(app.graphicsDevice, [
            { semantic: pc.gfx.SEMANTIC_POSITION, components: 3, type: pc.gfx.ELEMENTTYPE_FLOAT32 },
            { semantic: pc.gfx.SEMANTIC_ATTR0, components: 1, type: pc.gfx.ELEMENTTYPE_FLOAT32 }
        ]);
        var rad = Math.PI / 180;

        // ================
        // directional light
        buffer = new pc.gfx.VertexBuffer(app.graphicsDevice, vertexFormat, 14);
        iterator = new pc.gfx.VertexIterator(buffer);
        size = .2;
        length = -(2 - size * 2);
        // line
        iterator.element[pc.SEMANTIC_POSITION].set(0, 0, 0);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(0, length, 0);
        iterator.next();
        // triangle
        iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(0 * rad) * size, length, Math.cos(0 * rad) * size);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(120 * rad) * size, length, Math.cos(120 * rad) * size);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(120 * rad) * size, length, Math.cos(120 * rad) * size);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(240 * rad) * size, length, Math.cos(240 * rad) * size);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(240 * rad) * size, length, Math.cos(240 * rad) * size);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(0 * rad) * size, length, Math.cos(0 * rad) * size);
        iterator.next();
        // triangle corners
        iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(0 * rad) * size, length, Math.cos(0 * rad) * size);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(0, length - (size * 2), 0);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(120 * rad) * size, length, Math.cos(120 * rad) * size);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(0, length - (size * 2), 0);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(240 * rad) * size, length, Math.cos(240 * rad) * size);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(0, length - (size * 2), 0);
        iterator.next();
        iterator.end();
        // node
        node = new pc.GraphNode();
        // mesh
        mesh = new pc.Mesh();
        mesh.vertexBuffer = buffer;
        mesh.indexBuffer[0] = null;
        mesh.primitive[0].type = pc.PRIMITIVE_LINES;
        mesh.primitive[0].base = 0;
        mesh.primitive[0].count = buffer.getNumVertices();
        mesh.primitive[0].indexed = false;
        // meshInstance
        meshInstance = new pc.MeshInstance(node, mesh, material);
        meshInstance.updateKey();
        // model
        model = new pc.Model();
        model.graph = node;
        model.meshInstances = [ meshInstance ];
        models['directional'] = model;

        // ================
        // point light
        var segments = 72;
        buffer = new pc.gfx.VertexBuffer(app.graphicsDevice, vertexFormat, segments * 2);
        iterator = new pc.gfx.VertexIterator(buffer);
        // xz axis
        for(var i = 0; i < segments; i++) {
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * i * rad), Math.cos(360 / segments * i * rad), 0);
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * (i + 1) * rad), Math.cos(360 / segments * (i + 1) * rad), 0);
            iterator.next();
        }
        iterator.end();
        // node
        node = new pc.GraphNode();
        // mesh
        mesh = new pc.Mesh();
        mesh.vertexBuffer = buffer;
        mesh.indexBuffer[0] = null;
        mesh.primitive[0].type = pc.PRIMITIVE_LINES;
        mesh.primitive[0].base = 0;
        mesh.primitive[0].count = buffer.getNumVertices();
        mesh.primitive[0].indexed = false;
        // meshInstance
        meshInstance = new pc.MeshInstance(node, mesh, material);
        meshInstance.updateKey();
        // model
        model = new pc.Model();
        model.graph = node;
        model.meshInstances = [ meshInstance ];
        models['point'] = model;


        // ================
        // point light close
        var segments = 72;
        buffer = new pc.gfx.VertexBuffer(app.graphicsDevice, vertexFormat, segments * 2 * 3);
        iterator = new pc.gfx.VertexIterator(buffer);
        // circles
        for(var i = 0; i < segments; i++) {
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * i * rad), 0, Math.cos(360 / segments * i * rad));
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * (i + 1) * rad), 0, Math.cos(360 / segments * (i + 1) * rad));
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * i * rad), Math.cos(360 / segments * i * rad), 0);
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * (i + 1) * rad), Math.cos(360 / segments * (i + 1) * rad), 0);
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(0, Math.cos(360 / segments * i * rad), Math.sin(360 / segments * i * rad));
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(0, Math.cos(360 / segments * (i + 1) * rad), Math.sin(360 / segments * (i + 1) * rad));
            iterator.next();
        }
        iterator.end();
        // node
        node = new pc.GraphNode();
        // mesh
        mesh = new pc.Mesh();
        mesh.vertexBuffer = buffer;
        mesh.indexBuffer[0] = null;
        mesh.primitive[0].type = pc.PRIMITIVE_LINES;
        mesh.primitive[0].base = 0;
        mesh.primitive[0].count = buffer.getNumVertices();
        mesh.primitive[0].indexed = false;
        // meshInstance
        meshInstance = new pc.MeshInstance(node, mesh, material);
        meshInstance.updateKey();
        // model
        model = new pc.Model();
        model.graph = node;
        model.meshInstances = [ meshInstance ];
        models['point-close'] = model;


        // ================
        // spot light
        var segments = 72;
        buffer = new pc.gfx.VertexBuffer(app.graphicsDevice, vertexFormatSpot, segments * 2 * 2 + 8);
        iterator = new pc.gfx.VertexIterator(buffer);
        // lines
        //      left
        iterator.element[pc.SEMANTIC_POSITION].set(0, 0, 0);
        iterator.element[pc.SEMANTIC_ATTR0].set(1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(0 * rad), -1, Math.cos(0 * rad));
        iterator.element[pc.SEMANTIC_ATTR0].set(1);
        iterator.next();
        //      right
        iterator.element[pc.SEMANTIC_POSITION].set(0, 0, 0);
        iterator.element[pc.SEMANTIC_ATTR0].set(1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(180 * rad), -1, Math.cos(180 * rad));
        iterator.element[pc.SEMANTIC_ATTR0].set(1);
        iterator.next();
        // circles
        for(var i = 0; i < segments; i++) {
            // inner
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * i * rad), -1, Math.cos(360 / segments * i * rad));
            iterator.element[pc.SEMANTIC_ATTR0].set(0);
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * (i + 1) * rad), -1, Math.cos(360 / segments * (i + 1) * rad));
            iterator.element[pc.SEMANTIC_ATTR0].set(0);
            iterator.next();
            // outer
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * i * rad), -1, Math.cos(360 / segments * i * rad));
            iterator.element[pc.SEMANTIC_ATTR0].set(1);
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * (i + 1) * rad), -1, Math.cos(360 / segments * (i + 1) * rad));
            iterator.element[pc.SEMANTIC_ATTR0].set(1);
            iterator.next();
        }
        iterator.end();
        // node
        node = new pc.GraphNode();
        // mesh
        mesh = new pc.Mesh();
        mesh.vertexBuffer = buffer;
        mesh.indexBuffer[0] = null;
        mesh.primitive[0].type = pc.PRIMITIVE_LINES;
        mesh.primitive[0].base = 0;
        mesh.primitive[0].count = buffer.getNumVertices();
        mesh.primitive[0].indexed = false;
        // meshInstance
        meshInstance = new pc.MeshInstance(node, mesh, materialSpot);
        meshInstance.updateKey();
        // model
        model = new pc.Model();
        model.graph = node;
        model.meshInstances = [ meshInstance ];
        models['spot'] = model;
    });

    editor.on('viewport:gizmoUpdate', function(dt) {
        for(var key in entities)
            entities[key].update();
    });
});


/* editor/gizmo/gizmo-collision.js */
editor.once('load', function () {
    'use strict';

    var app;
    // selected entity gizmos
    var entities = { };
    // pool of gizmos
    var pool = [ ];
    var poolVec3 = [ ];
    // colors
    var colorBehind = new pc.Color(1, 1, 1, .15);
    var colorPrimary = new pc.Color(1, 1, 1);
    var container;
    var vec = new pc.Vec3();
    var materialBehind = new pc.BasicMaterial();
    materialBehind.color = colorBehind;
    materialBehind.blend = true;
    materialBehind.blendSrc = pc.BLENDMODE_SRC_ALPHA;
    materialBehind.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
    materialBehind.depthTest = false;
    materialBehind.update();
    var materialDefault, materialSpot, materialSpotBehind;
    var models = { };
    var materials = { };
    var poolModels = { 'box': [ ], 'sphere': [ ], 'capsule-x': [ ], 'capsule-y': [ ], 'capsule-z': [ ], 'cylinder-x': [ ], 'cylinder-y': [ ], 'cylinder-z': [ ] };
    var axesNames = { 0: 'x', 1: 'y', 2: 'z' };

    // gizmo class
    function Gizmo() {
        this._link = null;
        this.lines = [ ];
        this.events = [ ];
        this.type = '';
        this.asset = 0;
        this.entity = null;
    }
    // update lines
    Gizmo.prototype.update = function() {
        if (! this._link)
            return;

        var collision = this._link.entity.collision;
        this.entity.enabled = this._link.entity.enabled && collision && collision.enabled;
        if (! this.entity.enabled)
            return;

        this.entity.setPosition(this._link.entity.getPosition());
        this.entity.setRotation(this._link.entity.getRotation());

        var type = collision.type;

        if (type === 'cylinder' || type === 'capsule')
            type += '-' + axesNames[collision.axis];

        if (this.type !== type) {
            this.type = type;

            // set new model based on type
            if (models[this.type]) {
                // get current model
                var model = this.entity.model.model;
                if (model) {
                    // put back in pool
                    app.scene.removeModel(model);
                    this.entity.removeChild(model.getGraph());
                    if (poolModels[model._type])
                        poolModels[model._type].push(model);
                }
                // get from pool
                model = null;
                if (poolModels[this.type])
                    model = poolModels[this.type].shift();

                if (! model) {
                    // no in pool
                    model = models[this.type].clone();
                    model._type = this.type;
                }
                // set to model
                this.entity.model.model = model;
                this.entity.setLocalScale(1, 1, 1);
            } else if (this.type === 'mesh') {
                this.asset = collision.asset;
                this.entity.setLocalScale(this._link.entity.getWorldTransform().getScale());
                this.createWireframe(collision.asset)
                if (! this.asset) {
                    this.entity.enabled = false;
                    this.entity.model.model = null;
                    return;
                }
            } else {
                this.entity.enabled = false;
                this.entity.model.model = null;
                return;
            }
        }

        var mat = materialBehind;
        var radius = collision.radius || .00001;
        var height = collision.height || .00001;

        switch(this.type) {
            case 'sphere':
                this.entity.setLocalScale(radius, radius, radius);
                break;
            case 'box':
                this.entity.setLocalScale(collision.halfExtents.x || .00001, collision.halfExtents.y || .00001, collision.halfExtents.z || .00001);
                break;
            case 'cylinder-x':
                this.entity.setLocalScale(height, radius, radius);
                break;
            case 'cylinder-y':
                this.entity.setLocalScale(radius, height, radius);
                break;
            case 'cylinder-z':
                this.entity.setLocalScale(radius, radius, height);
                break;
            case 'capsule-x':
            case 'capsule-y':
            case 'capsule-z':
                if (this.entity.model.model) {
                    this.entity.model.model.meshInstances[0].setParameter('radius', collision.radius || .5);
                    this.entity.model.model.meshInstances[0].setParameter('height', collision.height || 2);
                }
                mat = materials['capsuleBehind-' + axesNames[collision.axis]];
                break;
            case 'mesh':
                this.entity.setLocalScale(this._link.entity.getWorldTransform().getScale());

                if (collision.asset !== this.asset) {
                    this.asset = collision.asset;
                    this.createWireframe(collision.asset);
                    if (! this.asset) {
                        this.entity.enabled = false;
                        this.entity.model.model = null;
                        return;
                    }
                }
                break;
        }

        // render behind model
        if (this.entity.enabled && this.entity.model.model) {
            var instance = new pc.MeshInstance(this.entity.model.model.meshInstances[0].node, this.entity.model.model.meshInstances[0].mesh, mat);

            switch(this.type) {
                case 'capsule-x':
                case 'capsule-y':
                case 'capsule-z':
                    instance.setParameter('radius', collision.radius || .5);
                    instance.setParameter('height', collision.height || 2);
                    break;
            }

            app.scene.immediateDrawCalls.push(instance);
        }
    };
    // link to entity
    Gizmo.prototype.link = function(obj) {
        this.unlink();
        this._link = obj;

        var self = this;

        this.events.push(this._link.once('destroy', function() {
            self.unlink();
        }));

        this.entity = new pc.Entity();
        this.entity.addComponent('model');

        container.addChild(this.entity);
    };
    // unlink
    Gizmo.prototype.unlink = function() {
        if (! this._link)
            return;

        for(var i = 0; i < this.events.length; i++) {
            if (this.events[i] && this.events[i].unbind)
                this.events[i].unbind();
        }

        this.events = [ ];
        this._link = null;
        this.type = '';
        this.asset = 0;

        var model = this.entity.model.model;
        if (model) {
            // put back in pool
            app.scene.removeModel(model);
            this.entity.removeChild(model.getGraph());
            if (model._type)
                poolModels[model._type].push(model);
        }

        this.entity.destroy();
    };
    // create wireframe
    Gizmo.prototype.createWireframe = function(asset) {
        asset = app.assets.get(asset);
        if (! asset)
            return null;

        if (asset.resource) {
            this.entity.model.model = createModelWireframe(asset.resource);
        } else {
            var self = this;

            this.events.push(asset.once('load', function(asset) {
                if (self.asset !== asset.id)
                    return;

                self.entity.model.model = createModelWireframe(asset.resource);
            }));
        }
    };

    editor.on('selector:change', function(type, items) {
        // clear gizmos
        if (type !== 'entity') {
            for(var key in entities) {
                entities[key].unlink();
                pool.push(entities[key]);
            }
            entities = { };
            return;
        }

        // index selection
        var ids = { };
        for(var i = 0; i < items.length; i++)
            ids[items[i].get('resource_id')] = items[i];

        var render = false;

        // remove
        for(var key in entities) {
            if (ids[key])
                continue;

            pool.push(entities[key]);
            entities[key].unlink();
            delete entities[key];
            render = true;
        }

        // add
        for(var key in ids) {
            if (entities[key])
                continue;

            var gizmo = pool.shift();
            if (! gizmo)
                gizmo = new Gizmo();

            gizmo.link(ids[key]);
            entities[key] = gizmo;
            render = true;
        }

        if (render)
            editor.call('viewport:render');
    });

    editor.once('viewport:load', function() {
        app = editor.call('viewport:framework');

        container = new pc.Entity(app);
        app.root.addChild(container);

        // material
        materialDefault = new pc.BasicMaterial();
        materialDefault.color = colorPrimary;
        materialDefault.update();

        var capsuleVShader = ' \
            attribute vec3 vertex_position;\n \
            attribute float side;\n \
            uniform mat4 matrix_model;\n \
            uniform mat4 matrix_viewProjection;\n \
            uniform float radius;\n \
            uniform float height;\n \
            void main(void)\n \
            {\n \
                vec3 pos = vertex_position * radius;\n \
                pos.{axis} += side * max(height / 2.0 - radius, 0.0);\n \
                gl_Position = matrix_viewProjection * matrix_model * vec4(pos, 1.0);\n \
            }\n';
        var capsuleFShader = ' \
            precision highp float;\n \
            uniform vec4 uColor;\n \
            void main(void)\n \
            {\n \
                gl_FragColor = uColor;\n \
                gl_FragColor = clamp(gl_FragColor, 0.0, 1.0);\n \
            }\n';

        var makeMaterial = function(a) {
            materials['capsule-' + a] = new pc.BasicMaterial();
            materials['capsule-' + a].updateShader = function(device) {
                this.shader = new pc.Shader(device, {
                    attributes: {
                        vertex_position: 'POSITION',
                        side: 'ATTR0'
                    },
                    vshader: capsuleVShader.replace('{axis}', a),
                    fshader: capsuleFShader,
                });
            };
            materials['capsule-' + a].color = colorPrimary;
            materials['capsule-' + a].update();

            materials['capsuleBehind-' + a] = new pc.BasicMaterial();
            materials['capsuleBehind-' + a].updateShader = materials['capsule-' + a].updateShader;
            materials['capsuleBehind-' + a].color = colorBehind;
            materials['capsuleBehind-' + a].blend = true;
            materials['capsuleBehind-' + a].blendSrc = pc.BLENDMODE_SRC_ALPHA;
            materials['capsuleBehind-' + a].blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
            materials['capsuleBehind-' + a].depthTest = false;
            materials['capsuleBehind-' + a].update();
        }

        for(var key in axesNames)
            makeMaterial(axesNames[key]);

        var buffer, iterator, size, length, node, mesh, meshInstance, model;
        var vertexFormat = new pc.gfx.VertexFormat(app.graphicsDevice, [
            { semantic: pc.gfx.SEMANTIC_POSITION, components: 3, type: pc.gfx.ELEMENTTYPE_FLOAT32 }
        ]);
        var vertexFormatAttr0 = new pc.gfx.VertexFormat(app.graphicsDevice, [
            { semantic: pc.gfx.SEMANTIC_POSITION, components: 3, type: pc.gfx.ELEMENTTYPE_FLOAT32 },
            { semantic: pc.gfx.SEMANTIC_ATTR0, components: 1, type: pc.gfx.ELEMENTTYPE_FLOAT32 }
        ]);
        var rad = Math.PI / 180;


        // ================
        // box
        buffer = new pc.gfx.VertexBuffer(app.graphicsDevice, vertexFormat, 12 * 2);
        iterator = new pc.gfx.VertexIterator(buffer);
        // top
        iterator.element[pc.SEMANTIC_POSITION].set(1, 1, 1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(1, 1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(1, 1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, 1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, 1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, 1, 1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, 1, 1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(1, 1, 1);
        iterator.next();
        // bottom
        iterator.element[pc.SEMANTIC_POSITION].set(1, -1, 1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(1, -1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(1, -1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, -1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, -1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, -1, 1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, -1, 1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(1, -1, 1);
        iterator.next();
        // sides
        iterator.element[pc.SEMANTIC_POSITION].set(1, -1, 1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(1, 1, 1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(1, -1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(1, 1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, -1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, 1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, -1, 1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, 1, 1);
        iterator.next();
        iterator.end();
        // node
        node = new pc.GraphNode();
        // mesh
        mesh = new pc.Mesh();
        mesh.vertexBuffer = buffer;
        mesh.indexBuffer[0] = null;
        mesh.primitive[0].type = pc.PRIMITIVE_LINES;
        mesh.primitive[0].base = 0;
        mesh.primitive[0].count = buffer.getNumVertices();
        mesh.primitive[0].indexed = false;
        // meshInstance
        meshInstance = new pc.MeshInstance(node, mesh, materialDefault);
        meshInstance.updateKey();
        // model
        model = new pc.Model();
        model.graph = node;
        model.meshInstances = [ meshInstance ];
        models['box'] = model;


        // ================
        // sphere
        var segments = 72;
        buffer = new pc.gfx.VertexBuffer(app.graphicsDevice, vertexFormat, segments * 2 * 3);
        iterator = new pc.gfx.VertexIterator(buffer);
        // circles
        for(var i = 0; i < segments; i++) {
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * i * rad), 0, Math.cos(360 / segments * i * rad));
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * (i + 1) * rad), 0, Math.cos(360 / segments * (i + 1) * rad));
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * i * rad), Math.cos(360 / segments * i * rad), 0);
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * (i + 1) * rad), Math.cos(360 / segments * (i + 1) * rad), 0);
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(0, Math.cos(360 / segments * i * rad), Math.sin(360 / segments * i * rad));
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(0, Math.cos(360 / segments * (i + 1) * rad), Math.sin(360 / segments * (i + 1) * rad));
            iterator.next();
        }
        iterator.end();
        // node
        node = new pc.GraphNode();
        // mesh
        mesh = new pc.Mesh();
        mesh.vertexBuffer = buffer;
        mesh.indexBuffer[0] = null;
        mesh.primitive[0].type = pc.PRIMITIVE_LINES;
        mesh.primitive[0].base = 0;
        mesh.primitive[0].count = buffer.getNumVertices();
        mesh.primitive[0].indexed = false;
        // meshInstance
        meshInstance = new pc.MeshInstance(node, mesh, materialDefault);
        meshInstance.updateKey();
        // model
        model = new pc.Model();
        model.graph = node;
        model.meshInstances = [ meshInstance ];
        models['sphere'] = model;


        // ================
        // cylinder-x
        var segments = 72;
        buffer = new pc.gfx.VertexBuffer(app.graphicsDevice, vertexFormat, segments * 2 * 2 + 4 * 2);
        iterator = new pc.gfx.VertexIterator(buffer);
        // circles
        for(var i = 0; i < segments; i++) {
            iterator.element[pc.SEMANTIC_POSITION].set(.5, Math.sin(360 / segments * i * rad), Math.cos(360 / segments * i * rad));
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(.5, Math.sin(360 / segments * (i + 1) * rad), Math.cos(360 / segments * (i + 1) * rad));
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(-.5, Math.sin(360 / segments * i * rad), Math.cos(360 / segments * i * rad));
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(-.5, Math.sin(360 / segments * (i + 1) * rad), Math.cos(360 / segments * (i + 1) * rad));
            iterator.next();
        }
        for(var i = 0; i < 4; i++) {
            iterator.element[pc.SEMANTIC_POSITION].set(.5, Math.sin(90 * i * rad), Math.cos(90 * i * rad));
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(-.5, Math.sin(90 * i * rad), Math.cos(90 * i * rad));
            iterator.next();
        }
        iterator.end();
        // node
        node = new pc.GraphNode();
        // mesh
        mesh = new pc.Mesh();
        mesh.vertexBuffer = buffer;
        mesh.indexBuffer[0] = null;
        mesh.primitive[0].type = pc.PRIMITIVE_LINES;
        mesh.primitive[0].base = 0;
        mesh.primitive[0].count = buffer.getNumVertices();
        mesh.primitive[0].indexed = false;
        // meshInstance
        meshInstance = new pc.MeshInstance(node, mesh, materialDefault);
        meshInstance.updateKey();
        // model
        model = new pc.Model();
        model.graph = node;
        model.meshInstances = [ meshInstance ];
        models['cylinder-x'] = model;

        // ================
        // cylinder-y
        var segments = 72;
        buffer = new pc.gfx.VertexBuffer(app.graphicsDevice, vertexFormat, segments * 2 * 2 + 4 * 2);
        iterator = new pc.gfx.VertexIterator(buffer);
        // circles
        for(var i = 0; i < segments; i++) {
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * i * rad), .5, Math.cos(360 / segments * i * rad));
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * (i + 1) * rad), .5, Math.cos(360 / segments * (i + 1) * rad));
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * i * rad), -.5, Math.cos(360 / segments * i * rad));
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * (i + 1) * rad), -.5, Math.cos(360 / segments * (i + 1) * rad));
            iterator.next();
        }
        for(var i = 0; i < 4; i++) {
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(90 * i * rad), .5, Math.cos(90 * i * rad));
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(90 * i * rad), -.5, Math.cos(90 * i * rad));
            iterator.next();
        }
        iterator.end();
        // node
        node = new pc.GraphNode();
        // mesh
        mesh = new pc.Mesh();
        mesh.vertexBuffer = buffer;
        mesh.indexBuffer[0] = null;
        mesh.primitive[0].type = pc.PRIMITIVE_LINES;
        mesh.primitive[0].base = 0;
        mesh.primitive[0].count = buffer.getNumVertices();
        mesh.primitive[0].indexed = false;
        // meshInstance
        meshInstance = new pc.MeshInstance(node, mesh, materialDefault);
        meshInstance.updateKey();
        // model
        model = new pc.Model();
        model.graph = node;
        model.meshInstances = [ meshInstance ];
        models['cylinder-y'] = model;

        // ================
        // cylinder-z
        var segments = 72;
        buffer = new pc.gfx.VertexBuffer(app.graphicsDevice, vertexFormat, segments * 2 * 2 + 4 * 2);
        iterator = new pc.gfx.VertexIterator(buffer);
        // circles
        for(var i = 0; i < segments; i++) {
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * i * rad), Math.cos(360 / segments * i * rad), .5);
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * (i + 1) * rad), Math.cos(360 / segments * (i + 1) * rad), .5);
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * i * rad), Math.cos(360 / segments * i * rad), -.5);
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * (i + 1) * rad), Math.cos(360 / segments * (i + 1) * rad), -.5);
            iterator.next();
        }
        for(var i = 0; i < 4; i++) {
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(90 * i * rad), Math.cos(90 * i * rad), .5);
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(90 * i * rad), Math.cos(90 * i * rad), -.5);
            iterator.next();
        }
        iterator.end();
        // node
        node = new pc.GraphNode();
        // mesh
        mesh = new pc.Mesh();
        mesh.vertexBuffer = buffer;
        mesh.indexBuffer[0] = null;
        mesh.primitive[0].type = pc.PRIMITIVE_LINES;
        mesh.primitive[0].base = 0;
        mesh.primitive[0].count = buffer.getNumVertices();
        mesh.primitive[0].indexed = false;
        // meshInstance
        meshInstance = new pc.MeshInstance(node, mesh, materialDefault);
        meshInstance.updateKey();
        // model
        model = new pc.Model();
        model.graph = node;
        model.meshInstances = [ meshInstance ];
        models['cylinder-z'] = model;


        // ================
        // capsule y
        var segments = 72;
        buffer = new pc.gfx.VertexBuffer(app.graphicsDevice, vertexFormatAttr0, segments * 2 * 2 + segments / 2 * 2 * 4 + 4 + 2 * 4);
        iterator = new pc.gfx.VertexIterator(buffer);

        for(var i = 0; i <= segments; i++) {
            // circles
            if (i < segments) {
                for(var n = 0; n <= 1; n++) {
                    for(var k = i; k <= i + 1; k++) {
                        iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * k * rad), 0, Math.cos(360 / segments * k * rad));
                        iterator.element[pc.SEMANTIC_ATTR0].set(n ? -1 : 1);
                        iterator.next();
                    }
                }
            }
            // domes
            var n = i % (segments / 2);
            var side = i > segments / 2;
            for(var k = n; k <= n + 1; k++) {
                iterator.element[pc.SEMANTIC_POSITION].set(Math.sin((360 / segments * k + (side ? -90 : 90)) * rad), Math.cos((360 / segments * k + (side ? -90 : 90)) * rad), 0);
                iterator.element[pc.SEMANTIC_ATTR0].set(side ? 1 : -1);
                iterator.next();
            }
            for(var k = n; k <= n + 1; k++) {
                iterator.element[pc.SEMANTIC_POSITION].set(0, Math.cos((360 / segments * k + (side ? -90 : 90)) * rad), Math.sin((360 / segments * k + (side ? -90 : 90)) * rad));
                iterator.element[pc.SEMANTIC_ATTR0].set(side ? 1 : -1);
                iterator.next();
            }
        }
        // lines
        for(var i = 0; i < 4; i++) {
            for(var n = 0; n <= 1; n++) {
                iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(90 * i * rad), 0, Math.cos(90 * i * rad));
                iterator.element[pc.SEMANTIC_ATTR0].set(n ? -1 : 1);
                iterator.next();
            }
        }
        iterator.end();
        // node
        node = new pc.GraphNode();
        // mesh
        mesh = new pc.Mesh();
        mesh.vertexBuffer = buffer;
        mesh.indexBuffer[0] = null;
        mesh.primitive[0].type = pc.PRIMITIVE_LINES;
        mesh.primitive[0].base = 0;
        mesh.primitive[0].count = buffer.getNumVertices();
        mesh.primitive[0].indexed = false;
        // meshInstance
        meshInstance = new pc.MeshInstance(node, mesh, materials['capsule-y']);
        meshInstance.updateKey();
        // model
        model = new pc.Model();
        model.graph = node;
        model.meshInstances = [ meshInstance ];
        models['capsule-y'] = model;

        // ================
        // capsule x
        var segments = 72;
        buffer = new pc.gfx.VertexBuffer(app.graphicsDevice, vertexFormatAttr0, segments * 2 * 2 + segments / 2 * 2 * 4 + 4 + 2 * 4);
        iterator = new pc.gfx.VertexIterator(buffer);

        for(var i = 0; i <= segments; i++) {
            // circles
            if (i < segments) {
                for(var n = 0; n <= 1; n++) {
                    for(var k = i; k <= i + 1; k++) {
                        iterator.element[pc.SEMANTIC_POSITION].set(0, Math.sin(360 / segments * k * rad), Math.cos(360 / segments * k * rad));
                        iterator.element[pc.SEMANTIC_ATTR0].set(n ? -1 : 1);
                        iterator.next();
                    }
                }
            }
            // domes
            var n = i % (segments / 2);
            var side = i > segments / 2;
            for(var k = n; k <= n + 1; k++) {
                iterator.element[pc.SEMANTIC_POSITION].set(Math.sin((360 / segments * k + (side ? 0 : 180)) * rad), Math.cos((360 / segments * k + (side ? 0 : 180)) * rad), 0);
                iterator.element[pc.SEMANTIC_ATTR0].set(side ? 1 : -1);
                iterator.next();
            }
            for(var k = n; k <= n + 1; k++) {
                iterator.element[pc.SEMANTIC_POSITION].set(Math.cos((360 / segments * k + (side ? -90 : 90)) * rad), 0, Math.sin((360 / segments * k + (side ? -90 : 90)) * rad));
                iterator.element[pc.SEMANTIC_ATTR0].set(side ? 1 : -1);
                iterator.next();
            }
        }
        // lines
        for(var i = 0; i < 4; i++) {
            for(var n = 0; n <= 1; n++) {
                iterator.element[pc.SEMANTIC_POSITION].set(0, Math.sin(90 * i * rad), Math.cos(90 * i * rad));
                iterator.element[pc.SEMANTIC_ATTR0].set(n ? -1 : 1);
                iterator.next();
            }
        }
        iterator.end();
        // node
        node = new pc.GraphNode();
        // mesh
        mesh = new pc.Mesh();
        mesh.vertexBuffer = buffer;
        mesh.indexBuffer[0] = null;
        mesh.primitive[0].type = pc.PRIMITIVE_LINES;
        mesh.primitive[0].base = 0;
        mesh.primitive[0].count = buffer.getNumVertices();
        mesh.primitive[0].indexed = false;
        // meshInstance
        meshInstance = new pc.MeshInstance(node, mesh, materials['capsule-x']);
        meshInstance.updateKey();
        // model
        model = new pc.Model();
        model.graph = node;
        model.meshInstances = [ meshInstance ];
        models['capsule-x'] = model;

        // ================
        // capsule z
        var segments = 72;
        buffer = new pc.gfx.VertexBuffer(app.graphicsDevice, vertexFormatAttr0, segments * 2 * 2 + segments / 2 * 2 * 4 + 4 + 2 * 4);
        iterator = new pc.gfx.VertexIterator(buffer);

        for(var i = 0; i <= segments; i++) {
            // circles
            if (i < segments) {
                for(var n = 0; n <= 1; n++) {
                    for(var k = i; k <= i + 1; k++) {
                        iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * k * rad), Math.cos(360 / segments * k * rad), 0);
                        iterator.element[pc.SEMANTIC_ATTR0].set(n ? -1 : 1);
                        iterator.next();
                    }
                }
            }
            // domes
            var n = i % (segments / 2);
            var side = i > segments / 2;
            for(var k = n; k <= n + 1; k++) {
                iterator.element[pc.SEMANTIC_POSITION].set(0, Math.cos((360 / segments * k + (side ? 0 : 180)) * rad), Math.sin((360 / segments * k + (side ? 0 : 180)) * rad));
                iterator.element[pc.SEMANTIC_ATTR0].set(side ? 1 : -1);
                iterator.next();
            }
            for(var k = n; k <= n + 1; k++) {
                iterator.element[pc.SEMANTIC_POSITION].set(Math.cos((360 / segments * k + (side ? 0 : 180)) * rad), 0, Math.sin((360 / segments * k + (side ? 0 : 180)) * rad));
                iterator.element[pc.SEMANTIC_ATTR0].set(side ? 1 : -1);
                iterator.next();
            }
        }
        // lines
        for(var i = 0; i < 4; i++) {
            for(var n = 0; n <= 1; n++) {
                iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(90 * i * rad), Math.cos(90 * i * rad), 0);
                iterator.element[pc.SEMANTIC_ATTR0].set(n ? -1 : 1);
                iterator.next();
            }
        }
        iterator.end();
        // node
        node = new pc.GraphNode();
        // mesh
        mesh = new pc.Mesh();
        mesh.vertexBuffer = buffer;
        mesh.indexBuffer[0] = null;
        mesh.primitive[0].type = pc.PRIMITIVE_LINES;
        mesh.primitive[0].base = 0;
        mesh.primitive[0].count = buffer.getNumVertices();
        mesh.primitive[0].indexed = false;
        // meshInstance
        meshInstance = new pc.MeshInstance(node, mesh, materials['capsule-z']);
        meshInstance.updateKey();
        // model
        model = new pc.Model();
        model.graph = node;
        model.meshInstances = [ meshInstance ];
        models['capsule-z'] = model;
    });

    var createModelWireframe = function(model) {
        var vertexFormat = new pc.gfx.VertexFormat(app.graphicsDevice, [
            { semantic: pc.gfx.SEMANTIC_POSITION, components: 3, type: pc.gfx.ELEMENTTYPE_FLOAT32 }
        ]);

        // model
        var modelLines = new pc.Model();
        modelLines.graph = new pc.GraphNode();
        modelLines.meshInstances = [ ];

        var wtm = model.graph.getWorldTransform();
        modelLines.graph.setPosition(wtm.getTranslation());
        modelLines.graph.setEulerAngles(wtm.getEulerAngles());
        modelLines.graph.setLocalScale(wtm.getScale());

        for(var m = 0; m < model.meshInstances.length; m++) {
            var mesh = model.meshInstances[m].mesh;


            var vertices = mesh.vertexBuffer;
            var format = vertices.getFormat();
            var indices = mesh.indexBuffer[pc.RENDERSTYLE_SOLID];

            var stride = format.size / 4;
            var offset = 0;
            var indicesView = new Uint16Array(indices.lock());

            for(var i = 0; i < format.elements.length; i++) {
                if (format.elements[i].name !== 'POSITION')
                    continue;

                offset = format.elements[i].offset;
                break;
            }

            var verticesView = new Float32Array(vertices.lock(), offset);

            var numTriangles = mesh.primitive[0].count / 3;
            var base = mesh.primitive[0].base;

            var buffer = new pc.gfx.VertexBuffer(app.graphicsDevice, vertexFormat, numTriangles * 3 * 2);
            var iterator = new pc.gfx.VertexIterator(buffer);

            var i1, i2, i3;
            var pairs = { };
            for (var j = 0; j < numTriangles; j++) {
                i1 = indicesView[ base + j * 3 ] * stride;
                i2 = indicesView[ base + j * 3 + 1 ] * stride;
                i3 = indicesView[ base + j * 3 + 2 ] * stride;

                if (! pairs[i1 + '-' + i2] && ! pairs[i2 + '-' + i1]) {
                    pairs[i1 + '-' + i2] = true;
                    iterator.element[pc.SEMANTIC_POSITION].set(verticesView[i1], verticesView[i1 + 1], verticesView[i1 + 2]);
                    iterator.next();
                    iterator.element[pc.SEMANTIC_POSITION].set(verticesView[i2], verticesView[i2 + 1], verticesView[i2 + 2]);
                    iterator.next();
                }

                if (! pairs[i2 + '-' + i3] && ! pairs[i3 + '-' + i2]) {
                    pairs[i2 + '-' + i3] = true;
                    iterator.element[pc.SEMANTIC_POSITION].set(verticesView[i2], verticesView[i2 + 1], verticesView[i2 + 2]);
                    iterator.next();
                    iterator.element[pc.SEMANTIC_POSITION].set(verticesView[i3], verticesView[i3 + 1], verticesView[i3 + 2]);
                    iterator.next();
                }

                if (! pairs[i3 + '-' + i1] && ! pairs[i1 + '-' + i3]) {
                    pairs[i3 + '-' + i1] = true;
                    iterator.element[pc.SEMANTIC_POSITION].set(verticesView[i3], verticesView[i3 + 1], verticesView[i3 + 2]);
                    iterator.next();
                    iterator.element[pc.SEMANTIC_POSITION].set(verticesView[i1], verticesView[i1 + 1], verticesView[i1 + 2]);
                    iterator.next();
                }
            }

            vertices.unlock();
            indices.unlock();

            iterator.end();

            // mesh
            var meshLines = new pc.Mesh();
            meshLines.vertexBuffer = buffer;
            meshLines.indexBuffer[0] = null;
            meshLines.primitive[0].type = pc.PRIMITIVE_LINES;
            meshLines.primitive[0].base = 0;
            meshLines.primitive[0].count = buffer.getNumVertices();
            meshLines.primitive[0].indexed = false;
            // meshInstance
            var wtm = model.meshInstances[m].node.getWorldTransform();
            var node = new pc.GraphNode();
            var meshInstance = new pc.MeshInstance(node, meshLines, materialDefault);
            node.setPosition(wtm.getTranslation());
            node.setEulerAngles(wtm.getEulerAngles());
            node.setLocalScale(wtm.getScale());
            meshInstance.updateKey();
            modelLines.meshInstances.push(meshInstance);
            modelLines.graph.addChild(node);
        }

        return modelLines;
    };

    editor.on('viewport:gizmoUpdate', function(dt) {
        for(var key in entities)
            entities[key].update();
    });
});


/* editor/gizmo/gizmo-particles.js */
editor.once('load', function () {
    'use strict';

    var app;
    // selected entity gizmos
    var entities = { };
    // pool of gizmos
    var pool = [ ];
    // colors
    var colorBehind = new pc.Color(1, 1, 1, .15);
    var colorPrimary = new pc.Color(1, 1, 1);
    var container;
    var materialDefault;
    var materialBehind = new pc.BasicMaterial();
    materialBehind.color = colorBehind;
    materialBehind.blend = true;
    materialBehind.blendSrc = pc.BLENDMODE_SRC_ALPHA;
    materialBehind.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
    materialBehind.depthTest = false;
    materialBehind.update();
    var models = { };
    var poolModels = { 'box': [ ], 'sphere': [ ] };
    var shapes = { 0: 'box', 1: 'sphere' };

    // gizmo class
    function Gizmo() {
        this._link = null;
        this.events = [ ];
        this.type = '';
        this.entity = null;
    }
    // update lines
    Gizmo.prototype.update = function() {
        if (! this._link)
            return;

        var particles = this._link.entity.particlesystem;
        this.entity.enabled = this._link.entity.enabled && particles && particles.enabled;
        if (! this.entity.enabled)
            return;

        this.entity.setPosition(this._link.entity.getPosition());
        this.entity.setRotation(this._link.entity.getRotation());

        var type = shapes[particles.emitterShape];

        if (this.type !== type) {
            this.type = type;

            // set new model based on type
            if (models[this.type]) {
                // get current model
                var model = this.entity.model.model;
                if (model) {
                    // put back in pool
                    app.scene.removeModel(model);
                    this.entity.removeChild(model.getGraph());
                    if (poolModels[model._type])
                        poolModels[model._type].push(model);
                }
                // get from pool
                model = null;
                if (poolModels[this.type])
                    model = poolModels[this.type].shift();

                if (! model) {
                    // no in pool
                    model = models[this.type].clone();
                    model._type = this.type;
                }
                // set to model
                this.entity.model.model = model;
                this.entity.setLocalScale(1, 1, 1);
            } else {
                this.entity.enabled = false;
                this.entity.model.model = null;
                return;
            }
        }

        var mat = materialBehind;

        switch(this.type) {
            case 'sphere':
                this.entity.setLocalScale(particles.emitterRadius || .000001, particles.emitterRadius || .000001, particles.emitterRadius || .000001);
                break;
            case 'box':
                this.entity.setLocalScale(particles.emitterExtents.x / 2 || .00001, particles.emitterExtents.y / 2 || .00001, particles.emitterExtents.z / 2 || .00001);
                break;
        }

        // render behind model
        if (this.entity.enabled && this.entity.model.model) {
            var instance = new pc.MeshInstance(this.entity.model.model.meshInstances[0].node, this.entity.model.model.meshInstances[0].mesh, mat);
            app.scene.immediateDrawCalls.push(instance);
        }
    };
    // link to entity
    Gizmo.prototype.link = function(obj) {
        this.unlink();
        this._link = obj;

        var self = this;

        this.events.push(this._link.once('destroy', function() {
            self.unlink();
        }));

        this.entity = new pc.Entity();
        this.entity.addComponent('model');

        container.addChild(this.entity);
    };
    // unlink
    Gizmo.prototype.unlink = function() {
        if (! this._link)
            return;

        for(var i = 0; i < this.events.length; i++) {
            if (this.events[i] && this.events[i].unbind)
                this.events[i].unbind();
        }

        this.events = [ ];
        this._link = null;
        this.type = '';

        var model = this.entity.model.model;
        if (model) {
            // put back in pool
            app.scene.removeModel(model);
            this.entity.removeChild(model.getGraph());
            if (model._type)
                poolModels[model._type].push(model);
        }

        this.entity.destroy();
    };

    editor.on('selector:change', function(type, items) {
        // clear gizmos
        if (type !== 'entity') {
            for(var key in entities) {
                entities[key].unlink();
                pool.push(entities[key]);
            }
            entities = { };
            return;
        }

        // index selection
        var ids = { };
        for(var i = 0; i < items.length; i++)
            ids[items[i].get('resource_id')] = items[i];

        var render = false;

        // remove
        for(var key in entities) {
            if (ids[key])
                continue;

            pool.push(entities[key]);
            entities[key].unlink();
            delete entities[key];
            render = true;
        }

        // add
        for(var key in ids) {
            if (entities[key])
                continue;

            var gizmo = pool.shift();
            if (! gizmo)
                gizmo = new Gizmo();

            gizmo.link(ids[key]);
            entities[key] = gizmo;
            render = true;
        }

        if (render)
            editor.call('viewport:render');
    });

    editor.once('viewport:load', function() {
        app = editor.call('viewport:framework');

        container = new pc.Entity(app);
        app.root.addChild(container);

        // material
        materialDefault = new pc.BasicMaterial();
        materialDefault.color = colorPrimary;
        materialDefault.update();

        var buffer, iterator, size, length, node, mesh, meshInstance, model;
        var vertexFormat = new pc.gfx.VertexFormat(app.graphicsDevice, [
            { semantic: pc.gfx.SEMANTIC_POSITION, components: 3, type: pc.gfx.ELEMENTTYPE_FLOAT32 }
        ]);
        var vertexFormatAttr0 = new pc.gfx.VertexFormat(app.graphicsDevice, [
            { semantic: pc.gfx.SEMANTIC_POSITION, components: 3, type: pc.gfx.ELEMENTTYPE_FLOAT32 },
            { semantic: pc.gfx.SEMANTIC_ATTR0, components: 1, type: pc.gfx.ELEMENTTYPE_FLOAT32 }
        ]);
        var rad = Math.PI / 180;


        // ================
        // box
        buffer = new pc.gfx.VertexBuffer(app.graphicsDevice, vertexFormat, 12 * 2);
        iterator = new pc.gfx.VertexIterator(buffer);
        // top
        iterator.element[pc.SEMANTIC_POSITION].set(1, 1, 1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(1, 1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(1, 1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, 1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, 1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, 1, 1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, 1, 1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(1, 1, 1);
        iterator.next();
        // bottom
        iterator.element[pc.SEMANTIC_POSITION].set(1, -1, 1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(1, -1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(1, -1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, -1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, -1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, -1, 1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, -1, 1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(1, -1, 1);
        iterator.next();
        // sides
        iterator.element[pc.SEMANTIC_POSITION].set(1, -1, 1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(1, 1, 1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(1, -1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(1, 1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, -1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, 1, -1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, -1, 1);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-1, 1, 1);
        iterator.next();
        iterator.end();
        // node
        node = new pc.GraphNode();
        // mesh
        mesh = new pc.Mesh();
        mesh.vertexBuffer = buffer;
        mesh.indexBuffer[0] = null;
        mesh.primitive[0].type = pc.PRIMITIVE_LINES;
        mesh.primitive[0].base = 0;
        mesh.primitive[0].count = buffer.getNumVertices();
        mesh.primitive[0].indexed = false;
        // meshInstance
        meshInstance = new pc.MeshInstance(node, mesh, materialDefault);
        meshInstance.updateKey();
        // model
        model = new pc.Model();
        model.graph = node;
        model.meshInstances = [ meshInstance ];
        models['box'] = model;


        // ================
        // sphere
        var segments = 72;
        buffer = new pc.gfx.VertexBuffer(app.graphicsDevice, vertexFormat, segments * 2 * 3);
        iterator = new pc.gfx.VertexIterator(buffer);
        // circles
        for(var i = 0; i < segments; i++) {
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * i * rad), 0, Math.cos(360 / segments * i * rad));
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * (i + 1) * rad), 0, Math.cos(360 / segments * (i + 1) * rad));
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * i * rad), Math.cos(360 / segments * i * rad), 0);
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(Math.sin(360 / segments * (i + 1) * rad), Math.cos(360 / segments * (i + 1) * rad), 0);
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(0, Math.cos(360 / segments * i * rad), Math.sin(360 / segments * i * rad));
            iterator.next();
            iterator.element[pc.SEMANTIC_POSITION].set(0, Math.cos(360 / segments * (i + 1) * rad), Math.sin(360 / segments * (i + 1) * rad));
            iterator.next();
        }
        iterator.end();
        // node
        node = new pc.GraphNode();
        // mesh
        mesh = new pc.Mesh();
        mesh.vertexBuffer = buffer;
        mesh.indexBuffer[0] = null;
        mesh.primitive[0].type = pc.PRIMITIVE_LINES;
        mesh.primitive[0].base = 0;
        mesh.primitive[0].count = buffer.getNumVertices();
        mesh.primitive[0].indexed = false;
        // meshInstance
        meshInstance = new pc.MeshInstance(node, mesh, materialDefault);
        meshInstance.updateKey();
        // model
        model = new pc.Model();
        model.graph = node;
        model.meshInstances = [ meshInstance ];
        models['sphere'] = model;
    });

    editor.on('viewport:gizmoUpdate', function(dt) {
        for(var key in entities)
            entities[key].update();
    });
});


/* editor/project/project.js */
editor.once('load', function() {
    'use strict';

    var project = new Observer();

    var loadedProject = false;

    // Loads current project from the server
    editor.method('project:load', function (callback) {
        Ajax.get('{{url.api}}/projects/{{project.id}}?access_token={{accessToken}}')
        .on('load', function (status, data) {
            project.patch(data.response[0]);

            loadedProject = true;
            if (callback)
                callback(project);
        });
    });

    editor.method('project:get', function (callback) {
        loadAndExecute(function () {
            callback(project);
        });
    });

    // Saves specified data to server
    editor.method('project:save', function (data, success, error) {
        Ajax.put('{{url.api}}/projects/{{project.id}}?access_token={{accessToken}}', data)
        .on('load', function () {
            if (success)
                success();
        })
        .on('error', function () {
            if (error)
                error();
        });
    });

    var loadAndExecute = function (fn) {
        if (!loadedProject)
            editor.call('project:load', fn);
        else
            fn();
    };

    // Adds the physics library to the project and updates db
    editor.method('project:enablePhysics', function (callback) {
        loadAndExecute(function () {
            var libraries = project.getRaw('settings.libraries');
            if (libraries.indexOf('physics-engine-3d') < 0) {
                project.insert('settings.libraries', 'physics-engine-3d', libraries.length - 1);

                var data = {
                    name: project.get('name'),
                    settings: project.get('settings')
                };

                editor.call('project:save', data, callback, function (err) {
                    // remove physics from libraries on error
                    project.removeValue('settings.libraries', 'physics-engine-3d');
                });
            }
        });
    });

    editor.method('project:setLoadingScreenScript', function (script, callback) {
        loadAndExecute(function () {
            project.set('settings.loading_screen_script', script);

            var data = {
                name: project.get('name'),
                settings: project.get('settings')
            };

            editor.call('project:save', data, callback, function (err) {
                // remove physics from libraries on error
                project.unset('settings.loading_screen_script');
            });
        });
    });

    editor.method('project:getLoadingScreenScript', function (callback) {
        loadAndExecute(function () {
            callback(project.get('settings.loading_screen_script'));
        });
    });


    editor.method('project:setPrimaryScene', function (sceneId, callback) {
        loadAndExecute(function () {
            var prevPrimary = config.project.primaryScene;
            config.project.primaryScene = parseInt(sceneId, 10);
            project.set('primary_pack', parseInt(sceneId, 10));
            editor.call('project:save', {
                name: project.get('name'),
                primary_pack: config.project.primaryScene
            }, callback, function (err) {
                project.set('primary_pack', prevPrimary);
                config.project.primaryScene = prevPrimary;
            });
        });
    });

    editor.on('messenger:project.primary_pack', function (data) {
        var primaryScene = parseInt(data.project.primary_pack, 10);
        if (loadedProject)
            project.set('primary_pack', primaryScene);

        var prev = config.project.primaryScene;
        config.project.primaryScene = primaryScene;

        editor.emit('project:primaryScene', primaryScene, prev);
    });
});


/* editor/users/users.js */
editor.once('load', function() {
    'use strict';

    var users = { };
    var userRequests = { };

    // Loads a user from the server
    editor.method('users:loadOne', function (id, callback) {
        if (users[id])
            return callback(users[id]);

        if (userRequests[id])
            return userRequests[id].push(callback);

        userRequests[id] = [ callback ];

        Ajax.get('{{url.api}}/users/' + id + '?access_token={{accessToken}}')
        .on('load', function (status, data) {
            users[id] = data.response[0];

            for(var i = 0; i < userRequests[id].length; i++)
                userRequests[id][i](data.response[0]);

            delete userRequests[id];
        });
    });
});


/* editor/users/users-usage.js */
editor.once('load', function () {
    'use strict';

    editor.on('messenger:user.usage', function (data) {
        if (data.user !== config.owner.id) return;

        config.owner.size += data.usage.total;

        editor.emit('user:' + config.owner.id + ':usage', config.owner.size);
    });
});


/* editor/assets/assets.js */
/*

NAMESPACE
    asset

METHODS
    add
    remove
    get
    find
    findOne

EVENTS
    add
    remove

*/

editor.once('load', function() {
    'use strict';

    var assets = new ObserverList({
        index: 'id',
        sorted: function(a, b) {
            var f = (b._data['type'] === 'folder') - (a._data['type'] === 'folder');

            if (f !== 0)
                return f;

            if (a._data['name'].toLowerCase() > b._data['name'].toLowerCase()) {
                return 1;
            } else if (a._data['name'].toLowerCase() < b._data['name'].toLowerCase()) {
                return -1;
            } else {
                return 0;
            }
        }
    });


    // return assets ObserverList
    editor.method('assets:raw', function() {
        return assets;
    });

    // allow adding assets
    editor.method('assets:add', function(asset) {
        var pos = assets.add(asset);

        if (pos === null)
            return;

        asset.on('name:set', function(name, nameOld) {
            name = name.toLowerCase();
            nameOld = nameOld.toLowerCase();

            var ind = assets.data.indexOf(this);
            var pos = assets.positionNextClosest(this, function(a, b) {
                var f = (b._data['type'] === 'folder') - (a._data['type'] === 'folder');

                if (f !== 0)
                    return f;

                if ((a === b ? nameOld : a._data['name'].toLowerCase()) > name) {
                    return 1;
                } else if ((a === b ? nameOld : a._data['name'].toLowerCase()) < name) {
                    return -1;
                } else {
                    return 0;
                }
            });

            if (pos === -1 && (ind + 1) == assets.data.length)
                return;

            if (ind !== -1 && (ind + 1 === pos) || (ind === pos))
                return;

            if (ind < pos)
                pos--;

            assets.move(this, pos);
            editor.emit('assets:move', asset, pos);
        });

        // publish added asset
        editor.emit('assets:add[' + asset.get('id') + ']', asset, pos);
        editor.emit('assets:add', asset, pos);
    });

    // allow removing assets
    editor.method('assets:remove', function(asset) {
        assets.remove(asset);
        asset.destroy();
    });

    // remove all assets
    editor.method('assets:clear', function () {
        assets.clear();
        editor.emit('assets:clear');
    });

    // get asset by id
    editor.method('assets:get', function(id) {
        return assets.get(id);
    });

    // find assets by function
    editor.method('assets:find', function(fn) {
        return assets.find(fn);
    });

    // find one asset by function
    editor.method('assets:findOne', function(fn) {
        return assets.findOne(fn);
    });

    editor.method('assets:map', function (fn) {
        assets.map(fn);
    });

    editor.method('assets:list', function () {
        return assets.array();
    });

    // publish remove asset
    assets.on('remove', function(asset) {
        editor.emit('assets:remove', asset);
    });
});


/* editor/assets/assets-registry.js */
editor.once('load', function() {
    'use strict';

    editor.method('assets:registry:bind', function (assetRegistry, assetTypes) {
        // add assets to asset registry
        editor.on('assets:add', function (asset) {
            // do only for target assets
            if (asset.get('source'))
                return;

            if (assetTypes && assetTypes.indexOf(asset.get('type')) === -1)
                return;

            // raw json data
            var assetJson = asset.json();

            // engine material data
            var data = {
                id: parseInt(assetJson.id, 10),
                name: assetJson.name,
                file: assetJson.file ? {
                    filename: assetJson.file.filename,
                    url: assetJson.file.url,
                    hash: assetJson.file.hash,
                    size: assetJson.file.size
                } : null,
                data: assetJson.data,
                type: assetJson.type
            };

            // add to registry
            // assetRegistry.createAndAddAsset(assetJson.id, data);

            var newAsset = new pc.Asset(data.name, data.type, data.file, data.data);
            newAsset.id = parseInt(assetJson.id, 10);
            assetRegistry.add(newAsset);

            var timeout;
            var updatedFields = {};

            asset.on('*:set', function (path, value) {
                var parts = path.split('.');

                if (parts[0] !== 'data' && parts[0] !== 'file')
                    return;

                if (timeout)
                    clearTimeout(timeout);

                updatedFields[parts[0]] = true;

                // do this in a timeout to avoid multiple sets of the same
                // fields
                timeout = setTimeout(function () {
                    var realtimeAsset = assetRegistry.get(asset.get('id'));

                    for (var key in updatedFields) {
                        var data = asset.get(key);

                        // this will trigger the 'update' event on the asset in the engine
                        // handling all resource loading automatically
                        realtimeAsset[key] = data;

                        delete updatedFields[key];
                    }

                    timeout = null;
                });
            });
        });

        // remove assets from asset registry
        editor.on('assets:remove', function (asset) {
            var realtimeAsset = assetRegistry.get(asset.get('id'));
            if (realtimeAsset) {
                assetRegistry.remove(realtimeAsset);
            }
        });
    });
});


/* editor/assets/assets-preview.js */
editor.once('load', function () {

    // canvas user to render the preview
    var canvas = document.createElement('canvas');

    // set up graphics
    var device = new pc.GraphicsDevice(canvas, {premultipliedAlpha: false});

    // create resource loader and asset registry
    var loader = new pc.ResourceLoader();
    var assets = new pc.AssetRegistry(loader, '/api');

    loader.addHandler("model", new pc.ModelHandler(device));
    loader.addHandler("material", new pc.MaterialHandler(assets));
    loader.addHandler("texture", new pc.TextureHandler(device, assets, loader));
    loader.addHandler("cubemap", new pc.CubemapHandler(device, assets, loader));

    // bind asset registry to editor
    editor.call('assets:registry:bind', assets, ['texture', 'cubemap', 'material', 'model']);

    var renderTimeouts = {};

    editor.method('preview:render', function (asset) {
        editor.call('preview:render:' + asset.get('type'), asset, 128, function (canvas) {
            var url = canvas.toDataURL('image/png');
            editor.call('preview:setThumbnail', asset, url);
        });
    });


    // renders preview for specified asset after a delay
    editor.method('preview:delayedRender', function (asset, delay) {
        var id = asset.get('id');
        if (renderTimeouts[id])
            clearTimeout(renderTimeouts[id]);

        renderTimeouts[id] = setTimeout(function () {
            editor.call('preview:render', asset);
            delete renderTimeouts[id];
        }, delay || 100);
    });

    // sets thumbnail to specified asset without syncing or recording history
    editor.method('preview:setThumbnail', function (asset, value) {
        var sync = asset.sync.enabled;
        asset.sync.enabled = false;

        var history = asset.history.enabled;
        asset.history.enabled = false;

        if (value) {
            asset.set('has_thumbnail', true);
            asset.set('thumbnails', {
                's': value,
                'm': value,
                'l': value,
                'xl': value
            });
        } else {
            asset.set('has_thumbnail', false);
            asset.unset('thumbnails');
        }

        asset.history.enabled = history;
        asset.sync.enabled = sync;
    });

    // Gets asset registry
    editor.method('preview:assetRegistry', function () {
        return assets;
    });

    editor.method('preview:loader', function () {
        return loader;
    });

    editor.method('preview:device', function () {
        return device;
    });

    // Get necessary objects for a new preview scene
    editor.method('preview:prepare', function () {
        return {
            canvas: canvas,
            assets: assets,
            scene: new pc.Scene(),
            renderer: new pc.ForwardRenderer(device),
            device: device
        };
    });

});


/* editor/assets/assets-preview-materials.js */
editor.once('load', function () {

    var data = editor.call('preview:prepare');
    if (! data) return;

    var canvas = data.canvas;
    var assets = data.assets;
    var scene = data.scene;
    var renderer = data.renderer;
    var device = data.device;

    // set up sphere
    var node = new pc.GraphNode();
    var mesh = pc.createSphere(device);
    var meshInstance = new pc.MeshInstance(node, mesh, new pc.PhongMaterial());
    var model = new pc.Model();
    model.graph = node;
    model.meshInstances = [ meshInstance ];

    // set up light
    var light = new pc.Light();
    light.setEnabled(true);
    light.setColor(1, 1, 1);
    var lightNode = new pc.GraphNode();
    lightNode.setPosition(5, 5, 5);
    lightNode.rotate(45, 45, 0);
    light._node = lightNode;

    // set up camera
    var camera = new pc.Camera();
    var clearOptions = camera.getClearOptions();
    clearOptions.color[0] = 0;
    clearOptions.color[1] = 0;
    clearOptions.color[2] = 0;
    clearOptions.color[3] = 0;

    var cameraNode = new pc.GraphNode();
    cameraNode.setPosition(0, 0, 1.34);
    camera._node = cameraNode;

    // set up scene
    scene.ambientLight.set(0.2, 0.2, 0.2);
    scene.addLight(light);
    scene.addModel(model);

    var sceneSettingsLoaded = false;

    var settings = editor.call('sceneSettings');

    var materialCache = {};
    var cubemapCache = {};

    var updateSettings = function () {
        var ambient = settings.get('render.global_ambient');
        var gammaCorrection = settings.get('render.gamma_correction');
        var tonemapping = settings.get('render.tonemapping');
        var exposure = settings.get('render.exposure');
        //var skybox = settings.get('render.skybox');

        scene.ambientLight.set(ambient[0], ambient[1], ambient[2]);
        scene.gammaCorrection = gammaCorrection;
        scene.toneMapping = tonemapping;
        scene.exposure = exposure;
        //scene.skybox = skybox;

        // regenerate all material thumbnails
        editor.call('assets:map', function (asset) {
            if (asset.get('type') !== 'material') return;

            editor.emit('preview:material:changed', asset.get('id'));
        });
    };


    // when scene settings load render all materials
    editor.on('sceneSettings:load', function () {
        sceneSettingsLoaded = true;

        updateSettings();

        settings.on('render.global_ambient:set', updateSettings);
        settings.on('render.gamma_correction:set', updateSettings);
        settings.on('render.tonemapping:set', updateSettings);
        settings.on('render.exposure:set', updateSettings);
        //settings.on('render.skybox:set', updateSettings);
    });


    // Instantly renders a preview for the specified material and passes
    // the canvas in the callback
    editor.method('preview:render:material', function (asset, size, callback) {
        if (!sceneSettingsLoaded) return;

        var material = assets.get(asset.get('id'));
        if (!material) return;

        material = material.resource;
        if (!material) return;

        // multiply-blend won't work properly so make it normal
        if (material.blendType === pc.BLEND_MULTIPLICATIVE)
            material.blendType = pc.BLEND_NORMAL;

        // clear material mesh instances
        // to avoid issues with the same material being
        // used in skinned meshes
        material.meshInstances = [];
        model.meshInstances[0].material = material;

        // resize canvas appropriately
        if (canvas.width !== size)
            device.resizeCanvas(size, size);

        camera.setAspectRatio(1);

        renderer.render(scene, camera);

        callback(canvas);
    });

    // when materials are changed render their thumbs
    editor.on('preview:material:changed', function (assetId) {
        var asset = editor.call('assets:get', assetId);
        if (asset)
            editor.call('preview:delayedRender', asset);
    });

    // loads real-time material for the specified asset and
    // generates thumbnails for it
    var generatePreview = function (asset) {
        var assetId = asset.get('id');
        var material;

        var realtimeAsset = assets.get(assetId);
        if (!realtimeAsset)
            return;

        // called when material resource is loaded
        function onLoaded () {
            materialCache[material.id] = assetId;
            editor.emit('preview:material:changed', assetId);
        }

        // use or load material
        realtimeAsset.ready(function (asset) {
            material = asset.resource;
            onLoaded();
        });
        assets.load(realtimeAsset);
    };

    editor.on('assets:add', function (asset) {
        if (asset.get('type') === 'material')
            // generate preview after a little while to wait
            // for all assets to be added to the registry first
            setTimeout(function () {
                generatePreview(asset);
            }, 100);
    });

    editor.on('assets:remove', function (asset) {
        if (asset.get('type') !== 'material') return;

        // clear caches
        var assetId = asset.get('id');
        for (var id in materialCache) {
            if (materialCache[id] === assetId) {
                delete cubemapCache[id];
                delete materialCache[id];
            }
        }
    });

    // patch update for materials to emit change event
    var update = pc.PhongMaterial.prototype.update;
    pc.PhongMaterial.prototype.update = function () {
        update.call(this);
        if (materialCache[this.id])
            editor.emit('preview:material:changed', materialCache[this.id]);

        // add referenced cubemap to cubemap cache
        if (this.cubeMap)
            cubemapCache[this.id] = this.cubeMap;
        else
            delete cubemapCache[this.id];
    };

});


/* editor/assets/assets-preview-models.js */
editor.once('load', function () {

    var data = editor.call('preview:prepare');
    if (! data) return;

    var canvas = data.canvas;
    var assets = data.assets;
    var scene = data.scene;
    var renderer = data.renderer;
    var device = data.device;

    // set up light
    var light = new pc.Light();
    light.setEnabled(true);
    light.setColor(1, 1, 1);
    var lightNode = new pc.GraphNode();
    lightNode.setPosition(5, 5, 5);
    lightNode.rotate(45, 45, 0);
    light._node = lightNode;

    // set up camera
    var camera = new pc.Camera();
    camera.setNearClip(0.0001);
    camera.setFarClip(100000);

    var clearOptions = camera.getClearOptions();
    clearOptions.color[0] = 0;
    clearOptions.color[1] = 0;
    clearOptions.color[2] = 0;
    clearOptions.color[3] = 0;

    var material = new pc.PhongMaterial();

    var cameraNode = new pc.GraphNode();
    cameraNode.setPosition(0, 0, 1.34);
    camera._node = cameraNode;

    // set up scene
    scene.ambientLight.set(0.2, 0.2, 0.2);
    scene.addLight(light);

    var setBestCameraPositionForModel = function (model) {
        var aabb = new pc.shape.Aabb();
        var meshInstances = model.meshInstances;
        if (meshInstances.length > 0) {
            meshInstances[0].syncAabb();
            aabb.copy(meshInstances[0].aabb);
            for (var i = 1; i < meshInstances.length; i++) {
                meshInstances[i].syncAabb();
                aabb.add(meshInstances[i].aabb);
            }
        }

        var bestPosition = aabb.center;
        var halfWidth = aabb.halfExtents.x;
        var halfHeight = aabb.halfExtents.y;
        var halfDepth = aabb.halfExtents.z;
        var max = Math.max(halfWidth, halfDepth);
        max = Math.max(max, halfHeight);
        bestPosition.z += max / Math.tan(0.5 * camera.getFov() * Math.PI / 180.0) + halfDepth;

        cameraNode.setPosition(bestPosition);
    };

    // Instantly renders a preview for the specified model and passes
    // the result in the callback
    editor.method('preview:render:model', function (asset, size, callback) {
        var model = assets.get(asset.get('id'));
        if (!model) return;

        model = model.resource;
        if (!model) return;

        var models = scene.getModels();
        var i = models.length;
        while (i--) {
            scene.removeModel(models[i]);
        }

        // update skinned mesh instance aabb's and materials
        var meshInstances = model.meshInstances;
        var material = new pc.PhongMaterial();
        for (var i = 0; i < meshInstances.length; i++) {
            meshInstances[i].material = material;

            if (meshInstances[i].skinInstance) {
                meshInstances[i].skinInstance.updateMatrixPalette();
            }
        }

        scene.addModel(model);

        setBestCameraPositionForModel(model);

        // resize canvas appropriately
        device.resizeCanvas(size, size);
        camera.setAspectRatio(1);

        renderer.render(scene, camera);

        if (callback)
            callback(canvas);
    });

    // loads real-time material for the specified asset and
    // generates thumbnails for it
    var generatePreview = function (asset) {
        var timeout;
        var model = assets.get(asset.get('id'));
        if (!model) return;

        var onLoaded = function () {
            editor.call('preview:render', asset);
        };

        var onReady = function (asset) {
            model = asset.resource;
            onLoaded();

            var onChange = function (asset, attribute, newValue, oldValue) {
                if (attribute === 'file') {
                    if (timeout) {
                        clearTimeout(timeout);
                    }

                    // reload model asset
                    // (do it in a timeout to avoid
                    // rapid attribute changes)
                    timeout = setTimeout(function () {
                        asset.off('change', onChange);
                        asset.unload();
                        editor.call('preview:loader').clearCache(asset.file.url, 'model');
                        asset.ready(onReady);
                        assets.load(asset);

                        timeout = null;
                    }, 100);
                }
            };

            asset.off('change', onChange);
            asset.on('change', onChange);
        };


        model.ready(onReady);
        assets.load(model);
    };


    // TODO: enable for white materials
    editor.on('assets:add', function (asset) {
        if (asset.get('source')) return;
        if (asset.get('type') !== 'model') return;

        // do this in a timeout to wait for all
        // assets to be added to the asset registry first
        setTimeout(function () {
            generatePreview(asset);
        }, 100);
    });
});


/* editor/assets/assets-preview-cubemaps.js */
editor.once('load', function () {

    var canvas = document.createElement('canvas');

    var placeHolderLoaded = false;
    var placeholder = document.createElement('img');
    placeholder.addEventListener('load', function () {
        placeHolderLoaded = true;
    });
    placeholder.src = '/editor/scene/img/asset-placeholder-texture.png';

    var assets = editor.call('preview:assetRegistry');

    var eventsToClear = [];
    var assetsLoaded = false;

    editor.on('assets:load', function () {
        assetsLoaded = true;

        eventsToClear.forEach(function (evt) {
            evt.unbind();
        });
    });

    editor.on('assets:clear', function () {
        assetsLoaded = false;
    });

    editor.method('preview:render:cubemap', function (asset, size, callback) {
        var textures = asset.get('data.textures');

        // make sure placeholder image is loaded
        if (!placeHolderLoaded) {
            editor.call('preview:delayedRender', asset);
            return;
        }

        var images = [];
        var loadedImages = 0;

        var onLoaded = function () {
            if (canvas.width !== size) {
                canvas.width = size;
                canvas.height = size;
            }

            var width = size / 4;
            var height = size / 4;
            var offset = (size - height * 3) / 2;

            var ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // left
            ctx.drawImage(images[1], 0, offset + height, width, height);
            // front
            ctx.drawImage(images[4], width, offset + height, width, height);
            // right
            ctx.drawImage(images[0], 2*width, offset + height, width, height);
            // back
            ctx.drawImage(images[5], 3*width, offset + height, width, height);
            // top
            ctx.drawImage(images[2], width, offset, width, height);
            // bottom
            ctx.drawImage(images[3], width, offset + 2*height, width, height);

            callback(canvas);

            images = null;
        };

        var onImageLoaded = function () {
            loadedImages++;
            if (loadedImages === 6) {
                onLoaded();
            }
        };

        for (var i = 0; i < textures.length; i++) {
            faceImagesLoaded = 0;
            var img = placeholder;

            var texture;
            if (textures[i]) {
                texture = editor.call('assets:get', textures[i]);
                if (! texture && ! assetsLoaded) {
                    eventsToClear.push(editor.once('assets:add[' + textures[i] + ']', function () {
                        editor.call('preview:delayedRender', asset);
                    }));
                }
            }

            if (texture && (texture.get('thumbnails.s') || texture.get('file.url'))) {
                img = new Image();
                img.addEventListener('load', onImageLoaded);

                // use small thumbnail or file if thumbnail not there
                img.setAttribute('crossOrigin', 'anonymous');
                img.src = (texture.get('thumbnails.s') || texture.get('file.url'));
            }

            images.push(img);

            if (img === placeholder) {
                onImageLoaded();
            }
        }

    });

    editor.on('assets:add', function (asset) {
        if (asset.get('type') !== 'cubemap') return;

        // re-render thumbnail if texture thumbnails changed
        var evts = [];

        var onChanged = function () {
            editor.call('preview:delayedRender', asset);
        };

        var bindTextureChanges = function () {
            evts.forEach(function (evt) {
                evt.unbind();
            });

            evts.length = 0;

            asset.get('data.textures').forEach(function (id) {
                if (parseInt(id) >= 0) {
                    var texture = editor.call('assets:get', id);
                    if (texture) {
                        evts.push(texture.on('thumbnails.s:set', onChanged));
                    }
                }
            });
        };

        // do this in a timeout to wait for all
        // assets to be added to the asset registry first
        setTimeout(function () {
            bindTextureChanges();
            editor.call('preview:render', asset);
        }, 100);


        asset.on('*:set', function (path) {
            if (path.indexOf('data.textures') === 0) {
                onChanged();
                bindTextureChanges();
            }
        });
    });
});


/* editor/assets/assets-cubemap-prefiltering.js */
editor.once('load', function () {

    var app = null;

    editor.once('viewport:load', function() {
        app = editor.call('viewport:framework');
    });

    // var device = editor.call('preview:device');
    // var assets = editor.call('preview:assetRegistry');

    var getTextureAssets = function (assetCubeMap) {
        var result = [];
        var textures = assetCubeMap.get('data.textures');
        for (var i = 0; i < textures.length; i++) {
            var id = textures[i];
            if (parseInt(id) >= 0) {
                var texture = editor.call('assets:get', id);
                if (!texture) {
                    return null;
                }

                result.push(texture);
            } else {
                return null;
            }
        }

        return result;
    };

    var prefilterHdrCubemap = function (assetCubeMap, cubemap, callback) {
        try {
            var textureAssets = getTextureAssets(assetCubeMap);
            if (textureAssets) {
                var l = textureAssets.length;
                var count = l;
                var textures = [];

                var onLoad = function () {
                    editor.call('status:job', 'prefilter');

                    cubemap = new pc.Texture(app.graphicsDevice, {
                        cubemap: true,
                        rgbm: false,
                        fixCubemapSeams: true,
                        format: textures[0].format,
                        width: textures[0].width,
                        height: textures[0].height
                    });

                    cubemap.addressU = pc.ADDRESS_CLAMP_TO_EDGE;
                    cubemap.addressV = pc.ADDRESS_CLAMP_TO_EDGE;

                    cubemap._levels[0] = [ textures[0]._levels[0],
                                           textures[1]._levels[0],
                                           textures[2]._levels[0],
                                           textures[3]._levels[0],
                                           textures[4]._levels[0],
                                           textures[5]._levels[0] ];

                    // prefilter cubemap
                    var options = {
                        device: app.graphicsDevice,
                        sourceCubemap: cubemap,
                        method: 1,
                        samples: 4096,
                        cpuSync: true,
                        filteredFixed: [],
                        filteredFixedRgbm: [],
                        singleFilteredFixedRgbm: true
                    };

                    pc.prefilterCubemap(options);

                    // get dds and create blob
                    var dds = options.singleFilteredFixedRgbm.getDds();
                    var blob = new Blob([dds], {type: 'image/dds'});

                    // upload blob as dds
                    editor.call('assets:uploadFile', {
                        file: blob,
                        name: assetCubeMap.get('name') + '.dds',
                        asset: assetCubeMap,
                        type: 'cubemap'
                    }, function (err, data) {
                        if (!err) {
                            callback();
                        } else {
                            editor.call('status:job', 'prefilter');
                            callback(err);
                        }
                    });
                };

                textureAssets.forEach(function (asset, index) {
                    editor.call('status:job', 'prefilter', index);

                    var url = asset.get('file.url').replace(/.png$/, '.dds');

                    app.assets._loader.load(url, "texture", function (err, resource) {
                        if (!err) {
                            textures[index] = resource;
                        } else {
                            console.warn(err);
                        }

                        count--;
                        if (count === 0) {
                            onLoad();
                        }
                    });
                });
            }
        }
        catch (ex) {
            callback(ex);
        }
    };

    var prefilterCubemap = function (assetCubeMap, cubemap, callback) {
        try {
            var count = 0;
            var textures = [ ];
            var texturesAssets = [ ];
            var textureIds = assetCubeMap.get('data.textures');

            for(var i = 0; i < 6; i++) {
                // missing texture
                if (! textureIds[i])
                    return;

                texturesAssets[i] = editor.call('assets:get', textureIds[i]);

                // texture is not in registry
                if (! texturesAssets[i])
                    return;
            }

            var texturesReady = function() {
                editor.call('status:job', 'prefilter');

                var options = {
                    device: app.graphicsDevice,
                    sourceCubemap: cubemap,
                    method: 1,
                    samples: 4096,
                    cpuSync: true,
                    filteredFixed: [ ],
                    singleFilteredFixed: true
                };

                pc.prefilterCubemap(options);

                var dds = options.singleFilteredFixed.getDds();
                var blob = new Blob([ dds ], { type: 'image/dds' });

                // upload blob as dds
                editor.call('assets:uploadFile', {
                    file: blob,
                    name: assetCubeMap.get('name') + '.dds',
                    asset: assetCubeMap,
                    type: 'cubemap'
                }, function (err, data) {
                    if (callback)
                        callback(null);
                });
            };

            var textureLoad = function(ind, url) {
                editor.call('status:job', 'prefilter', ind);

                app.assets._loader.load(url, 'texture', function (err, resource) {
                    if (err)
                        console.warn(err);

                    textures[ind] = resource;

                    count++;
                    if (count === 6)
                        texturesReady();
                });
            };

            for(var i = 0; i < 6; i++)
                textureLoad(i, texturesAssets[i].get('file.url'))
        } catch (ex) {
            if (callback)
                callback(ex);
        }
    };

    editor.method('assets:cubemaps:prefilter', function (assetCubeMap, callback) {
        var asset = app.assets.get(parseInt(assetCubeMap.get('id'), 10));
        if (! asset)
            return;

        var cubemap;
        var onLoad = function() {
            if (app.graphicsDevice.extTextureFloatRenderable && cubemap.rgbm) {
                prefilterHdrCubemap(assetCubeMap, cubemap, callback);
            } else {
                prefilterCubemap(assetCubeMap, cubemap, callback);
            }
        };

        if (asset.resource) {
            cubemap = asset.resource;
            onLoad();
        } else {
            asset.once('load', function(asset) {
                cubemap = asset.resource;
                onLoad();
            });
            app.assets.load(asset);
        }
    });

    // invalidate prefiltering data on cubemaps
    // when one of face textures file is changed
    editor.on('assets:add', function(asset) {
        if (asset.get('type') !== 'cubemap')
            return;

        asset._textures = [ ];

        var invalidate = function() {
            if (! asset.get('file'))
                return;

            asset.set('file', null);
        };

        var watchTexture = function(ind, id) {
            if (asset._textures[ind])
                asset._textures[ind].unbind();

            asset._textures[ind] = null;

            if (! id)
                return;

            var texture = editor.call('assets:get', id);
            if (texture)
                asset._textures[ind] = texture.on('file.hash:set', invalidate);
        };

        var watchFace = function(ind) {
            // update watching on face change
            asset.on('data.textures.' + ind + ':set', function(id) {
                watchTexture(ind, id);
            });
            // start watching
            watchTexture(ind, asset.get('data.textures.' + ind));
        };

        for(var i = 0; i < 6; i++)
            watchFace(i);
    });
});


/* editor/assets/assets-sync.js */
editor.once('load', function() {
    'use strict';

    var syncPaths = [
        'name',
        'preload',
        'scope',
        'data',
        'file'
    ];

    var docs = {};

    editor.method('loadAsset', function (id, callback) {
        var connection = editor.call('realtime:connection');

        var doc = connection.get('assets', '' + id);

        docs[id] = doc;

        // error
        doc.on('error', function (err) {
            editor.emit('realtime:assets:error', err);
        });

        // ready to sync
        doc.on('ready', function () {
            // notify of operations
            doc.on('after op', function (ops, local) {
                if (local) return;

                for (var i = 0; i < ops.length; i++) {
                    editor.emit('realtime:op:assets', ops[i], id);
                }
            });

            // notify of asset load
            var assetData = doc.getSnapshot();
            assetData.id = id;

            if (assetData.file)
                assetData.file.url = getFileUrl(assetData.id, assetData.revision, assetData.file.filename);

            var asset = new Observer(assetData);
            editor.call('assets:add', asset);

            if (callback)
                callback(asset);

        });

        // subscribe for realtime events
        doc.subscribe();
    });

    editor.method('assets:fs:paths:patch', function(data) {
        var connection = editor.call('realtime:connection');
        var assets = connection.collections.assets;

        for(var i = 0; i < data.length; i++) {
            if (! assets.hasOwnProperty(data[i].id))
                continue;

            // force snapshot path data
            assets[data[i].id].snapshot.path = data[i].path;

            // sync observer
            editor.emit('realtime:op:assets', {
                p: [ 'path' ],
                oi: data[i].path,
                od: null
            }, data[i].id);
        }
    });

    var onLoad = function(data) {
        editor.call('assets:progress', .5);

        data = data.response;

        var count = 0;

        var load = function (id) {
            editor.call('loadAsset', id, function (asset) {
                count++;
                editor.call('assets:progress', (count / data.length) * .5 + .5);
                if (count >= data.length) {
                    editor.call('assets:progress', 1);
                    editor.emit('assets:load');
                }
            });
        };

        if (data.length) {
            for(var i = 0; i < data.length; i++) {
                load(data[i].id);
            }
        } else {
            editor.call('assets:progress', 1);
            editor.emit('assets:load');
        }
    };

    // load all assets
    editor.on('realtime:authenticated', function() {
        editor.call('assets:clear');

        Ajax
        .get('{{url.api}}/projects/{{project.id}}/assets?view=designer&access_token={{accessToken}}')
        .on('load', function(status, data) {
            onLoad(data);
        })
        .on('progress', function(progress) {
            editor.call('assets:progress', .1 + progress * .4);
        })
        .on('error', function(status, evt) {
            console.log(status, evt);
        });
    });

    editor.call('assets:progress', .1);

    // create asset
    editor.method('assets:create', function (data) {
        var assetId = null;
        var evtAssetAdd = editor.once('assets:add', function(asset) {
            if (! evtAssetAdd && assetId !== parseInt(asset.get('id'), 10))
                return;

            evtAssetAdd = null;
            editor.call('selector:set', 'asset', [ asset ]);
            // navigate to folder too
            var path = asset.get('path');
            if (path.length) {
                editor.call('assets:panel:currentFolder', editor.call('assets:get', path[path.length - 1]));
            } else {
                editor.call('assets:panel:currentFolder', null);
            }
        });

        editor.once('selector:change', function() {
            if (evtAssetAdd) {
                evtAssetAdd.unbind();
                evtAssetAdd = null;
            }
        });

        editor.call('assets:uploadFile', data, function(err, res) {
            if (evtAssetAdd)
                evtAssetAdd = null;

            if (err) {
                editor.call('status:error', err);

                // TODO
                // disk allowance error

                return;
            }

            assetId = res.asset.id;
        });
    });

    // delete asset
    editor.method('assets:delete', function(list) {
        if (! (list instanceof Array))
            list = [ list ];

        var assets = [ ];

        for(var i = 0; i < list.length; i++) {
            if (list[i].get('type') === 'script') {
                editor.emit('sourcefiles:remove', list[i]);
                Ajax.delete('{{url.api}}/projects/' + config.project.id + '/repositories/directory/sourcefiles/' + list[i].get('filename') + '?access_token={{accessToken}}');
            } else {
                assets.push(list[i]);
            }
        }

        if (assets.length)
            editor.call('assets:fs:delete', assets);
    });

    editor.on('assets:remove', function (asset) {
        var id = asset.get('id');
        if (docs[id]) {
            docs[id].destroy();
            delete docs[id];
        }
    });

    var getFileUrl = function (id, revision, filename) {
        return '/api/files/assets/' + id + '/' + revision + '/' + filename;
    };

    var assetSetThumbnailPaths = function(asset) {
        if (asset.get('type') !== 'texture')
            return;

        if (asset.get('has_thumbnail')) {
            asset.set('thumbnails', {
                's': '/api/assets/' + asset.get('id') + '/thumbnail/small.jpg',
                'm': '/api/assets/' + asset.get('id') + '/thumbnail/medium.jpg',
                'l': '/api/assets/' + asset.get('id') + '/thumbnail/large.jpg',
                'xl': '/api/assets/' + asset.get('id') + '/thumbnail/xlarge.jpg'
            });
        } else {
            asset.unset('thumbnails');
        }
    };

    // hook sync to new assets
    editor.on('assets:add', function(asset) {
        if (asset.sync)
            return;

        // convert material data to flat
        if (asset.get('type') === 'material') {
            // store missing tilings / offset before we set default values
            editor.call('material:rememberMissingFields', asset);

            asset.set('data', editor.call('material:default', asset.get('data')));
        }

        asset.sync = new ObserverSync({
            item: asset,
            paths: syncPaths
        });

        // client > server
        asset.sync.on('op', function(op) {
            editor.call('realtime:assets:op', op, asset.get('id'));
        });

        // set thumbnails
        assetSetThumbnailPaths(asset);

        var setting = false;

        asset.on('*:set', function (path, value) {
            if (setting || (! (path.startsWith('file') && value) && ! (path === 'has_thumbnail' && value && asset.get('file.url'))))
                return;

            setting = true;

            // reset file url
            asset.set('file.url', getFileUrl(asset.get('id'), asset.get('revision'), asset.get('file.filename')));
            // set thumbnails
            assetSetThumbnailPaths(asset);

            setting = false;
        });
    });

    // write asset operations
    editor.method('realtime:assets:op', function(op, id) {
        if (! editor.call('permissions:write') || !docs[id])
            return;

        // console.trace();
        // console.log('out: [ ' + Object.keys(op).filter(function(i) { return i !== 'p' }).join(', ') + ' ]', op.p.join('.'));
        // console.log(op)

        docs[id].submitOp([ op ]);
    });


    // server > client
    editor.on('realtime:op:assets', function(op, id) {
        var asset = editor.call('assets:get', id);
        if (asset) {
            asset.sync.write(op);
        } else {
            console.error('realtime operation on missing asset: ' + op.p[1]);
        }
    });

    // handle disconnection
    editor.on('realtime:disconnected', function () {
        var viewport = editor.call('viewport:framework');
        if (!viewport) return;

        // clear ALL asset registry events
        viewport.assets._callbacks = {};
    });
});


/* editor/assets/assets-fs.js */
editor.once('load', function() {
    'use strict';

    var getIds = function(assets) {
        if (! (assets instanceof Array))
            assets = [ assets ];

        var ids = [ ];
        for(var i = 0; i < assets.length; i++)
            ids.push(parseInt(assets[i].get('id'), 10));

        return ids;
    };

    editor.method('assets:fs:delete', function(assets) {
        editor.call('realtime:send', 'fs', {
            op: 'delete',
            ids: getIds(assets)
        });
    });

    editor.method('assets:fs:move', function(assets, assetTo) {
        editor.call('realtime:send', 'fs', {
            op: 'move',
            ids: getIds(assets),
            to: assetTo ? parseInt(assetTo.get('id'), 10) : null
        });
    });

    editor.method('assets:fs:duplicate', function(assets) {
        editor.call('realtime:send', 'fs', {
            op: 'duplicate',
            ids: getIds(assets)
        });
    });
});


/* editor/assets/assets-panel.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');
    var assetsPanel = editor.call('layout.assets');

    var dragging = false;
    var draggingType = '';
    var draggingData = { };
    var selector = {
        type: '',
        items: [ ],
        prev: {
            type: '',
            items: [ ]
        }
    };
    var searching = false;

    var overlay = new ui.Panel();
    overlay.class.add('overlay');
    assetsPanel.append(overlay);

    var loading = new ui.Progress();
    loading.on('progress:100', function() {
        overlay.hidden = true;
    });
    overlay.append(loading);

    editor.method('assets:progress', function(progress) {
        loading.progress = progress;
    });

    // folders panel
    var folders = new ui.Panel();
    folders.class.add('folders');
    folders.flexShrink = false;
    folders.style.width = '200px';
    folders.innerElement.style.width = '200px';
    folders.foldable = false;
    folders.horizontal = true;
    folders.scroll = true;
    folders.resizable = 'right';
    folders.resizeMin = 100;
    folders.resizeMax = 300;
    assetsPanel.append(folders);

    editor.method('assets:panel:folders', function() {
        return folders;
    });

    var currentFolder = null;
    editor.method('assets:panel:currentFolder', function(asset) {
        if (asset === undefined)
            return currentFolder;

        if (asset === currentFolder)
            return;

        // current folder style remove
        if (currentFolder && typeof(currentFolder) !== 'string' && assetsIndex[currentFolder.get('id')]) {
            assetsIndex[currentFolder.get('id')].tree.class.remove('current');
        } else {
            if (currentFolder === null) {
                treeRoot.class.remove('current');
            } else if (currentFolder === 'scripts') {
                treeScripts.class.remove('current');
            }
        }

        currentFolder = asset;

        // current folder style add
        if (currentFolder && typeof(currentFolder) !== 'string') {
            assetsIndex[currentFolder.get('id')].tree.class.add('current');

            // open tree up
            var path = currentFolder.get('path');
            for(var i = 0; i < path.length; i++) {
                if (! assetsIndex[path[i]] || ! assetsIndex[path[i]].tree)
                    continue;

                assetsIndex[path[i]].tree.open = true;
            }
        } else if (currentFolder === null) {
            treeRoot.class.add('current');
        } else if (currentFolder === 'scripts') {
            treeScripts.class.add('current');
        }

        gridScripts.hidden = currentFolder !== null;

        editor.emit('assets:panel:currentFolder', currentFolder);
    });

    editor.call('hotkey:register', 'assets:fs:up', {
        key: 'backspace',
        callback: function() {
            if (! currentFolder || editor.call('selector:type') !== 'asset')
                return;

            var path = typeof(currentFolder) === 'string' ? [ ] : currentFolder.get('path');
            if (path.length === 0) {
                editor.call('assets:panel:currentFolder', null);
            } else {
                editor.call('assets:panel:currentFolder', editor.call('assets:get', path[path.length - 1]));
            }
        }
    });

    editor.on('drop:active', function(state, type, data) {
        dragging = state;

        if (! dragging) {
            grid.dragOver = undefined;
            gridDropBorder.classList.remove('active');
            treeDropBorder.classList.remove('active');
        }
    });

    editor.on('drop:set', function(type, data) {
        draggingType = type;
        draggingData = data;
    });

    // tree
    var tree = new ui.Tree();
    tree.enabled = false;
    tree.draggable = false;
    tree.class.add('assets');
    folders.append(tree);

    var dropRef = editor.call('drop:target', {
        ref: folders.element,
        hole: true,
        passThrough: true,
        filter: function(type, data) {
            return type.startsWith('asset');
        },
        drop: function(type, data) {
            if (! type || grid.dragOver === undefined || ! type.startsWith('asset'))
                return;

            var items = editor.call('selector:items');
            var assets = [ ];

            var addAsset = function(id) {
                var asset = editor.call('assets:get', id);

                // deselect moved asset
                if (items.indexOf(asset) !== -1)
                    editor.call('selector:remove', asset);

                assets.push(asset);
            };

            if (data.ids) {
                for(var i = 0; i < data.ids.length; i++)
                    addAsset(data.ids[i]);
            } else {
                addAsset(data.id);
            }
            editor.call('assets:fs:move', assets, grid.dragOver);
        }
    });
    dropRef.element.classList.add('assets-drop-area');

    var treeAppendQueue = { };

    // tree root
    var treeRoot = new ui.TreeItem({
        text: '/'
    });
    tree.append(treeRoot);
    treeRoot.open = true;
    treeRoot.class.add('current');
    treeRoot.on('select', function() {
        this.selected = false;
    });

    // scripts folder
    var gridScripts;
    var treeScripts;

    treeRoot.elementTitle.addEventListener('mouseover', function() {
        if (! dragging || grid.dragOver === null || (! draggingData.id && ! draggingData.ids))
            return;

        // already in that folder
        var dragAsset = editor.call('assets:get', draggingData.id || draggingData.ids[0]);
        if (! dragAsset.get('path').length)
            return;

        gridDropBorder.classList.remove('active');

        var rect = treeRoot.elementTitle.getBoundingClientRect();
        treeDropBorder.classList.add('active');
        treeDropBorder.style.left = rect.left + 'px';
        treeDropBorder.style.top = rect.top + 'px';
        treeDropBorder.style.right = (window.innerWidth - rect.right) + 'px';
        treeDropBorder.style.bottom = (window.innerHeight - rect.bottom) + 'px';

        grid.dragOver = null;
    }, false);

    treeRoot.elementTitle.addEventListener('mouseout', function() {
        if (! dragging || grid.dragOver === undefined)
            return;

        gridDropBorder.classList.remove('active');
        treeDropBorder.classList.remove('active');

        grid.dragOver = undefined;
    }, false);

    // tree width resizing
    var resizeTree = function() {
        tree.element.style.width = '';
        tree.element.style.width = (folders.innerElement.scrollWidth - 5) + 'px';
    };
    folders.on('resize', resizeTree);
    tree.on('open', resizeTree);
    tree.on('close', resizeTree);
    setInterval(resizeTree, 500);

    var files = new ui.Panel();
    files.class.add('files');
    files.flexGrow = true;
    files.foldable = false;
    files.horizontal = true;
    files.scroll = true;
    assetsPanel.append(files);

    editor.method('assets:panel:files', function() {
        return files;
    });

    // grid
    var grid = new ui.Grid();
    grid.enabled = false;
    grid.class.add('assets');
    files.append(grid);


    var dropRef = editor.call('drop:target', {
        ref: files.element,
        hole: true,
        passThrough: true,
        filter: function(type, data) {
            return type.startsWith('asset');
        },
        drop: function(type, data) {
            if (! type || grid.dragOver === undefined || ! type.startsWith('asset'))
                return;

            var assets = [ ];
            var items = editor.call('selector:items');

            var addAsset = function(id) {
                var asset = editor.call('assets:get', id);

                // deselect moved asset
                if (items.indexOf(asset) !== -1)
                    editor.call('selector:remove', asset);

                assets.push(asset);
            };

            if (data.ids) {
                for(var i = 0; i < data.ids.length; i++)
                    addAsset(data.ids[i]);
            } else {
                addAsset(data.id);
            }

            editor.call('assets:fs:move', assets, grid.dragOver);
        }
    });
    dropRef.element.classList.add('assets-drop-area');

    editor.on('permissions:writeState', function(state) {
        tree.enabled = state;
        grid.enabled = state;
    });

    var labelNoAssets = new ui.Label();
    labelNoAssets.renderChanges = false;
    labelNoAssets.class.add('no-assets');
    labelNoAssets.hidden = true;
    files.append(labelNoAssets);

    editor.method('assets:panel:message', function (msg) {
        labelNoAssets.text = msg;
        labelNoAssets.hidden = !msg;
    });

    var scriptsIndex = { };
    var assetsIndex = { };
    var assetsChanged = false;
    grid.assetsIndex = assetsIndex;

    var gridDropBorder = document.createElement('div');
    gridDropBorder.classList.add('assets-drop-border');
    root.append(gridDropBorder);

    var treeDropBorder = document.createElement('div');
    treeDropBorder.classList.add('assets-drop-border');
    root.append(treeDropBorder);

    tree.on('select', function(item) {
        if (assetsChanged)
            return;

        if (item.asset) {
            if (! Tree._ctrl || ! Tree._ctrl()) {
                if (currentFolder !== item.asset) {
                    item.selected = false;
                } else {
                    editor.call('selector:set', 'asset', [ item.asset ]);
                }
            } else {
                editor.call('selector:add', 'asset', item.asset);
            }
        }

        if (! item.asset) {
            if (item === treeRoot) {
                editor.call('assets:filter:search', '');
                editor.call('assets:panel:currentFolder', null);
            } else if (item === treeScripts) {
                editor.call('assets:filter:search', '');
                editor.call('assets:panel:currentFolder', 'scripts');
            }
            return;
        }

        if (! Tree._ctrl || ! Tree._ctrl()) {
            editor.call('assets:filter:search', '');
            editor.call('assets:panel:currentFolder', item.asset);
        }
    });

    tree.on('deselect', function(item) {
        if (assetsChanged)
            return;

        if (item.asset)
            editor.call('selector:remove', item.asset);
    });

    grid.on('select', function(item) {
        if (assetsChanged)
            return;

        if (item.asset) {
            editor.call('selector:add', 'asset', item.asset);
        } else if (item.script) {
            editor.call('selector:add', 'asset', item.script);
        }
    });

    grid.on('deselect', function(item) {
        if (assetsChanged)
            return;

        if (item.asset) {
            editor.call('selector:remove', item.asset);
        } else if (item.script) {
            editor.call('selector:remove', item.script);
        }
    });

    editor.on('selector:change', function(type, items) {
        assetsChanged = true;

        if (type === 'asset') {
            tree.clear();
            items = items.slice(0);
            var assets = items.slice(0);

            for(var i = 0; i < items.length; i++) {
                if (items[i].get('type') === 'script') {
                    assets[i] = scriptsIndex[items[i].get('filename')];
                } else {
                    assets[i] = assetsIndex[items[i].get('id')];
                    if (assets[i].tree) {
                        assets[i].tree.selected = true;

                        // open tree up
                        var path = items[i].get('path');
                        for(var n = 0; n < path.length; n++) {
                            if (! assetsIndex[path[n]] || ! assetsIndex[path[n]].tree)
                                continue;

                            assetsIndex[path[n]].tree.open = true;
                        }
                    }
                }
            }

            grid.selected = assets;
        } else {
            if (! (gridScripts.selected && grid.selected.length === 1) || ! selector.type)
                grid.selected = [ ];

            tree.clear();
        }

        selector.prev.type = selector.type;
        selector.prev.items = selector.items;

        selector.type = editor.call('selector:type');
        selector.items = editor.call('selector:items');

        assetsChanged = false;
    });

    // return grid
    editor.method('assets:grid', function() {
        return grid;
    });


    // filter assets in grid
    editor.method('assets:panel:filter', function(fn) {
        if (! fn)
            fn = editor.call('assets:panel:filter:default');

        labelNoAssets.hidden = true;

        grid.forEach(function(gridItem) {
            if (gridItem.asset) {
                gridItem.hidden = ! fn('asset', gridItem.asset);
            } else if (gridItem.script) {
                gridItem.hidden = ! fn('script', gridItem.script);
            }
        });

        var type = editor.call('assets:filter:type');
        var search = editor.call('assets:filter:search');

        // navigate to selected assets folder
        if (searching && ! search) {
            searching = false;

            if (selector.type === 'asset') {
                var script = selector.items[0].get('type') === 'script';
                var path = script ? [ ] : selector.items[0].get('path');
                var multiPath = false;
                for(var i = 1; i < selector.items.length; i++) {
                    var item = selector.items[i];
                    if (script !== (item.get('type') === 'script') || (! script && ! path.equals(item.get('path')))) {
                        multiPath = true;
                        break;
                    }
                }

                if (! multiPath) {
                    if (path.length) {
                        editor.call('assets:panel:currentFolder', editor.call('assets:get', path[path.length - 1]));
                        assetsIndex[selector.items[0].get('id')].element.focus();
                    } else if (script) {
                        editor.call('assets:panel:currentFolder', 'scripts');
                    } else {
                        editor.call('assets:panel:currentFolder', null);
                    }
                }
            }
        }

        if (search)
            searching = true;

        gridScripts.hidden = ! fn('scripts', 'scripts');
    });


    // get grid item by id
    editor.method('assets:panel:get', function(id) {
        return assetsIndex[id] || scriptsIndex[id];
    });


    editor.on('messenger:asset.thumbnail', function(data) {
        var gridItem = assetsIndex[parseInt(data.asset.id, 10)];

        if (! gridItem || gridItem.asset.get('source'))
            return;

        var url = '/api/assets/' + data.asset.id + '/thumbnail/medium.jpg?t=' + (gridItem.asset.get('file.hash') || data.asset.hash || '')
        gridItem.thumbnail.style.backgroundImage = 'url(' + url + ')';
        gridItem.thumbnail.classList.remove('placeholder');
    });


    var appendChildFolders = function(item) {
        var queue = treeAppendQueue[item.asset.get('id')];
        if (! queue || ! queue.length)
            return;

        for(var i = 0; i < queue.length; i++) {
            var closest = treeFindClosest(item.tree, queue[i].tree);
            if (closest === -1) {
                item.tree.append(queue[i].tree);
            } else {
                item.tree.appendBefore(queue[i].tree, item.tree.child(closest).ui);
            }
            appendChildFolders(queue[i]);
        }

        delete treeAppendQueue[item.asset.get('id')];
    };

    var treeFindClosest = function(item, b, nameOld) {
        var l = Array.prototype.slice.call(item.element.childNodes, 1);
        if (item === treeRoot)
            l = l.slice(1);

        var min = 0;
        var max = l.length - 1;
        var cur;
        var a, i;
        var aN, bN;

        if (l.length === 0)
            return -1;

        if (((a === b) ? nameOld.toLowerCase() : l[0].ui.text.toLowerCase()) === bN)
            return 0;

        while (min <= max) {
            cur = Math.floor((min + max) / 2);
            a = l[cur];

            aN = (a === b) ? nameOld.toLowerCase() : a.ui.text.toLowerCase();
            bN = b.text.toLowerCase();

            if (aN > bN) {
                max = cur - 1;
            } else if (aN < bN) {
                min = cur + 1;
            } else {
                return cur;
            }
        }

        if (aN > bN)
            return cur;

        if ((cur + 1) === l.length)
            return -1;

        return cur + 1;
    };

    var createScriptFolder = function() {
        gridScripts = new ui.GridItem();
        gridScripts.class.add('type-folder', 'scripts');
        grid.append(gridScripts);

        gridScripts.tree = treeScripts = new ui.TreeItem({
            text: 'scripts'
        });
        gridScripts.tree.class.add('scripts');
        gridScripts.tree.on('select', function() {
            this.selected = false;
        });
        treeRoot.append(gridScripts.tree);

        gridScripts.on('select', function() {
            editor.call('selector:clear');

            if (! selector.type) {
                selector.prev.type = null;
                selector.prev.items = [ ];
            }
        });

        // folder open
        gridScripts.element.addEventListener('dblclick', function() {
            tree.clear();
            editor.call('assets:filter:search', '');
            editor.call('assets:panel:currentFolder', 'scripts');
            // change back selection

            if (selector.prev.type)
                editor.call('selector:set', selector.prev.type, selector.prev.items);
        }, false);

        var thumbnail = gridScripts.thumbnail = document.createElement('div');
        thumbnail.classList.add('thumbnail', 'placeholder');
        gridScripts.element.appendChild(thumbnail);

        var icon = document.createElement('div');
        icon.classList.add('icon');
        gridScripts.element.appendChild(icon);

        var label = gridScripts.labelElement = document.createElement('div');
        label.classList.add('label');
        label.textContent = 'scripts';
        gridScripts.element.appendChild(label);

        // context menu
        var menu = new ui.Menu();
        root.append(menu);

        // script
        var menuScript = new ui.MenuItem({
            text: 'New Script',
            value: 'script',
            icon: '&#57864;'
        });
        menuScript.on('select', function () {
            editor.call('sourcefiles:new');
        });
        menu.append(menuScript);

        editor.on('repositories:load', function (repositories) {
            if (repositories.get('current') !== 'directory')
                menuScript.disabled = true;
        });
        var onContextMenu = function(evt) {
            evt.stopPropagation();
            evt.preventDefault();

            if (! editor.call('permissions:write'))
                return;

            menu.position(evt.clientX + 1, evt.clientY);
            menu.open = true;
        };
        gridScripts.element.addEventListener('contextmenu', onContextMenu, false);
        treeScripts.elementTitle.addEventListener('contextmenu', onContextMenu, false);

        resizeTree();
    };
    createScriptFolder();

    editor.on('assets:add', function(asset, pos) {
        asset._type = 'asset';

        var item = new ui.GridItem();
        item.asset = asset;
        item.class.add('type-' + asset.get('type'));

        var onDragStart = function(evt) {
            evt.preventDefault();
            evt.stopPropagation();

            if (! editor.call('permissions:write'))
                return;

            var type = 'asset.' + asset.get('type');
            var data = {
                id: asset.get('id')
            };

            var selectorType = editor.call('selector:type');
            var selectorItems = editor.call('selector:items');

            if (selectorType === 'asset' && selectorItems.length > 1) {
                var path = selectorItems[0].get('path');

                if (selectorItems.indexOf(asset) !== -1) {
                    var ids = [ ];
                    for(var i = 0; i < selectorItems.length; i++) {
                        // don't allow multi-path dragging
                        if (path.length !== selectorItems[i].get('path').length || path[path.length - 1] !== selectorItems[i].get('path')[path.length - 1])
                            return;

                        ids.push(parseInt(selectorItems[i].get('id'), 10));
                    }

                    type = 'assets';
                    data = {
                        ids: ids
                    };
                }
            }

            editor.call('drop:set', type, data);
            editor.call('drop:activate', true);
        };

        if (asset.get('type') === 'folder') {
            item.tree = new ui.TreeItem({
                text: asset.get('name')
            });
            item.tree.asset = asset;

            var appended = false;
            var path = asset.get('path');
            var parent;
            if (path.length) {
                var parentFolderId = path[path.length - 1];
                if (assetsIndex[parentFolderId]) {
                    appended = true;
                    parent = assetsIndex[parentFolderId].tree;
                } else {
                    if (! treeAppendQueue[parentFolderId])
                        treeAppendQueue[parentFolderId] = [ ];

                    treeAppendQueue[parentFolderId].push(item);
                }
            } else {
                appended = true;
                parent = treeRoot;
            }

            if (parent) {
                var closest = treeFindClosest(parent, item.tree);
                if (closest === -1) {
                    parent.append(item.tree);
                } else {
                    parent.appendBefore(item.tree, parent.child(closest).ui);
                }

                appendChildFolders(item);
            }

            // draggable
            item.tree.elementTitle.draggable = true;
            item.tree.elementTitle.addEventListener('dragstart', onDragStart, false);

            var onMouseOver = function() {
                if (! dragging || grid.dragOver === asset)
                    return;

                // don't allow to drag on it self
                if (draggingData.ids) {
                    // multi-drag
                    if (draggingData.ids.indexOf(parseInt(asset.get('id'), 10)) !== -1)
                        return;
                } else if (draggingData.id) {
                    // single-drag
                    if (parseInt(asset.get('id'), 10) === parseInt(draggingData.id, 10))
                        return;
                } else {
                    // script file drag
                    return;
                }


                // already in that folder
                var dragAsset = editor.call('assets:get', draggingData.id || draggingData.ids[0]);
                var path = dragAsset.get('path');
                if (path.length && path[path.length - 1] === parseInt(asset.get('id')))
                    return;

                // don't allow dragging into own child
                if (draggingData.ids) {
                    // multi-drag
                    var assetPath = asset.get('path');
                    for(var i = 0; i < draggingData.ids.length; i++) {
                        if (assetPath.indexOf(draggingData.ids[i]) !== -1)
                            return;
                    }
                } else {
                    // single-drag
                    if (asset.get('path').indexOf(parseInt(dragAsset.get('id'), 10)) !== -1)
                        return;
                }

                var clip = files.element.getBoundingClientRect();
                var rect = item.element.getBoundingClientRect();
                var top = Math.max(rect.top, clip.top);
                var bottom = Math.min(rect.bottom, clip.bottom);

                if ((bottom - top) > 8) {
                    gridDropBorder.classList.add('active');
                    gridDropBorder.style.left = rect.left + 'px';
                    gridDropBorder.style.top = top + 'px';
                    gridDropBorder.style.right = (window.innerWidth - rect.right) + 'px';
                    gridDropBorder.style.bottom = (window.innerHeight - bottom) + 'px';
                }

                var rect = item.tree.elementTitle.getBoundingClientRect();
                top = Math.max(rect.top, clip.top);
                bottom = Math.min(rect.bottom, clip.bottom);
                if (rect.height && (bottom - top) > 4) {
                    treeDropBorder.classList.add('active');
                    treeDropBorder.style.left = rect.left + 'px';
                    treeDropBorder.style.top = top + 'px';
                    treeDropBorder.style.right = (window.innerWidth - rect.right) + 'px';
                    treeDropBorder.style.bottom = (window.innerHeight - bottom) + 'px';
                }

                grid.dragOver = asset;
            };

            var onMouseOut = function() {
                if (! dragging || grid.dragOver !== asset)
                    return;

                gridDropBorder.classList.remove('active');
                treeDropBorder.classList.remove('active');
                grid.dragOver = undefined;
            };

            item.element.addEventListener('mouseout', onMouseOut, false);
            item.tree.elementTitle.addEventListener('mouseout', onMouseOut, false);

            item.element.addEventListener('mouseover', onMouseOver, false);
            item.tree.elementTitle.addEventListener('mouseover', onMouseOver, false);
        }

        var updateTask = function() {
            var status = asset.get('task');
            if (status && typeof(status) === 'string' && status[0] !== '{') {
                item.class.add('task', status);
            } else {
                item.class.remove('task', 'failed', 'running');
            }
        };

        // add task status
        updateTask();
        asset.on('task:set', updateTask);

        item.element.draggable = true;
        item.element.addEventListener('dragstart', onDragStart, false);

        assetsIndex[asset.get('id')] = item;

        // source
        if (asset.get('source'))
            item.class.add('source');

        if (! editor.call('assets:panel:filter:default')('asset', asset))
            item.hidden = true;

        var fileSize = asset.get('file.size');

        if (! asset.get('source')) {
            // update thumbnails change
            asset.on('thumbnails.m:set', function(value) {
                if (value.startsWith('/api'))
                    value += '?t=' + asset.get('file.hash');

                thumbnail.style.backgroundImage = 'url(' + value + ')';
                thumbnail.classList.remove('placeholder');
            });

            asset.on('thumbnails.m:unset', function() {
                thumbnail.style.backgroundImage = 'none';
                thumbnail.classList.add('placeholder');
            });
        }

        // folder open
        if (asset.get('type') === 'folder') {
            item.element.addEventListener('dblclick', function() {
                tree.clear();
                item.tree.open = true;
                editor.call('assets:filter:search', '');
                editor.call('assets:panel:currentFolder', item.asset);

                // change back selection
                if (selector.type)
                    editor.call('selector:set', selector.prev.type, selector.prev.items);
            }, false);
        }

        var thumbnail = item.thumbnail = document.createElement('div');
        thumbnail.classList.add('thumbnail');
        item.element.appendChild(thumbnail);

        if (asset.has('thumbnails') && ! asset.get('source')) {
            thumbnail.style.backgroundImage = 'url("' + config.url.home + asset.get('thumbnails.m') + '")';
        } else {
            thumbnail.classList.add('placeholder');
        }

        var icon = document.createElement('div');
        icon.classList.add('icon');
        item.element.appendChild(icon);

        var label = item.labelElement = document.createElement('div');
        label.classList.add('label');
        label.textContent = asset.get('name');
        item.element.appendChild(label);

        // update name/filename change
        var evtNameSet = asset.on('name:set', function(name, nameOld) {
            // grid
            label.textContent = this.get('name');
            // tree
            if (item.tree) {
                item.tree.text = this.get('name');

                // resort element (move match alphabetical order)
                var parent = item.tree.parent;
                item.tree.parent.element.removeChild(item.tree.element);
                var closest = treeFindClosest(parent, item.tree, nameOld);
                if (closest === -1) {
                    parent.element.appendChild(item.tree.element);
                } else {
                    parent.element.insertBefore(item.tree.element, parent.child(closest));
                }

                resizeTree();
            }

            keepScriptsAtTop();
        });

        var evtPathSet = asset.on('path:set', function(path, pathOld) {
            // show or hide based on filters
            item.hidden = ! editor.call('assets:panel:filter:default')('asset', this);

            if (item.tree) {
                if (! pathOld.length || ! path.length || path[path.length - 1] !== pathOld[pathOld.length - 1]) {
                    item.tree.parent.remove(item.tree);
                    var parent;

                    if (path.length) {
                        parent = assetsIndex[path[path.length - 1]].tree;
                    } else {
                        parent = treeRoot;
                    }

                    var closest = treeFindClosest(parent, item.tree);
                    if (closest === -1) {
                        parent.append(item.tree);
                    } else {
                        parent.appendBefore(item.tree, parent.child(closest).ui);
                    }
                }

                if (currentFolder === asset)
                    editor.emit('assets:panel:currentFolder', currentFolder);
            }

            keepScriptsAtTop();
        });

        if (! asset.get('source')) {
            // used event
            var evtUnused = editor.on('assets:used:' + asset.get('id'), function(state) {
                if (state) {
                    item.class.remove('unused');
                } else {
                    item.class.add('unused');
                }
            });
            // used state
            if (! editor.call('assets:used:get', asset.get('id')))
                item.class.add('unused');

            // clean events
            item.once('destroy', function() {
                evtUnused.unbind();
            });
        }

        // clean events
        item.once('destroy', function() {
            editor.call('selector:remove', asset);
            evtNameSet.unbind();
            evtPathSet.unbind();
            delete assetsIndex[asset.get('id')];
        });

        // append to grid
        var assets = editor.call('assets:raw');
        if (pos === -1 || ! assets.data[pos + 1]) {
            grid.append(item);
        } else {
            grid.appendBefore(item, assetsIndex[assets.data[pos + 1].get('id')]);
        }

        resizeTree();

        keepScriptsAtTop();
    });

    var keepScriptsAtTop = function() {
        // resort scripts folder in grid
        gridScripts.element.parentNode.removeChild(gridScripts.element);
        var first = grid.element.firstChild;
        if (first) {
            grid.element.insertBefore(gridScripts.element, first);
        } else {
            grid.element.appendChild(gridScripts.element);
        }

        // resort scripts folder in tree
        treeScripts.element.parentNode.removeChild(treeScripts.element);
        var next = treeRoot.elementTitle.nextSibling;
        if (next) {
            treeRoot.element.insertBefore(treeScripts.element, next);
        } else {
            treeRoot.element.appendChild(treeScripts.element);
        }
    };

    editor.on('assets:move', function(asset, pos) {
        var item = assetsIndex[asset.get('id')];
        // remove
        grid.element.removeChild(item.element);
        // append
        if (pos === -1) {
            // to end
            grid.append(item);
        } else {
            // before another element
            grid.appendBefore(item, assetsIndex[editor.call('assets:raw').data[pos + 1].get('id')]);
        }
    });

    editor.on('assets:remove', function(asset) {
        var treeItem = assetsIndex[asset.get('id')].tree;
        if (treeItem) {
            if (treeItem.parent)
                treeItem.parent.remove(treeItem);
            treeItem.destroy();
        }

        assetsIndex[asset.get('id')].destroy();

        resizeTree();

        // reselect current directory, if selected was removed
        if (currentFolder && typeof(currentFolder) !== 'string') {
            var id = parseInt(currentFolder.get('id'), 10);
            var path = asset.get('path');
            var ind = path.indexOf(id);
            if (id === parseInt(asset.get('id'), 10) || ind !== -1) {
                if (ind === -1)
                    ind = path.length - 1;

                var found = false;
                i = ind + 1;
                while(i--) {
                    if (assetsIndex[path[i]]) {
                        found = true;
                        editor.call('assets:panel:currentFolder', assetsIndex[path[i]].asset);
                        break;
                    }
                }

                if (! found)
                    editor.call('assets:panel:currentFolder', null);
            }
        }
    });

    var addSourceFile = function(file) {
        file.set('type', 'script');

        var item = new ui.GridItem();
        item.script = file;
        item.class.add('type-script');
        grid.append(item);

        if (! editor.call('assets:panel:filter:default')('script', file))
            item.hidden = true;

        scriptsIndex[file.get('filename')] = item;

        var thumbnail = document.createElement('div');
        thumbnail.classList.add('thumbnail', 'placeholder');
        item.element.appendChild(thumbnail);

        var icon = document.createElement('div');
        icon.classList.add('icon');
        item.element.appendChild(icon);

        var label = item.labelElement = document.createElement('div');
        label.classList.add('label');
        label.textContent = file.get('filename');
        item.element.appendChild(label);

        // update name/filename change
        var evtNameSet = file.on('filename:set', function(value, valueOld) {
            label.textContent = value;
            scriptsIndex[value] = item;
            delete scriptsIndex[valueOld];
        });
        item.on('destroy', function() {
            editor.call('selector:remove', file);
            evtNameSet.unbind();
            delete scriptsIndex[file.get('filename')];
        });
        file.on('destroy', function() {
            item.destroy();
        });

        editor.call('drop:item', {
            element: item.element,
            type: 'asset.script',
            data: {
                filename: file.get('filename')
            }
        });
    };
    var removeSourceFile = function(file) {
        file.destroy();
    };

    editor.on('sourcefiles:add', addSourceFile);
    editor.on('sourcefiles:remove', removeSourceFile);
});


/* editor/assets/assets-panel-control.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');
    var assetsPanel = editor.call('layout.assets');

    // context menu
    var menu = new ui.Menu();
    root.append(menu);

    var assets = {
        'upload': {
            title: 'Upload',
            icon: '&#57909;'
        },
        'folder': {
            title: 'Folder',
            icon: '&#57657;'
        },
        'css': {
            title: 'CSS',
            icon: '&#57864;'
        },
        'cubemap': {
            title: 'CubeMap',
            icon: '&#57879;'
        },
        'html': {
            title: 'HTML',
            icon: '&#57864;'
        },
        'json': {
            title: 'JSON',
            icon: '&#57864;'
        },
        'material': {
            title: 'Material',
            icon: '&#57749;'
        },
        'script': {
            title: 'Script',
            icon: '&#57864;'
        },
        'shader': {
            title: 'Shader',
            icon: '&#57864;'
        },
        'text': {
            title: 'Text',
            icon: '&#57864;'
        }
    };

    var addNewMenuItem = function(key, data) {
        // new folder
        var item = new ui.MenuItem({
            text: data.title,
            icon: data.icon || '',
            value: key
        });
        item.on('select', function() {
            var args = {
                parent: editor.call('assets:panel:currentFolder')
            };

            if (key === 'upload') {
                editor.call('assets:upload:picker', args);
            } else if (key === 'script') {
                editor.call('sourcefiles:new');
            } else {
                editor.call('assets:create:' + key, args)
            }
        });
        menu.append(item);

        if (key === 'script') {
            editor.on('repositories:load', function (repositories) {
                if (repositories.get('current') !== 'directory')
                    item.disabled = true;
            });
        }
    };

    var keys = Object.keys(assets);
    for(var i = 0; i < keys.length; i++) {
        if (! assets.hasOwnProperty(keys[i]))
            continue;

        addNewMenuItem(keys[i], assets[keys[i]]);
    }

    // // upload
    // var menuUpload = new ui.MenuItem({
    //     text: 'Upload',
    //     value: 'upload'
    // });
    // menuUpload.on('select', function() {
    //     editor.call('assets:upload:picker');
    // });
    // menu.append(menuUpload);

    // // folder
    // var menuFolder = new ui.MenuItem({
    //     text: 'New Folder',
    //     value: 'folder'
    // });
    // menuFolder.on('select', function() {
    //     editor.call('assets:create:folder');
    // });
    // menu.append(menuFolder);

    // // css
    // var menuCss = new ui.MenuItem({
    //     text: 'New Css',
    //     value: 'css'
    // });
    // menuCss.on('select', function () {
    //     editor.call('assets:create:css');
    // });
    // menu.append(menuCss);

    // // cubemap
    // var menuCubemap = new ui.MenuItem({
    //     text: 'New CubeMap',
    //     value: 'cubemap'
    // });
    // menuCubemap.on('select', function() {
    //     editor.call('assets:create:cubemap');
    // });
    // menu.append(menuCubemap);

    // // html
    // var menuHtml = new ui.MenuItem({
    //     text: 'New Html',
    //     value: 'html'
    // });
    // menuHtml.on('select', function () {
    //     editor.call('assets:create:html');
    // });
    // menu.append(menuHtml);

    // // json
    // var menuJson = new ui.MenuItem({
    //     text: 'New Json',
    //     value: 'json'
    // });
    // menuJson.on('select', function () {
    //     editor.call('assets:create:json');
    // });
    // menu.append(menuJson);

    // // material
    // var menuMaterial = new ui.MenuItem({
    //     text: 'New Material',
    //     value: 'material'
    // });
    // menuMaterial.on('select', function() {
    //     editor.call('assets:create:material');
    // });
    // menu.append(menuMaterial);

    // // script
    // var menuScript = new ui.MenuItem({
    //     text: 'New Script',
    //     value: 'script'
    // });
    // menuScript.on('select', function () {
    //     editor.call('sourcefiles:new');
    // });
    // menu.append(menuScript);

    // editor.on('repositories:load', function (repositories) {
    //     if (repositories.get('current') !== 'directory')
    //         menuScript.disabled = true;
    // });

    // // shader
    // var menuShader = new ui.MenuItem({
    //     text: 'New Shader',
    //     value: 'shader'
    // });
    // menuShader.on('select', function () {
    //     editor.call('assets:create:shader');
    // });
    // menu.append(menuShader);

    // // text
    // var menuText = new ui.MenuItem({
    //     text: 'New Text',
    //     value: 'text'
    // });
    // menuText.on('select', function () {
    //     editor.call('assets:create:text');
    // });
    // menu.append(menuText);

    // controls
    var controls = new ui.Panel();
    controls.enabled = false;
    controls.class.add('assets-controls');
    controls.parent = assetsPanel;
    assetsPanel.headerElement.insertBefore(controls.element, assetsPanel.headerElementTitle.nextSibling);
    editor.on('permissions:writeState', function(state) {
        controls.enabled = state;
    });


    // add
    var btnNew = new ui.Button();
    btnNew.class.add('create-asset');
    btnNew.text = '&#57632;';
    btnNew.on('click', function(evt) {
        var rect = btnNew.element.getBoundingClientRect();
        menu.position(rect.right, rect.top);
        menu.open = true;
    });
    controls.append(btnNew);

    var tooltipAdd = Tooltip.attach({
        target: btnNew.element,
        text: 'Add Asset',
        align: 'bottom',
        root: root
    });
    menu.on('open', function(state) {
        tooltipAdd.disabled = state;
    });

    // delete
    var btnDelete = new ui.Button({
        text: '&#57636;'
    });
    btnDelete.style.fontWeight = 200;
    btnDelete.disabled = true;
    btnDelete.class.add('delete');
    btnDelete.on('click', function() {
        if (! editor.call('permissions:write'))
            return;

        var type = editor.call('selector:type');
        if (type !== 'asset')
            return;

        editor.call('assets:delete:picker', editor.call('selector:items'));
    });
    controls.append(btnDelete);

    var tooltipDelete = Tooltip.attach({
        target: btnDelete.element,
        text: 'Delete Asset',
        align: 'bottom',
        root: root
    });
    tooltipDelete.class.add('innactive');


    editor.on('attributes:clear', function() {
        // btnDuplicate.disabled = true;
        btnDelete.disabled = true;
        tooltipDelete.class.add('innactive');
    });

    editor.on('attributes:inspect[*]', function(type) {
        if (type.startsWith('asset')) {
            btnDelete.enabled = true;
            tooltipDelete.class.remove('innactive');
        } else {
            btnDelete.enabled = false;
            tooltipDelete.class.add('innactive');
        }
        // btnDuplicate.enabled = type === 'asset.material';
    });
});


/* editor/assets/assets-context-menu.js */
editor.once('load', function() {
    'use strict';

    var currentAsset = null;
    var root = editor.call('layout.root');

    // menu
    var menu = new ui.Menu();
    root.append(menu);


    // edit
    var menuItemNewScript = new ui.MenuItem({
        text: 'New Script',
        icon: '&#57864;',
        value: 'script'
    });
    menuItemNewScript.on('select', function() {
        editor.call('sourcefiles:new');
    });
    menu.append(menuItemNewScript);


    // new asset
    var menuItemNew = new ui.MenuItem({
        text: 'New Asset',
        icon: '&#57632;',
        value: 'new'
    });
    menu.append(menuItemNew);

    var assets = {
        'upload': {
            title: 'Upload',
            icon: '&#57909;'
        },
        'folder': {
            title: 'Folder',
            icon: '&#57657;'
        },
        'css': {
            title: 'CSS',
            icon: '&#57864;'
        },
        'cubemap': {
            title: 'CubeMap',
            icon: '&#57879;'
        },
        'html': {
            title: 'HTML',
            icon: '&#57864;'
        },
        'json': {
            title: 'JSON',
            icon: '&#57864;'
        },
        'material': {
            title: 'Material',
            icon: '&#57749;'
        },
        'script': {
            title: 'Script',
            icon: '&#57864;'
        },
        'shader': {
            title: 'Shader',
            icon: '&#57864;'
        },
        'text': {
            title: 'Text',
            icon: '&#57864;'
        }
    };

    var addNewMenuItem = function(key, data) {
        // new folder
        var item = new ui.MenuItem({
            text: data.title,
            icon: data.icon || '',
            value: key
        });
        item.on('select', function() {
            var args = { };

            if (currentAsset && currentAsset.get('type') === 'folder') {
                args.parent = currentAsset;
            } else if (currentAsset === undefined) {
                args.parent = editor.call('assets:panel:currentFolder');
            }

            if (key === 'upload') {
                editor.call('assets:upload:picker', args);
            } else if (key === 'script') {
                editor.call('sourcefiles:new');
            } else {
                editor.call('assets:create:' + key, args)
            }
        });
        menuItemNew.append(item);

        if (key === 'script') {
            editor.on('repositories:load', function (repositories) {
                if (repositories.get('current') !== 'directory')
                    item.disabled = true;
            });
        }
    };

    var keys = Object.keys(assets);
    for(var i = 0; i < keys.length; i++) {
        if (! assets.hasOwnProperty(keys[i]))
            continue;

        addNewMenuItem(keys[i], assets[keys[i]]);
    }


    // edit
    var menuItemEdit = new ui.MenuItem({
        text: 'Edit',
        icon: '&#57648;',
        value: 'edit'
    });
    menuItemEdit.on('select', function() {
        editor.call('assets:edit', currentAsset);
    });
    menu.append(menuItemEdit);


    // duplicate
    var menuItemDuplicate = new ui.MenuItem({
        text: 'Duplicate',
        icon: '&#57638;',
        value: 'duplicate'
    });
    menuItemDuplicate.on('select', function() {
        editor.call('assets:duplicate', currentAsset);
    });
    menu.append(menuItemDuplicate);


    // delete
    var menuItemDelete = new ui.MenuItem({
        text: 'Delete',
        icon: '&#57636;',
        value: 'delete'
    });
    menuItemDelete.style.fontWeight = 200;
    menuItemDelete.on('select', function() {
        var asset = currentAsset;
        var multiple = false;

        if (asset) {
            var assetType = asset.get('type');
            var type = editor.call('selector:type');
            var items;

            if (type === 'asset') {
                items = editor.call('selector:items');
                for(var i = 0; i < items.length; i++) {
                    if ((assetType === 'script' && items[i].get('filename') === asset.get('filename')) || (assetType !== 'script' && items[i].get('id') === asset.get('id'))) {
                        multiple = true;
                        break;
                    }
                }
            }

            editor.call('assets:delete:picker', multiple ? items : [ asset ]);
        }
    });
    menu.append(menuItemDelete);


    // filter buttons
    menu.on('open', function() {
        menuItemNewScript.hidden = ! ((currentAsset === null || (currentAsset && currentAsset.get('type') === 'script')) && editor.call('assets:panel:currentFolder') === 'scripts');
        menuItemNew.hidden = ! menuItemNewScript.hidden;

        if (currentAsset) {
            // duplicate
            if (currentAsset.get('type') === 'material') {
                menuItemEdit.hidden = true;
                if (editor.call('selector:type') === 'asset') {
                    var items = editor.call('selector:items');
                    menuItemDuplicate.hidden = (items.length > 1 && items.indexOf(currentAsset) !== -1);
                } else {
                    menuItemDuplicate.hidden = false;
                }
            } else {
                menuItemDuplicate.hidden = true;
            }

            // edit
            if (! currentAsset.get('source') && ['html', 'css', 'json', 'text', 'script', 'shader'].indexOf(currentAsset.get('type')) !== -1) {
                if (editor.call('selector:type') === 'asset') {
                    var items = editor.call('selector:items');
                    menuItemEdit.hidden = (items.length > 1 && items.indexOf(currentAsset) !== -1);
                } else {
                    menuItemEdit.hidden = false;
                }
            } else {
                menuItemEdit.hidden = true;
            }

            // delete
            menuItemDelete.hidden = false;
        } else {
            // no asset
            menuItemDuplicate.hidden = true;
            menuItemEdit.hidden = true;
            menuItemDelete.hidden = true;
        }
    });


    // for each asset added
    editor.on('assets:add', function(asset) {
        // get grid item
        var item = editor.call('assets:panel:get', asset.get('id'));
        if (! item) return;

        var contextMenuHandler = function(evt) {
            evt.stopPropagation();
            evt.preventDefault();

            if (! editor.call('permissions:write'))
                return;

            currentAsset = asset;
            menu.open = true;
            menu.position(evt.clientX + 1, evt.clientY);
        };

        // grid
        item.element.addEventListener('contextmenu', contextMenuHandler, false);

        // tree
        if (item.tree)
            item.tree.elementTitle.addEventListener('contextmenu', contextMenuHandler, false);
    });

    editor.on('sourcefiles:add', function(asset) {
        // get grid item
        var item = editor.call('assets:panel:get', asset.get('filename'));
        if (! item) return;

        // attach contextmenu event
        item.element.addEventListener('contextmenu', function(evt) {
            evt.stopPropagation();
            evt.preventDefault();

            if (! editor.call('permissions:write'))
                return;

            currentAsset = asset;
            menu.open = true;
            menu.position(evt.clientX + 1, evt.clientY);
        });
    });


    // folders
    editor.call('assets:panel:folders').innerElement.addEventListener('contextmenu', function(evt) {
        evt.preventDefault();
        evt.stopPropagation();

        if (! editor.call('permissions:write'))
            return;

        currentAsset = undefined;
        menu.open = true;
        menu.position(evt.clientX + 1, evt.clientY);
    }, false);

    // files
    editor.call('assets:panel:files').innerElement.addEventListener('contextmenu', function(evt) {
        evt.preventDefault();
        evt.stopPropagation();

        if (! editor.call('permissions:write'))
            return;

        currentAsset = null;
        menu.open = true;
        menu.position(evt.clientX + 1, evt.clientY);
    }, false);
});


/* editor/assets/assets-store.js */
editor.once('load', function () {
    'use strict';

    var assetsPanel = editor.call('layout.assets');

    var btnStore = new ui.Button({
        text: "Library"
    });
    btnStore.class.add('store');
    assetsPanel.headerAppend(btnStore);

    btnStore.on('click', function () {
        window.open('https://store.playcanvas.com/', '_blank');
    });
});


/* editor/assets/assets-filter.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');
    var assetsPanel = editor.call('layout.assets');
    var currentFolder = null;
    var currentPath = [ ];

    // filters
    var panelFilters = new ui.Panel();
    panelFilters.class.add('filters');
    assetsPanel.headerAppend(panelFilters);

    var filter = function(type, item) {
        if (! item)
            return false;

        var visible = true;

        // type
        if (visible && filterField.value !== 'all') {
            if (type === 'asset') {
                visible = item.get('type') === filterField.value;
            } else if (type === 'script') {
                visible = filterField.value === 'script';
            }
        }

        // query
        if (visible && search.value) {
            var name = (type === 'scripts') ? item : item.get(type === 'asset' ? 'name' : 'filename');
            var normalSearch = true;

            if (search.value[0] === '*' && search.value.length > 1) {
                try {
                    visible = (new RegExp(search.value.slice(1), 'i')).test(name);
                    normalSearch = false;
                } catch(ex) { }
            }

            if (normalSearch)
                visible = name.toLowerCase().indexOf(search.value.toLowerCase()) !== -1;
        }

        // folder
        if (visible && ! search.value) {
            if (type === 'script' || currentFolder === 'scripts') {
                visible = currentFolder === 'scripts' && type === 'script';
            } else if (type === 'scripts') {
                visible = ! currentFolder && filterField.value === 'all';
            } else {
                var path = item.get('path');
                if (currentFolder === null) {
                    visible = path.length === 0;
                } else {
                    visible = (path.length === currentPath.length + 1) && path[path.length - 1] === currentFolder;
                }
            }
        }

        return visible;
    };
    editor.method('assets:panel:filter:default', function() {
        return filter;
    });


    // options
    var filterField = new ui.SelectField({
        options: {
            all: 'All',
            animation: 'Animation',
            audio: 'Audio',
            cubemap: 'Cubemap',
            css: 'Css',
            json: 'Json',
            html: 'Html',
            material: 'Material',
            model: 'Model',
            script: 'Script',
            shader: 'Shader',
            text: 'Text',
            texture: 'Texture'
        }
    });
    filterField.class.add('options');
    filterField.value = 'all';
    filterField.renderChanges = false;
    panelFilters.append(filterField);

    filterField.on('change', function(value) {
        if (value !== 'all') {
            filterField.class.add('not-empty');
        } else {
            filterField.class.remove('not-empty');
        }
        editor.call('assets:panel:filter', filter);
    });

    var tooltipFilter = Tooltip.attach({
        target: filterField.element,
        text: 'Filter Assets',
        align: 'bottom',
        root: root
    });
    filterField.on('open', function() {
        tooltipFilter.disabled = true;
    });
    filterField.on('close', function() {
        tooltipFilter.disabled = false;
    });

    editor.method('assets:filter:search', function(query) {
        if (query === undefined)
            return search.value;

        search.value = query;
    });

    editor.method('assets:filter:type', function(type) {
        if (type === undefined)
            return filterField.value;

        filterField.value = type || 'all';
    });

    editor.method('assets:filter:type:disabled', function(state) {
        filterField.disabled = state;
    });

    editor.on('assets:panel:currentFolder', function(asset) {
        if (asset) {
            if (typeof(asset) === 'string') {
                currentFolder = 'scripts';
                currentPath = null;
            } else {
                currentFolder = parseInt(asset.get('id'));
                currentPath = asset.get('path');
            }
        } else {
            currentFolder = null;
            currentPath = null;
        }
        editor.call('assets:panel:filter', filter);
    });

    editor.on('assets:add', function(asset) {
        if (filterField.value === 'all' && ! search.value)
            return;

        if (! filter((asset.get('type') === 'script') ? 'script' : 'asset', asset))
            editor.call('assets:panel:get', asset.get('id')).hidden = true;
        else
            editor.call('assets:panel:message', null); // clear possible no assets message
    });

    editor.on('sourcefiles:add', function (file) {
        if (filterField.value === 'all' && ! search.value)
            return;

        if (! filter('script', file))
            editor.call('assets:panel:get', file.get('filename')).hidden = true;
        else
            editor.call('assets:panel:message', null); // clear possible no assets message

    });

    // search
    var search = new ui.TextField({
        placeholder: 'Search'
    });
    search.keyChange = true;
    search.class.add('search');
    search.renderChanges = false;
    panelFilters.append(search);

    var searchClear = document.createElement('div');
    searchClear.innerHTML = '&#57650;';
    searchClear.classList.add('clear');
    search.element.appendChild(searchClear);

    searchClear.addEventListener('click', function() {
        search.value = '';
    }, false);

    search.on('change', function(value) {
        value = value.trim();

        if (value) {
            search.class.add('not-empty');
        } else {
            search.class.remove('not-empty');
        }

        editor.call('assets:panel:filter', filter);
    });

    Tooltip.attach({
        target: search.element,
        text: 'Search Assets',
        align: 'bottom',
        root: root
    });
});


/* editor/assets/assets-upload.js */
editor.once('load', function() {
    'use strict';

    var uploadJobs = 0;

    editor.method('assets:canUploadFiles', function (files) {
        // check usage first
        var totalSize = 0;
        for(var i = 0; i < files.length; i++) {
            totalSize += files[i].size;
        }

        return config.owner.size + totalSize <= config.owner.diskAllowance;
    });

    editor.method('assets:uploadFile', function (args, fn) {
        // NOTE
        // non-file form data should be above file,
        // to make it parsed on back-end first

        var form = new FormData();

        // name
        if (args.name)
            form.append('name', args.name);

        // update asset
        if (args.asset)
            form.append('asset', args.asset.get('id'));

        // parent folder
        if (args.parent && (args.parent instanceof Observer))
            form.append('parent', args.parent.get('id'));

        // type
        if (args.type)
            form.append('type', args.type);

        // data
        if (args.data)
            form.append('data', JSON.stringify(args.data));

        // preload
        form.append('preload', true);

        // file
        if (args.file && args.file.size)
            form.append('file', args.file, args.filename || args.name);

        var job = ++uploadJobs;
        editor.call('status:job', 'asset-upload:' + job, 0);

        var data = {
            url: '/editor/project/{{project.id}}/asset-upload',
            method: 'POST',
            query: {
                'access_token': '{{accessToken}}'
            },
            data: form,
            ignoreContentType: true,
            headers: {
                Accept: 'application/json'
            }
        };

        Ajax(data)
        .on('load', function(status, data) {
            editor.call('status:text', data);
            editor.call('status:job', 'asset-upload:' + job);
            if (fn)
                fn(null, data);
        })
        .on('progress', function(progress) {
            editor.call('status:job', 'asset-upload:' + job, progress);
        })
        .on('error', function(status, data) {
            if (/Disk allowance/.test(data))
                data += '. <a href="/upgrade" target="_blank">UPGRADE</a> to get more disk space.';

            editor.call('status:error', data);
            editor.call('status:job', 'asset-upload:' + job);
            if (fn)
                fn(data);
        });
    });

    editor.method('assets:upload:picker', function(args) {
        args = args || { };

        var parent = args.parent || editor.call('assets:panel:currentFolder');

        var fileInput = document.createElement('input');
        fileInput.type = 'file';
        // fileInput.accept = '';
        fileInput.multiple = true;
        fileInput.style.display = 'none';
        editor.call('layout.assets').append(fileInput);

        var onChange = function() {
            if (! editor.call('assets:canUploadFiles', this.files)) {
                var msg = 'Disk allowance exceeded. <a href="/upgrade" target="_blank">UPGRADE</a> to get more disk space.';
                editor.call('status:error', msg);
                return;
            }

            for(var i = 0; i < this.files.length; i++) {
                editor.call('assets:uploadFile', {
                    file: this.files[i],
                    name: this.files[i].name,
                    parent: parent
                });
            }
            this.value = null;
            fileInput.removeEventListener('change', onChange);
        };

        fileInput.addEventListener('change', onChange, false);
        fileInput.click();

        fileInput.parentNode.removeChild(fileInput);
    });
});


/* editor/assets/assets-drop.js */
editor.once('load', function() {
    'use strict';

    var assetsPanel = editor.call('layout.assets');

    var targetExtensions = [ 'jpg', 'jpeg', 'png', 'css', 'html', 'json', 'xml', 'txt', 'vert', 'frag', 'glsl', 'mp3', 'ogg', 'wav', 'mp4' ];
    var tmp = { };
    for(var i = 0; i < targetExtensions.length; i++)
        tmp[targetExtensions[i]] = true;
    targetExtensions = tmp;

    var typeToExt = {
        'scene': [ 'fbx', 'dae', 'obj', '3ds' ],
        'text': [ 'txt', 'xml' ],
        'html': [ 'html' ],
        'css': [ 'css' ],
        'json': [ 'json' ],
        'texture': [ 'tif', 'tga', 'png', 'jpg', 'jpeg', 'gif', 'bmp', 'dds', 'hdr', 'exr' ],
        'audio': [ 'wav', 'mp3', 'mp4', 'ogg' ],
        'shader': [ 'glsl', 'frag', 'vert' ]
    };
    var extToType = { };
    for(var type in typeToExt) {
        for(var i = 0; i < typeToExt[type].length; i++) {
            extToType[typeToExt[type][i]] = type;
        }
    }

    var dropRef = editor.call('drop:target', {
        ref: assetsPanel.element,
        type: 'files',
        drop: function(type, data) {
            if (type !== 'files')
                return;

            if (! editor.call('assets:canUploadFiles', data)) {
                var msg = 'Disk allowance exceeded. <a href="/upgrade" target="_blank">UPGRADE</a> to get more disk space.';
                editor.call('status:error', msg);
                return;
            }

            for(var i = 0; i < data.length; i++) {
                var currentFolder = editor.call('assets:panel:currentFolder');
                var path = [ ];

                if (currentFolder)
                    path = currentFolder.get('path').concat(parseInt(currentFolder.get('id'), 10));

                var source = false;
                var ext = data[i].name.split('.');
                if (ext.length === 1)
                    continue;
                ext = ext[ext.length - 1].toLowerCase();

                var source = ! targetExtensions[ext];
                var type = extToType[ext];

                // can we override another asset?
                var asset = editor.call('assets:findOne', function(item) {
                    return item.get('name').toLowerCase() === data[i].name.toLowerCase() && item.get('path').match(path) && item.get('source') === source && item.get('type') === type;
                });

                editor.call('assets:uploadFile', {
                    asset: asset ? asset[1] : null,
                    file: data[i],
                    name: data[i].name,
                    parent: editor.call('assets:panel:currentFolder')
                });
            }
        }
    });

    dropRef.element.classList.add('assets-drop-area');
});


/* editor/assets/assets-messenger.js */
editor.once('load', function() {
    'use strict';

    var create = function(data) {
        var assetId = data.asset.id;

        if (data.asset.source === false && data.asset.status && data.asset.status !== 'complete')
            return;

        var asset = editor.call('assets:get', assetId);
        if (asset)
            return;

        editor.call('loadAsset', assetId);
    };

    // create new asset
    editor.on('messenger:asset.new', create);

    // remove
    editor.on('messenger:asset.delete', function(data) {
        var asset = editor.call('assets:get', data.asset.id);
        if (! asset) return;
        editor.call('assets:remove', asset);
    });

    // remove multiple
    editor.on('messenger:assets.delete', function(data) {
        for(var i = 0; i < data.assets.length; i++) {
            var asset = editor.call('assets:get', parseInt(data.assets[i], 10));
            if (! asset) continue;
            editor.call('assets:remove', asset);
        }
    });
});


/* editor/assets/assets-delete.js */
editor.once('load', function() {
    'use strict';

    editor.method('assets:delete:picker', function(items) {
        if (! editor.call('permissions:write'))
            return;

        var msg = 'Delete Asset?';

        if (items.length === 1 && items[0].get('type') === 'folder')
            msg = 'Delete Folder?';

        if (items.length > 1)
            msg = 'Delete ' + items.length + ' Assets?';

        editor.call('picker:confirm:class', 'asset-delete');

        editor.call('picker:confirm', msg, function() {
            if (! editor.call('permissions:write'))
                return;

            editor.call('assets:delete', items);
        });
    });

    var deleteCallback = function() {
        if (! editor.call('permissions:write'))
            return;

        var type = editor.call('selector:type');
        if (type !== 'asset')
            return;

        editor.call('assets:delete:picker', editor.call('selector:items'));
    };
    // delete
    editor.call('hotkey:register', 'asset:delete', {
        key: 'delete',
        callback: deleteCallback
    });
    // ctrl + backspace
    editor.call('hotkey:register', 'asset:delete', {
        ctrl: true,
        key: 'backspace',
        callback: deleteCallback
    });
});


/* editor/assets/assets-duplicate.js */
editor.once('load', function() {
    'use strict';

    editor.method('assets:duplicate', function(asset) {
        var path = asset.get('path');
        var parent = path.length ? path[path.length - 1] : null;

        var raw = {
            type: 'material',
            name: asset.get('name') + ' Copy',
            source: false,
            data: asset.get('data'),
            preload: asset.get('preload'),
            parent: parent ? editor.call('assets:get', parent) : null,
            scope: {
                type: 'project',
                id: config.project.id
            }
        };

        editor.call('assets:create', raw);
    });
});


/* editor/assets/assets-edit.js */
editor.once('load', function() {
    'use strict';

    editor.method('assets:edit', function (asset) {
        if (asset.get('type') === 'script') {
            window.open('/editor/code/' + config.project.id + '/' + asset.get('filename'));
        } else {
            window.open('/editor/asset/' + asset.get('id'));
        }
    });
});


/* editor/assets/assets-history.js */
editor.once('load', function() {
    'use strict';

    editor.on('assets:add', function(asset) {
        if (asset.history)
            return;

        var id = asset.get('id');

        asset.history = new ObserverHistory({
            item: asset,
            prefix: 'asset.' + id + '.',
            getItemFn: function () {
                return editor.call('assets:get', id);
            }
            // TODO
            // allowed paths
        });

        // record history
        asset.history.on('record', function(action, data) {
            editor.call('history:' + action, data);
        });
    });
});


/* editor/assets/assets-create-folder.js */
editor.once('load', function() {
    'use strict';

    editor.method('assets:create:folder', function (args) {
        if (! editor.call('permissions:write'))
            return;

        args = args || { };

        var asset = {
            name: 'New Folder',
            type: 'folder',
            source: true,
            preload: false,
            data: null,
            parent: (args.parent !== undefined) ? args.parent : editor.call('assets:panel:currentFolder'),
            scope: {
                type: 'project',
                id: config.project.id
            }
        };

        editor.call('assets:create', asset);
    });
});


/* editor/assets/assets-create-material.js */
editor.once('load', function() {
    'use strict';

    editor.method('assets:create:material', function (args) {
        if (! editor.call('permissions:write'))
            return;

        args = args || { };

        var data = editor.call('material:default');

        var asset = {
            name: 'New Material',
            type: 'material',
            source: false,
            preload: true,
            data: data,
            parent: (args.parent !== undefined) ? args.parent : editor.call('assets:panel:currentFolder'),
            scope: {
                type: 'project',
                id: config.project.id
            }
        };

        editor.call('assets:create', asset);
    });
});


/* editor/assets/assets-create-cubemap.js */
editor.once('load', function() {
    'use strict';

    editor.method('assets:create:cubemap', function (args) {
        if (! editor.call('permissions:write'))
            return;

        args = args || { };

        var asset = {
            name: 'New Cubemap',
            type: 'cubemap',
            source: false,
            preload: true,
            parent: (args.parent !== undefined) ? args.parent : editor.call('assets:panel:currentFolder'),
            data: {
                name: 'New Cubemap',
                textures: [ null, null, null, null, null, null ],
                minFilter: 5, // linear mipmap linear
                magFilter: 1, // linear
                anisotropy: 1
            },
            scope: {
                type: 'project',
                id: config.project.id
            }
        };

        editor.call('assets:create', asset);
    });
});


/* editor/assets/assets-create-html.js */
editor.once('load', function() {
    'use strict';

    editor.method('assets:create:html', function (args) {
        if (! editor.call('permissions:write'))
            return;

        args = args || { };

        var asset = {
            name: 'New Html',
            type: 'html',
            source: false,
            preload: true,
            parent: (args.parent !== undefined) ? args.parent : editor.call('assets:panel:currentFolder'),
            filename: 'asset.html',
            file: new Blob([ '\n' ], { type: 'text/html' }),
            scope: {
                type: 'project',
                id: config.project.id
            }
        };

        editor.call('assets:create', asset);
    });
});


/* editor/assets/assets-create-css.js */
editor.once('load', function() {
    'use strict';

    editor.method('assets:create:css', function (args) {
        if (! editor.call('permissions:write'))
            return;

        args = args || { };

        var asset = {
            name: 'New Css',
            type: 'css',
            source: false,
            preload: true,
            parent: (args.parent !== undefined) ? args.parent : editor.call('assets:panel:currentFolder'),
            filename: 'asset.css',
            file: new Blob([ '\n' ], { type: 'text/css' }),
            scope: {
                type: 'project',
                id: config.project.id
            }
        };

        editor.call('assets:create', asset);
    });
});


/* editor/assets/assets-create-json.js */
editor.once('load', function() {
    'use strict';

    editor.method('assets:create:json', function (args) {
        if (! editor.call('permissions:write'))
            return;

        args = args || { };

        var asset = {
            name: 'New Json',
            type: 'json',
            source: false,
            preload: true,
            parent: (args.parent !== undefined) ? args.parent : editor.call('assets:panel:currentFolder'),
            filename: 'asset.json',
            file: new Blob([ '{ }' ], { type: 'application/json' }),
            scope: {
                type: 'project',
                id: config.project.id
            }
        };

        editor.call('assets:create', asset);
    });
});


/* editor/assets/assets-create-text.js */
editor.once('load', function() {
    'use strict';

    editor.method('assets:create:text', function (args) {
        if (! editor.call('permissions:write'))
            return;

        args = args || { };

        var asset = {
            name: 'New Text',
            type: 'text',
            source: false,
            preload: true,
            parent: (args.parent !== undefined) ? args.parent : editor.call('assets:panel:currentFolder'),
            filename: 'asset.txt',
            file: new Blob([ '\n' ], { type: 'text/plain' }),
            scope: {
                type: 'project',
                id: config.project.id
            }
        };

        editor.call('assets:create', asset);
    });
});


/* editor/assets/assets-create-shader.js */
editor.once('load', function() {
    'use strict';

    editor.method('assets:create:shader', function (args) {
        if (! editor.call('permissions:write'))
            return;

        args = args || { };

        var asset = {
            name: 'New Shader',
            type: 'shader',
            source: false,
            preload: true,
            parent: (args.parent !== undefined) ? args.parent : editor.call('assets:panel:currentFolder'),
            filename: 'asset.glsl',
            file: new Blob([ '\n' ], { type: 'text/x-glsl' }),
            scope: {
                type: 'project',
                id: config.project.id
            }
        };

        editor.call('assets:create', asset);
    });
});


/* editor/assets/assets-used.js */
editor.once('load', function() {
    'use strict';

    var index = { };
    var keys = {
        'cubemap': {
            'data.textures.0': true,
            'data.textures.1': true,
            'data.textures.2': true,
            'data.textures.3': true,
            'data.textures.4': true,
            'data.textures.5': true
        },
        'material': {
            'data.aoMap': true,
            'data.diffuseMap': true,
            'data.specularMap': true,
            'data.metalnessMap': true,
            'data.glossMap': true,
            'data.emissiveMap': true,
            'data.opacityMap': true,
            'data.normalMap': true,
            'data.heightMap': true,
            'data.sphereMap': true,
            'data.cubeMap': true,
            'data.lightMap': true
        },
        'model': { },
        'entity': {
            'components.model.materialAsset': true,
            'components.model.asset': true,
            'components.collision.asset': true,
            'components.particlesystem.colorMapAsset': true,
            'components.particlesystem.normalMapAsset': true,
            'components.particlesystem.mesh': true
        },
        'entity-lists': {
            'components.animation.assets': true,
            'components.audiosource.assets': true,
            // 'components.script.scripts': true
        }
    };
    var updateAsset = function(referer, oldId, newId) {
        if (oldId && index[oldId] !== undefined) {
            index[oldId].count--;

            if (index[oldId].ref[referer]) {
                if (editor.call('assets:used:get', referer)) {
                    index[oldId].parent--;
                    if (index[oldId].count !== 0 && index[oldId].parent === 0)
                        editor.emit('assets:used:' + oldId, false);
                }

                index[oldId].ref[referer][0].unbind();
                if (index[oldId].ref[referer][1])
                    index[oldId].ref[referer][1].unbind();

                delete index[oldId].ref[referer];
            }

            if (index[oldId].count === 0)
                editor.emit('assets:used:' + oldId, false);
        }

        if (newId) {
            if (index[newId] === undefined) {
                index[newId] = {
                    count: 0,
                    parent: 0,
                    ref: { }
                };
            }

            index[newId].count++;

            if (! index[newId].ref[referer]) {
                index[newId].ref[referer] = [ ];

                index[newId].ref[referer][0] = editor.on('assets:used:' + referer, function(state) {
                    if (! index[newId])
                        return;

                    index[newId].parent += state * 2 - 1;

                    if (index[newId].parent === 0) {
                        // now not used
                        editor.emit('assets:used:' + newId, false);
                    } else if (index[newId].parent === 1) {
                        // now used
                        editor.emit('assets:used:' + newId, true);
                    }
                });

                // referer can be destroyed
                var item = editor.call('assets:get', referer);
                if (! item)
                    item = editor.call('entities:get', referer);
                if (item) {
                    index[newId].ref[referer][1] = item.once('destroy', function() {
                        updateAsset(referer, newId);
                    });
                }

                if (editor.call('assets:used:get', referer)) {
                    index[newId].parent++;

                    if (index[newId].count !== 1 && index[newId].parent === 1)
                        editor.emit('assets:used:' + newId, true);
                }
            }

            if (index[newId].count === 1 && index[newId].parent)
                editor.emit('assets:used:' + newId, true);
        }
    };
    var onSetMethods = {
        'cubemap': function(path, value, valueOld) {
            if (! keys['cubemap'][path])
                return;

            updateAsset(this.get('id'), valueOld, value);
        },
        'material': function(path, value, valueOld) {
            if (! keys['material'][path])
                return;

            updateAsset(this.get('id'), valueOld, value);
        },
        'model': function(path, value, valueOld) {
            if (path.startsWith('data.mapping.') && path.slice(-8) === 'material')
                updateAsset(this, valueOld, value);

            if (! keys['model'][path])
                return;

            updateAsset(this.get('id'), valueOld, value);
        },
        'model-insert': function(path, value) {
            if (! path.startsWith('data.mapping.'))
                return;

            updateAsset(this.get('id'), null, value);
        },
        'model-remove': function(path, value) {
            if (! path.startsWith('data.mapping.'))
                return;

            updateAsset(this.get('id'), value);
        },
        'entity': function(path, value, valueOld) {
            if (path.startsWith('components.model.mapping.')) {
                var parts = path.split('.');
                if (parts.length !== 4)
                    return;
            } else if (! keys['entity'][path]) {
                return;
            }

            updateAsset(this.get('resource_id'), valueOld, value);
        },
        'entity-unset': function(path, value) {
            if (path.startsWith('components.model.mapping.')) {
                var parts = path.split('.');
                if (parts.length !== 4)
                    return;
            } else if (! keys['entity'][path]) {
                return;
            }

            updateAsset(this.get('resource_id'), value, null);
        },
        'entity-insert': function(path, value) {
            if (path.startsWith('components.script.scripts.')) {
                var parts = path.split('.');
                if (parts.length !== 7 || parts[4] !== 'attributes' || parts[6] !== 'value' || this.get(parts.slice(0, 6).join('.') + '.type') !== 'asset')
                    return;
            } else if (! keys['entity-lists'][path]) {
                return;
            }

            updateAsset(this.get('resource_id'), null, value);
        },
        'entity-remove': function(path, value) {
            if (path.startsWith('components.script.scripts.')) {
                var parts = path.split('.');
                if (parts.length !== 7 || parts[4] !== 'attributes' || parts[6] !== 'value' || this.get(parts.slice(0, 6).join('.') + '.type') !== 'asset')
                    return;
            } else if (! keys['entity-lists'][path]) {
                return;
            }

            updateAsset(this.get('resource_id'), value, null);
        }
    };

    // assets
    editor.on('assets:add', function(asset) {
        if (asset.get('source'))
            return;

        var type = asset.get('type');

        if (type === 'folder')
            return;

        if (onSetMethods[type]) {
            asset.on('*:set', onSetMethods[type]);

            if (onSetMethods[type + '-insert'])
                asset.on('*:insert', onSetMethods[type + '-insert']);

            if (onSetMethods[type + '-remove'])
                asset.on('*:remove', onSetMethods[type + '-remove']);

            for(var key in keys[type]) {
                updateAsset(asset.get('id'), null, asset.get(key));
            }

            if (type === 'model') {
                var mapping = asset.get('data.mapping');
                if (mapping) {
                    for(var i = 0; i < mapping.length; i++) {
                        updateAsset(asset.get('id'), null, mapping[i].material);
                    }
                }
            }
        }
    });

    // entities
    editor.on('entities:add', function(entity) {
        entity.on('*:set', onSetMethods['entity']);
        entity.on('*:unset', onSetMethods['entity-unset']);
        entity.on('*:insert', onSetMethods['entity-insert']);
        entity.on('*:remove', onSetMethods['entity-remove']);

        for(var key in keys['entity'])
            updateAsset(entity.get('resource_id'), null, entity.get(key));

        var mappings = entity.get('components.model.mapping');
        if (mappings) {
            for(var ind in mappings) {
                if (! mappings.hasOwnProperty(ind) || ! mappings[ind])
                    continue;

                updateAsset(entity.get('resource_id'), null, mappings[ind]);
            }
        }
    });

    // scene settings
    var sceneSettings = editor.call('sceneSettings');
    sceneSettings.on('render.skybox:set', function(value, valueOld) {
        updateAsset('sceneSettings', valueOld, value);
    });

    editor.method('assets:used:index', function() {
        return index;
    });
    editor.method('assets:used:get', function(id) {
        if (isNaN(id))
            return true;

        if (! index[id])
            return false;

        return !! (index[id].count && index[id].parent);
    });
});


/* editor/userdata/userdata-realtime.js */
editor.once('load', function() {
    'use strict';

    var userData = null;

    var loadUserData = function () {
        if (! userData && config.scene.id) {
            userData = editor.call('realtime:subscribe:userdata', config.scene.id, config.self.id);
        }
    };

    editor.method('realtime:subscribe:userdata', function (sceneId, userId) {
        var connection = editor.call('realtime:connection');
        var data = connection.get('user_data', '' + sceneId + '_' + userId);

        // error
        data.on('error', function (err) {
            editor.emit('realtime:userdata:error', err);
        });

        // ready to sync
        data.on('ready', function() {
            // notify of operations
            data.on('after op', function(ops, local) {
                if (local) return;

                for (var i = 0; i < ops.length; i++) {
                    if (ops[i].p[0])
                        editor.emit('realtime:userdata:' + userId + ':op:' + ops[i].p[0], ops[i]);
                }
            });

            // notify of scene load
            editor.emit('userdata:' + userId + ':raw', data.getSnapshot());
        });

        // subscribe for realtime events
        data.subscribe();

        if (data.state === 'ready')
            editor.emit('userdata:' + userId + ':raw', data.getSnapshot());

        return data;
    });

    // write userdata operations
    editor.method('realtime:userdata:op', function(op) {
        if (! editor.call('permissions:read') || ! userData)
            return;

        // console.trace();
        // console.log('out: [ ' + Object.keys(op).filter(function(i) { return i !== 'p' }).join(', ') + ' ]', op.p.join('.'));
        // console.log(op)

        userData.submitOp([ op ]);
    });

    // subscribe to permission changes for userdata
    editor.on('permissions:set:' + config.self.id, function () {
        if (editor.call('permissions:read') && config.scene.id) {
            loadUserData();
        } else {
            if (userData) {
                userData.destroy();
                userData = null;
            }
        }
    });

    editor.on('realtime:disconnected', function () {
        if (userData) {
            userData.destroy();
            userData = null;
        }
    });

    editor.on('scene:unload', function () {
        if (userData) {
            userData.destroy();
            userData = null;
        }
    });

    editor.on('scene:raw', function () {
        if (editor.call('permissions:read'))
            loadUserData();
    });

});


/* editor/userdata/userdata.js */
editor.once('load', function() {
    'use strict';

    var userdata = new Observer();

    editor.on('userdata:' + config.self.id + ':raw', function (data) {

        userdata.sync = new ObserverSync({
            item: userdata,
            paths: [ 'cameras' ]
        });

        // client > server
        var evt = userdata.sync.on('op', function(op) {
            if (op.oi === null) {
                console.error('Tried to send invalid userdata op', op);
                return;
            }

            editor.call('realtime:userdata:op', op);
        });

        editor.once('scene:unload', function () {
            if (evt) {
                evt.unbind();
                evt = null;
            }
        });

        editor.once('realtime:disconnected', function () {
            if (evt) {
                evt.unbind();
                evt = null;
            }
        });

        userdata.sync.enabled = false;
        userdata.patch(data);
        userdata.sync.enabled = true;

        editor.emit('userdata:load', userdata);
    });

    editor.method('userdata', function () {
        return userdata;
    });
});


/* editor/scenes/scenes.js */
editor.once('load', function () {
    'use strict';

    // Fetch list of scenes from the server and
    // pass them to the callback
    editor.method('scenes:list', function (callback) {
        Ajax.get('{{url.api}}/projects/{{project.id}}/scenes?access_token={{accessToken}}')
        .on('load', function (status, data) {
            if (callback)
                callback(data.response);
        });
    });

    // Get a specific scene from the server and pass result to callback
    editor.method('scenes:get', function (sceneId, callback) {
        Ajax.get('{{url.api}}/scenes/' + sceneId + '?access_token={{accessToken}}')
        .on('load', function (status, data) {
            if (callback)
                callback(data.response[0]);
        });
    });

    // Create a scene and pass result to callback
    editor.method('scenes:new', function (callback) {
        Ajax.post('{{url.api}}/scenes?access_token={{accessToken}}', {project_id: config.project.id})
        .on('load', function (status, data) {
            if (callback)
                callback(data.response[0]);
        });
    });

    // Duplicate scene and pass result to callback
    editor.method('scenes:duplicate', function (sceneId, newName, callback) {
        Ajax.post('{{url.api}}/scenes?access_token={{accessToken}}', {
            project_id: config.project.id,
            duplicate_from: sceneId,
            name: newName
        })
        .on('load', function (status, data) {
            if (callback)
                callback(data.response[0]);
        });
    });


    // Delete a scene
    editor.method('scenes:delete', function (sceneId, callback) {
        Ajax.delete('{{url.api}}/scenes/' + sceneId + '?access_token={{accessToken}}')
        .on('load', function (status, data) {
            if (callback)
                callback();
        });
    });

});

/* editor/scenes/scenes-load.js */
editor.once('load', function () {
    'use strict';

    var pushState = true;

    var deletedScenes = {};

    // Load scene with specified id. If isNew is true
    // then scene settings will open right after loading the new scene
    editor.method('scene:load', function (id, isNew) {
        if (config.scene.id)
            editor.call('scene:unload');

        editor.emit('scene:beforeload', id);

        editor.call('realtime:loadScene', id);

        if (isNew) {
            editor.once('entities:load', function () {
                editor.call('selector:set', 'designerSettings', [ editor.call('designerSettings') ]);
            });
        }
    });

    // When scene is loaded
    editor.on('scene:load', function (id) {
        // set config
        config.scene.id = id.toString();
        Ajax.param('scene.id', config.scene.id);

        // add history state
        if (pushState) {
            history.pushState(null, 'Editor', '/editor/scene/' + id);
        }

        pushState = true;

        // clear history in a timeout
        // otherwise some select events might remain
        setTimeout(function () {
            editor.call('history:clear');
        });
    });

    // Unload current scene
    editor.method('scene:unload', function () {
        var id = config.scene.id;
        config.scene.id = null;

        editor.emit('scene:unload', id);
    });

    // When history state changes make sure we load the
    // correct scene based on the new URL
    window.addEventListener('popstate', function (e) {
        var location = e.path[0].location.pathname;

        // close scene picker
        editor.call('picker:scene:close');

        // if this is a scene URL
        if (/scene/.test(location)) {
            var parts = location.split('/');
            var sceneId = parts[parts.length-1];
            // if this is not the current scene
            if (parseInt(sceneId, 10) !== parseInt(config.scene.id)) {
                // if the current scene has been deleted then don't load it
                // but rather make the current URL a project URL so that the scene picker opens
                if (deletedScenes[sceneId]) {
                    history.replaceState(null, 'Editor', '/editor/project/' + config.project.id);
                    // unload current scene
                    editor.call('scene:unload');
                    // open scene picker
                    editor.call('picker:scene');
                } else {
                    // load scene but don't add it to the history
                    pushState = false;
                    editor.call('scene:load', sceneId);
                }
            }
        } else {
            // if this is not a scene URL then
            // unload current scene and show scene picker
            editor.call('scene:unload');
            editor.call('picker:scene');
        }
    });

     // subscribe to messenger pack.delete
    editor.on('messenger:pack.delete', function (data) {
        // add scene to deleted so that we don't try to reopen it
        // on the 'popstate' event
        deletedScenes[data.pack.id] = true;

        // if the current scene has been deleted then change URL to project URL
        if (parseInt(config.scene.id, 10) === parseInt(data.pack.id, 10)) {
            history.replaceState(null, 'Editor', '/editor/project/' + config.project.id);
            editor.call('scene:unload');
            editor.call('picker:scene');
        }
    });
});

/* editor/whoisonline/whoisonline.js */
editor.once('load', function() {
    'use strict';

    var whoisonline = new ObserverList();

    // Set whoisonline
    editor.method('whoisonline:set', function (data) {
        whoisonline.clear();
        if (data) {
            data.forEach(function (id) {
                whoisonline.add(id);
            });
        }
    });

    // Get whoisonline
    editor.method('whoisonline:get', function () {
        return whoisonline;
    });

    // Add to whoiseonline
    editor.method('whoisonline:add', function (id) {
        whoisonline.add(id);
    });

    // Remove from whoisonline
    editor.method('whoisonline:remove', function (id) {
        whoisonline.remove(id);
    });

    // Returns true if specified user id is online
    editor.method('whoisonline:find', function (id) {
        return whoisonline.indexOf(id) >= 0;
    });

    // 'add' event
    whoisonline.on('add', function (id) {
        editor.emit('whoisonline:add', id);
    });

    // 'remove' event
    whoisonline.on('remove', function (id, index) {
        editor.emit('whoisonline:remove', id, index);
    });

    // remove all users when disconnected
    editor.on('realtime:disconnected', function () {
        whoisonline.clear();
    });

});


/* editor/attributes/attributes-panel.js */
editor.once('load', function() {
    'use strict';

    var title = 'INSPECTOR';
    var root = editor.call('layout.right');
    root.header = title;

    var clearPanel = function() {
        root.clear();
        editor.emit('attributes:clear');
    };

    // clearing
    editor.method('attributes:clear', clearPanel);

    // get current inspected items
    editor.method('attributes:items', function() {
        var type = editor.call('selector:type');
        var items = editor.call('selector:items');
        return {
            type: type,
            items: items
        };
    });

    // set header
    editor.method('attributes:header', function(text) {
        root.header = text;
    });

    // return root panel
    editor.method('attributes.rootPanel', function() {
        return root;
    });

    // add panel
    editor.method('attributes:addPanel', function(args) {
        args = args || { };

        // panel
        var panel = new ui.Panel(args.name || '');
        // parent
        (args.parent || root).append(panel);

        // folding
        panel.foldable = args.foldable || args.folded;
        panel.folded = args.folded;

        return panel;
    });

    var historyState = function(item, state) {
        if (item.history !== undefined) {
            if (typeof(item.history) === 'boolean') {
                item.history = state;
            } else {
                item.history.enabled = state;
            }
        } else {
            if (item._parent && item._parent.history !== undefined) {
                item._parent.history.enabled = state;
            }
        }
    };

    editor.method('attributes:linkField', function(args) {
        var update, changeField, changeFieldQueue;
        args.field._changing = false;
        var events = [ ];

        if (! (args.link instanceof Array))
            args.link = [ args.link ];

        update = function() {
            var different = false;
            var value = args.link[0].has(args.path) ? args.link[0].get(args.path) : undefined;
            if (args.type === 'rgb') {
                if (value) {
                    for(var i = 1; i < args.link.length; i++) {
                        if (! value.equals(args.link[i].get(args.path))) {
                            value = null;
                            different = true;
                            break;
                        }
                    }
                }
                if (value) {
                    value = value.map(function(v) {
                        return Math.floor(v * 255);
                    });
                }
            } else if (args.type === 'asset') {
                var countUndefined = value === undefined ? 1 : 0;
                for(var i = 1; i < args.link.length; i++) {
                    if (!args.link[i].has(args.path)) {
                        countUndefined++;
                        continue;
                    }

                    var val = args.link[i].get(args.path);

                    if ((value || 0) !== (args.link[i].get(args.path) || 0)) {
                        if (value !== undefined) {
                            value = args.enum ? '' : null;
                            different = true;
                            break;
                        }
                    }

                    value = val;
                }

                if (countUndefined && countUndefined != args.link.length) {
                    args.field.class.add('star');
                    if (! /^\* /.test(args.field._title.text))
                        args.field._title.text = '* ' + args.field._title.text;
                } else {
                    args.field.class.remove('star');
                    if (/^\* /.test(args.field._title.text))
                        args.field._title.text = args.field._title.text.substring(2);

                }

                if (different) {
                    args.field.class.add('null');
                    args.field._title.text = 'various';
                } else {
                    args.field.class.remove('null');
                }
            } else if (args.type === 'entity' || ! args.type) {
                for(var i = 1; i < args.link.length; i++) {
                    if (value !== args.link[i].get(args.path)) {
                        value = 'various';
                        different = true;
                        break;
                    }
                }
                if (different) {
                    args.field.class.add('null');
                    args.field.text = 'various';
                } else {
                    args.field.class.remove('null');
                }
            } else {
                for(var i = 1; i < args.link.length; i++) {
                    var v = args.link[i].get(args.path);
                    if ((value || 0) !== (v || 0)) {
                        value = args.enum ? '' : null;
                        different = true;
                        break;
                    }
                }
            }

            args.field._changing = true;
            args.field.value = (value === undefined ? null : value);
            args.field._changing = false;

            if (args.enum) {
                var opt = args.field.optionElements[''];
                if (opt) opt.style.display = value !== '' ? 'none' : '';
            } else {
                args.field.proxy = value == null ? '...' : null;
            }
        };

        changeField = function(value) {
            if (args.field._changing)
                return;

            if (args.enum) {
                var opt = this.optionElements[''];
                if (opt) opt.style.display = value !== '' ? 'none' : '';
            } else {
                this.proxy = value === null ? '...' : null;
            }

            if (args.type === 'rgb') {
                value = value.map(function(v) {
                    return v / 255;
                });
            } else if (args.type === 'asset') {
                args.field.class.remove('null');
            }

            var items = [ ];

            // set link value
            args.field._changing = true;
            for(var i = 0; i < args.link.length; i++) {
                if (args.type === 'asset' && !args.link[i].has(args.path)) continue;

                items.push({
                    get: args.link[i].history !== undefined ? args.link[i].history._getItemFn : null,
                    item: args.link[i],
                    value: args.link[i].has(args.path) ? args.link[i].get(args.path) : undefined
                });

                historyState(args.link[i], false);
                args.link[i].set(args.path, value);
                historyState(args.link[i], true);
            }
            args.field._changing = false;

            // history
            if (args.type !== 'rgb' && ! args.slider && ! args.field._stopHistory) {
                editor.call('history:add', {
                    name: args.path,
                    undo: function() {
                        var different = false;
                        for(var i = 0; i < items.length; i++) {
                            var item;
                            if (items[i].get) {
                                item = items[i].get();
                                if (! item)
                                    continue;
                            } else {
                                item = items[i].item;
                            }

                            if (! different && items[0].value !== items[i].value)
                                different = true;

                            historyState(item, false);
                            if (items[i].value === undefined)
                                item.unset(args.path);
                            else
                                item.set(args.path, items[i].value);
                            historyState(item, true);
                        }

                        if (different) {
                            args.field.class.add('null');
                        } else {
                            args.field.class.remove('null');
                        }
                    },
                    redo: function() {
                        for(var i = 0; i < items.length; i++) {
                            var item;
                            if (items[i].get) {
                                item = items[i].get();
                                if (! item)
                                    continue;
                            } else {
                                item = items[i].item;
                            }

                            historyState(item, false);
                            if (value === undefined)
                                item.unset(args.path);
                            else
                                item.set(args.path, value);
                            item.set(args.path, value);
                            historyState(item, true);
                        }

                        args.field.class.remove('null');
                    }
                });
            }
        };

        changeFieldQueue = function() {
            if (args.field._changing)
                return;

            args.field._changing = true;
            setTimeout(function() {
                args.field._changing = false;
                update();
            }, 0);
        };

        var historyStart, historyEnd;

        if (args.type === 'rgb' || args.slider) {
            historyStart = function() {
                var items = [ ];

                for(var i = 0; i < args.link.length; i++) {
                    var v = args.link[i].get(args.path);
                    if (v instanceof Array)
                        v = v.slice(0);

                    items.push({
                        get: args.link[i].history !== undefined ? args.link[i].history._getItemFn : null,
                        item: args.link[i],
                        value: v
                    });
                }

                return items;
            };

            historyEnd = function(items, value) {
                // history
                editor.call('history:add', {
                    name: args.path,
                    undo: function() {
                        for(var i = 0; i < items.length; i++) {
                            var item;
                            if (items[i].get) {
                                item = items[i].get();
                                if (! item)
                                    continue;
                            } else {
                                item = items[i].item;
                            }

                            historyState(item, false);
                            item.set(args.path, items[i].value);
                            historyState(item, true);
                        }
                    },
                    redo: function() {
                        for(var i = 0; i < items.length; i++) {
                            var item;
                            if (items[i].get) {
                                item = items[i].get();
                                if (! item)
                                    continue;
                            } else {
                                item = items[i].item;
                            }

                            historyState(item, false);
                            item.set(args.path, value);
                            historyState(item, true);
                        }
                    }
                });
            };
        }

        if (args.type === 'rgb') {
            var colorPickerOn = false;
            args.field.on('click', function() {
                colorPickerOn = true;

                // set picker color
                editor.call('picker:color', args.field.value);

                var items = [ ];

                // picking starts
                var evtColorPickStart = editor.on('picker:color:start', function() {
                    items = historyStart();
                });

                // picked color
                var evtColorPick = editor.on('picker:color', function(color) {
                    args.field.value = color;
                });

                var evtColorPickEnd = editor.on('picker:color:end', function() {
                    historyEnd(items.slice(0), args.field.value.map(function(v) {
                        return v / 255;
                    }));
                });

                // position picker
                var rectPicker = editor.call('picker:color:rect');
                var rectField = args.field.element.getBoundingClientRect();
                editor.call('picker:color:position', rectField.left - rectPicker.width, rectField.top);

                // color changed, update picker
                var evtColorToPicker = args.field.on('change', function() {
                    editor.call('picker:color:set', this.value);
                });

                // picker closed
                editor.once('picker:color:close', function() {
                    evtColorPick.unbind();
                    evtColorPickStart.unbind();
                    evtColorPickEnd.unbind();
                    evtColorToPicker.unbind();
                    colorPickerOn = false;
                    args.field.element.focus();
                });
            });

            // close picker if field destroyed
            args.field.once('destroy', function() {
                if (colorPickerOn)
                    editor.call('picker:color:close');
            });
        } else if (args.slider) {
            var sliderRecords;

            events.push(args.field.on('start', function() {
                sliderRecords = historyStart();
            }));

            events.push(args.field.on('end', function() {
                historyEnd(sliderRecords.slice(0), args.field.value);
            }));
        }

        update();
        args.field.on('change', changeField);

        for(var i = 0; i < args.link.length; i++) {
            events.push(args.link[i].on(args.path + ':set', changeFieldQueue));
            events.push(args.link[i].on(args.path + ':unset', changeFieldQueue));
        }

        args.field.once('destroy', function() {
            for(var i = 0; i < events.length; i++)
                events[i].unbind();
        });
    });

    // add field
    editor.method('attributes:addField', function(args) {
        var panel = args.panel;

        if (! panel) {
            panel = new ui.Panel();
            panel.flexWrap = 'nowrap';
            panel.WebkitFlexWrap = 'nowrap';
            panel.style.display = '';

            if (args.type) {
                panel.class.add('field-' + args.type);
            } else {
                panel.class.add('field');
            }

            (args.parent || root).append(panel);
        }

        if (args.name) {
            var label = new ui.Label({
                text: args.name
            });
            label.class.add('label-field');
            panel._label = label;
            panel.append(label);

            if (args.reference) {
                var tooltip = editor.call('attributes:reference', {
                    element: label.element,
                    title: args.reference.title,
                    subTitle: args.reference.subTitle,
                    description: args.reference.description
                });

                tooltip.attach({
                    target: label,
                    element: label.element
                });
            }
        }

        var field;

        var linkField = function() {
            if (args.link) {
                var link = function(field, path) {
                    editor.call('attributes:linkField', {
                        field: field,
                        path: path || args.path,
                        type: args.type,
                        slider: args.slider,
                        enum: args.enum,
                        link: args.link
                    });
                };
                if (field instanceof Array) {
                    for(var i = 0; i < field.length; i++) {
                        link(field[i], args.path + '.' + i);
                    }
                } else {
                    link(field);
                }
            }
        };

        switch(args.type) {
            case 'string':
                if (args.enum) {
                    field = new ui.SelectField({
                        options: args.enum
                    });
                } else {
                    field = new ui.TextField();
                }

                field.value = args.value || '';
                field.flexGrow = 1;

                if (args.placeholder)
                    field.placeholder = args.placeholder;

                linkField();

                panel.append(field);
                break;

            case 'strings':
                var innerPanel = new ui.Panel();
                innerPanel.flex = true;
                innerPanel.flexGrow = 1;

                var events = [ ];

                field = new ui.TextField();
                field.renderChanges = false;
                innerPanel.append(field);

                field.element.addEventListener('keydown', function(evt) {
                    if (evt.keyCode !== 13 || ! field.value)
                        return;

                    addTag(field.value.trim());
                    field.value = '';
                });

                var btnAdd = new ui.Button({
                    text: '&#57632'
                });
                btnAdd.flexGrow = 0;
                btnAdd.on('click', function() {
                    if (! field.value)
                        return;

                    addTag(field.value.trim());
                    field.value = '';
                });
                innerPanel.append(btnAdd);

                var tagItems = { };
                var tagIndex = { };
                var tagList = [ ];

                var onRemoveClick = function() {
                    if (innerPanel.disabled)
                        return;

                    removeTag(this.tag);
                };

                var removeTag = function(tag) {
                    if (! tag || ! tagIndex.hasOwnProperty(tag))
                        return;

                    var records = [ ];

                    for(var i = 0; i < link.length; i++) {
                        if (link[i].get(args.path).indexOf(tag) === -1)
                            continue;

                        records.push({
                            get: link[i].history !== undefined ? link[i].history._getItemFn : null,
                            item: link[i],
                            path: args.path,
                            value: tag
                        });

                        historyState(link[i], false);
                        link[i].removeValue(args.path, tag);
                        historyState(link[i], true);
                    }

                    editor.call('history:add', {
                        name: args.path,
                        undo: function() {
                            for(var i = 0; i < records.length; i++) {
                                var item;
                                if (records[i].get) {
                                    item = records[i].get();
                                    if (! item)
                                        continue;
                                } else {
                                    item = records[i].item;
                                }

                                historyState(item, false);
                                item.insert(records[i].path, records[i].value);
                                historyState(item, true);
                            }
                        },
                        redo: function() {
                            for(var i = 0; i < records.length; i++) {
                                var item;
                                if (records[i].get) {
                                    item = records[i].get();
                                    if (! item)
                                        continue;
                                } else {
                                    item = records[i].item;
                                }

                                historyState(item, false);
                                item.removeValue(records[i].path, records[i].value);
                                historyState(item, true);
                            }
                        }
                    });
                };

                var addTag = function(tag) {
                    var records = [ ];

                    for(var i = 0; i < link.length; i++) {
                        if (link[i].get(args.path).indexOf(tag) !== -1)
                            continue;

                        records.push({
                            get: link[i].history !== undefined ? link[i].history._getItemFn : null,
                            item: link[i],
                            path: args.path,
                            value: tag
                        });

                        historyState(link[i], false);
                        link[i].insert(args.path, tag);
                        historyState(link[i], true);
                    }

                    editor.call('history:add', {
                        name: args.path,
                        undo: function() {
                            for(var i = 0; i < records.length; i++) {
                                var item;
                                if (records[i].get) {
                                    item = records[i].get();
                                    if (! item)
                                        continue;
                                } else {
                                    item = records[i].item;
                                }

                                historyState(item, false);
                                item.removeValue(records[i].path, records[i].value);
                                historyState(item, true);
                            }
                        },
                        redo: function() {
                            for(var i = 0; i < records.length; i++) {
                                var item;
                                if (records[i].get) {
                                    item = records[i].get();
                                    if (! item)
                                        continue;
                                } else {
                                    item = records[i].item;
                                }

                                historyState(item, false);
                                item.insert(records[i].path, records[i].value);
                                historyState(item, true);
                            }
                        }
                    });
                };

                var onInsert = function(tag) {
                    if (! tagIndex.hasOwnProperty(tag)) {
                        tagIndex[tag] = 0;
                        tagList.push(tag);
                    }

                    tagIndex[tag]++;
                    insertElement(tag);
                };

                var onRemove = function(tag) {
                    if (! tagIndex[tag])
                        return;

                    tagIndex[tag]--;

                    if (! tagIndex[tag]) {
                        innerPanel.innerElement.removeChild(tagItems[tag]);
                        var ind = tagList.indexOf(tag);
                        if (ind !== -1)
                            tagList.splice(ind, 1);

                        delete tagItems[tag];
                        delete tagIndex[tag];
                    } else {
                        if (tagIndex[tag] === link.length) {
                            tagItems[tag].classList.remove('partial');
                        } else {
                            tagItems[tag].classList.add('partial');
                        }
                    }
                };

                var insertElement = function(tag) {
                    if (! tagItems[tag]) {
                        sortTags();

                        var item = document.createElement('div');
                        tagItems[tag] = item;
                        item.classList.add('tag');
                        item.textContent = tag;

                        var icon = document.createElement('span');
                        icon.innerHTML = '&#57650;';
                        icon.classList.add('icon');
                        icon.tag = tag;
                        icon.addEventListener('click', onRemoveClick, false);
                        item.appendChild(icon);

                        var ind = tagList.indexOf(tag);
                        if (tagItems[tagList[ind + 1]]) {
                            innerPanel.appendBefore(item, tagItems[tagList[ind + 1]]);
                        } else {
                            innerPanel.appendBefore(item, field);
                        }
                    }

                    if (tagIndex[tag] === link.length) {
                        tagItems[tag].classList.remove('partial');
                    } else {
                        tagItems[tag].classList.add('partial');
                    }
                };

                var sortTags = function() {
                    tagList.sort(function(a, b) {
                        if (a > b) {
                            return 1;
                        } else if (a < b) {
                            return -1;
                        } else {
                            return 0;
                        }
                    });
                };

                if (args.placeholder)
                    field.placeholder = args.placeholder;

                // list
                var link = args.link;
                if (! (args.link instanceof Array))
                    link = [ link ];

                for(var i = 0; i < link.length; i++) {
                    var tags = link[i].get(args.path);

                    events.push(link[i].on('tags:insert', onInsert));
                    events.push(link[i].on('tags:remove', onRemove));

                    if (! tags)
                        continue;

                    for(var t = 0; t < tags.length; t++) {
                        if (! tags[t])
                            continue;

                        if (! tagIndex.hasOwnProperty(tags[t])) {
                            tagIndex[tags[t]] = 0;
                            tagList.push(tags[t]);
                        }

                        tagIndex[tags[t]]++;
                    }
                }

                sortTags();

                for(var i = 0; i < tagList.length; i++)
                    insertElement(tagList[i]);

                panel.once('destroy', function() {
                    for(var i = 0; i < events.length; i++)
                        events[i].unbind();
                });

                panel.append(innerPanel);
                break;

            case 'number':
                if (args.enum) {
                    field = new ui.SelectField({
                        options: args.enum,
                        number: true
                    });
                } else if (args.slider) {
                    field = new ui.Slider();
                } else {
                    field = new ui.NumberField();
                }

                field.value = args.value || 0;
                field.flexGrow = 1;
                if (args.placeholder)
                    field.placeholder = args.placeholder;

                if (args.precision != null)
                    field.precision = args.precision;

                if (args.step != null)
                    field.step = args.step;

                if (args.min != null)
                    field.min = args.min;

                if (args.max != null)
                    field.max = args.max;

                linkField();

                panel.append(field);
                break;

            case 'checkbox':
                field = new ui.Checkbox();
                field.value = args.value || 0;
                field.class.add('tick');

                linkField();

                panel.append(field);
                break;

            case 'vec2':
            case 'vec3':
            case 'vec4':
                var channels = parseInt(args.type[3], 10);
                field = [ ];

                for(var i = 0; i < channels; i++) {
                    field[i] = new ui.NumberField();
                    field[i].flexGrow = 1;
                    field[i].style.width = '24px';
                    field[i].value = (args.value && args.value[i]) || 0;
                    panel.append(field[i]);

                    if (args.placeholder)
                        field[i].placeholder = args.placeholder[i];

                    if (args.precision != null)
                        field[i].precision = args.precision;

                    if (args.step != null)
                        field[i].step = args.step;

                    if (args.min != null)
                        field[i].min = args.min;

                    if (args.max != null)
                        field[i].max = args.max;

                    // if (args.link)
                    //     field[i].link(args.link, args.path + '.' + i);
                }

                linkField();
                break;

            case 'rgb':
                field = new ui.ColorField();

                linkField();

                var colorPickerOn = false;
                field.on('click', function() {
                    colorPickerOn = true;
                    var first = true;

                    // set picker color
                    editor.call('picker:color', field.value);

                    // picking starts
                    var evtColorPickStart = editor.on('picker:color:start', function() {
                        first = true;
                    });

                    // picked color
                    var evtColorPick = editor.on('picker:color', function(color) {
                        first = false;
                        field.value = color;
                    });

                    // position picker
                    var rectPicker = editor.call('picker:color:rect');
                    var rectField = field.element.getBoundingClientRect();
                    editor.call('picker:color:position', rectField.left - rectPicker.width, rectField.top);

                    // color changed, update picker
                    var evtColorToPicker = field.on('change', function() {
                        editor.call('picker:color:set', this.value);
                    });

                    // picker closed
                    editor.once('picker:color:close', function() {
                        evtColorPick.unbind();
                        evtColorPickStart.unbind();
                        evtColorToPicker.unbind();
                        colorPickerOn = false;
                        field.element.focus();
                    });
                });

                // close picker if field destroyed
                field.on('destroy', function() {
                    if (colorPickerOn)
                        editor.call('picker:color:close');
                });

                panel.append(field);
                break;

            case 'asset':
                field = new ui.ImageField();
                var evtPick;

                label.renderChanges = false;
                field._label = label;

                label.style.width = '32px';
                label.flexGrow = 1;

                var panelFields = document.createElement('div');
                panelFields.classList.add('top');

                var panelControls = document.createElement('div');
                panelControls.classList.add('controls');

                var fieldTitle = field._title = new ui.Label();
                fieldTitle.text = 'Empty';
                fieldTitle.parent = panel;
                fieldTitle.flexGrow = 1;
                fieldTitle.placeholder = '...';

                var btnEdit = new ui.Button({
                    text: '&#57648;'
                });
                btnEdit.disabled = true;
                btnEdit.parent = panel;
                btnEdit.flexGrow = 0;

                var btnRemove = new ui.Button({
                    text: '&#57650;'
                });
                btnRemove.disabled = true;
                btnRemove.parent = panel;
                btnRemove.flexGrow = 0;

                fieldTitle.on('click', function() {
                    var asset = editor.call('assets:get', field.value);
                    editor.call('picker:asset', args.kind, asset);

                    evtPick = editor.once('picker:asset', function(asset) {
                        field.value = asset.get('id');
                        evtPick = null;
                    });

                    editor.once('picker:asset:close', function() {
                        if (evtPick) {
                            evtPick.unbind();
                            evtPick = null;
                        }
                        field.element.focus();
                    });
                });

                field.on('click', function() {
                    if (! this.value)
                        return;

                    var asset = editor.call('assets:get', this.value);
                    if (! asset) return;
                    editor.call('selector:set', 'asset', [ asset ]);

                    if (asset.get('type') === 'script') {
                        editor.call('assets:panel:currentFolder', 'scripts');
                    } else {
                        var path = asset.get('path');
                        if (path.length) {
                            editor.call('assets:panel:currentFolder', editor.call('assets:get', path[path.length - 1]));
                        } else {
                            editor.call('assets:panel:currentFolder', null);
                        }
                    }

                });
                btnEdit.on('click', function() {
                    field.emit('click');
                });

                btnRemove.on('click', function() {
                    field.value = null;
                });

                var evtThumbnailChange;
                var updateThumbnail = function() {
                    var asset = editor.call('assets:get', field.value);

                    if (! asset) {
                        return field.image = config.url.home + '/editor/scene/img/asset-placeholder-texture.png';
                    } else {
                        if (asset.has('thumbnails.m')) {
                            var src = asset.get('thumbnails.m');
                            if (src.startsWith('data:image/png;base64')) {
                                field.image = asset.get('thumbnails.m');
                            } else {
                                field.image = config.url.home + asset.get('thumbnails.m') + '?t=' + asset.get('file.hash');
                            }
                        } else {
                            field.image = '/editor/scene/img/asset-placeholder-' + asset.get('type') + '.png';
                        }
                    }
                };

                linkField();

                var updateField = function() {
                    var value = field.value;

                    fieldTitle.text = field.class.contains('null') ? 'various' : 'Empty';

                    btnEdit.disabled = ! value;
                    btnRemove.disabled = ! value && ! field.class.contains('null');

                    if (evtThumbnailChange) {
                        evtThumbnailChange.unbind();
                        evtThumbnailChange = null;
                    }

                    if (! value) {
                        if (field.class.contains('star'))
                            fieldTitle.text = '* ' + fieldTitle.text;

                        return field.empty = true;
                    }

                    field.empty = false;

                    var asset = editor.call('assets:get', value);

                    if (! asset)
                        return field.image = config.url.home + '/editor/scene/img/asset-placeholder-texture.png';

                    evtThumbnailChange = asset.on('file.hash.m:set', updateThumbnail);
                    updateThumbnail();

                    fieldTitle.text = asset.get('name');

                    if (field.class.contains('star'))
                        fieldTitle.text = '* ' + fieldTitle.text;
                };
                field.on('change', updateField);

                if (args.value)
                    field.value = args.value;

                updateField();

                var dropRef = editor.call('drop:target', {
                    ref: panel.element,
                    filter: function(type, data) {
                        var rectA = root.innerElement.getBoundingClientRect();
                        var rectB = panel.element.getBoundingClientRect();
                        return (args.kind === '*' || type === 'asset.' + args.kind) && parseInt(data.id, 10) !== field.value && ! editor.call('assets:get', parseInt(data.id, 10)).get('source') && rectB.top > rectA.top && rectB.bottom < rectA.bottom;
                    },
                    drop: function(type, data) {
                        if ((args.kind !== '*' && type !== 'asset.' + args.kind) || editor.call('assets:get', parseInt(data.id, 10)).get('source'))
                            return;

                        field.value = parseInt(data.id, 10);
                    },
                    over: function(type, data) {
                        if (args.over)
                            args.over(type, data);
                    },
                    leave: function() {
                        if (args.leave)
                            args.leave();
                    }
                });
                field.on('destroy', function() {
                    dropRef.unregister();
                    if (evtThumbnailChange) {
                        evtThumbnailChange.unbind();
                        evtThumbnailChange = null;
                    }
                });

                // thumbnail
                panel.append(field);
                // right side
                panel.append(panelFields);
                // controls
                panelFields.appendChild(panelControls);
                // label
                panel.innerElement.removeChild(label.element);
                panelControls.appendChild(label.element);
                panelControls.classList.remove('label-field');
                // edit
                panelControls.appendChild(btnEdit.element);
                // remove
                panelControls.appendChild(btnRemove.element);

                // title
                panelFields.appendChild(fieldTitle.element);
                break;

            // entity picker
            case 'entity':
                field = new ui.Label();
                field.class.add('add-entity');
                field.flexGrow = 1;
                field.class.add('null');

                field.text = 'Select Entity';
                field.placeholder = '...';

                panel.append(field);

                var icon = document.createElement('span');
                icon.classList.add('icon');

                icon.addEventListener('click', function (e) {
                    e.stopPropagation();

                    if (editor.call('permissions:write'))
                        field.text = '';
                });

                field.on('change', function (value) {
                    if (value) {
                        var entity = editor.call('entities:get', value);
                        if (!entity) {
                            field.text = null;
                            return;
                        }

                        field.element.innerHTML = entity.get('name');
                        field.element.appendChild(icon);
                        field.placeholder = '';

                        if (value !== 'various')
                            field.class.remove('null');
                    } else {
                        field.element.innerHTML = 'Select Entity';
                        field.placeholder = '...';
                        field.class.add('null');
                    }
                });

                linkField();

                var getCurrentEntity = function () {
                    var entity = null;
                    if (args.link) {
                        if (! (args.link instanceof Array)) {
                            args.link = [args.link];
                        }

                        // get initial value only if it's the same for all
                        // links otherwise set it to null
                        for (var i = 0, len = args.link.length; i < len; i++) {
                            var val = args.link[i].get(args.path);
                            if (entity !== val) {
                                if (entity) {
                                    entity = null;
                                    break;
                                } else {
                                    entity = val;
                                }
                            }
                        }
                    }

                    return entity;
                };

                field.on('click', function () {
                    var evtEntityPick = editor.once('picker:entity', function (entity) {
                        field.text = entity ? entity.get('resource_id') : null;
                        evtEntityPick = null;
                    });

                    var initialValue = getCurrentEntity();

                    editor.call('picker:entity', initialValue);

                    editor.once('picker:entity:close', function () {
                        if (evtEntityPick) {
                            evtEntityPick.unbind();
                            evtEntityPick = null;
                        }
                    });
                });

                // highlight on hover
                field.on('hover', function () {
                    var entity = getCurrentEntity();
                    if (! entity) return;

                    editor.call('entities:panel:highlight', entity, true);

                    field.once('blur', function () {
                        editor.call('entities:panel:highlight', entity, false);
                    });

                    field.once('click', function () {
                        editor.call('entities:panel:highlight', entity, false);
                    });
                });

                var dropRef = editor.call('drop:target', {
                    ref: field.element,
                    filter: function(type, data) {
                        var rectA = root.innerElement.getBoundingClientRect();
                        var rectB = field.element.getBoundingClientRect();
                        return type === 'entity' && data.resource_id !== field.value && rectB.top > rectA.top && rectB.bottom < rectA.bottom;
                    },
                    drop: function(type, data) {
                        if (type !== 'entity')
                            return;

                        field.value = data.resource_id;
                    },
                    over: function(type, data) {
                        if (args.over)
                            args.over(type, data);
                    },
                    leave: function() {
                        if (args.leave)
                            args.leave();
                    }
                });
                field.on('destroy', function() {
                    dropRef.unregister();
                });

                break;
            case 'image':
                panel.flex = false;

                field = new Image();
                field.style.maxWidth = '100%';
                field.style.display = 'block';
                field.src = args.src;

                panel.append(field);
                break;

            case 'progress':
                field = new ui.Progress();
                field.flexGrow = 1;

                panel.append(field);
                break;

            case 'code':
                field = new ui.Code();
                field.flexGrow = 1;

                if (args.value)
                    field.text = args.value;

                panel.append(field);
                break;

            case 'button':
                field = new ui.Button();
                field.flexGrow = 1;
                field.text = args.text || 'Button';
                panel.append(field);
                break;

            case 'element':
                field = args.element;
                panel.append(field);
                break;

            case 'curveset':
                field = new ui.CurveField(args);
                field.flexGrow = 1;
                field.text = args.text || '';

                if (args.link) {
                    var link = args.link;
                    if (args.link instanceof Array)
                        link = args.link[0];

                    field.link(link, args.paths || [args.path]);
                }

                var curvePickerOn = false;

                var toggleCurvePicker = function () {
                    if (!field.class.contains('disabled') && !curvePickerOn) {
                        editor.call('picker:curve', field.value, args);

                        curvePickerOn = true;

                        var first = true;

                        // position picker
                        var rectPicker = editor.call('picker:curve:rect');
                        var rectField = field.element.getBoundingClientRect();
                        editor.call('picker:curve:position', rectField.right - rectPicker.width, rectField.bottom);

                        var evtPickerStartChange = editor.on('picker:curve:change:start', function () {
                            first = true;
                        });

                        var evtPickerChanged = editor.on('picker:curve:change', function (path, value) {
                            var combine;
                            if (field._link) {
                                if (field._link.history) {
                                    combine = field._link.history.combine;
                                    field._link.history.combine = ! first;
                                }

                                if (args.paths) {
                                    path = args.paths[parseInt(path[0])] + path.substring(1);
                                } else {
                                    path = args.path + path.substring(1);
                                }

                                field._link.set(path, value);

                                if (field._link.history)
                                    field._link.history.combine = combine;

                                // set second graph keys to be the same as the first
                                // if betweenCurves if false
                                if (args.paths && path.indexOf(args.paths[0]) === 0 && (path.indexOf('.keys') !== -1 || path.indexOf('betweenCurves') !== -1) && ! field._link.get(args.paths[0] + '.betweenCurves')) {
                                    var history;
                                    if (field._link.history) {
                                        history = field._link.history.enabled;
                                        field._link.history.enabled = false;
                                    }

                                    field._link.set(args.paths[1] + '.keys', field._link.get(args.paths[0] + '.keys'));

                                    if (field._link.history)
                                        field._link.history.enabled = history;
                                }
                            }

                            first = false;
                        });

                        var evtRefreshPicker = field.on('change', function (value) {
                            editor.call('picker:curve:set', value, args);
                        });

                        editor.once('picker:curve:close', function () {
                            evtRefreshPicker.unbind();
                            evtPickerStartChange.unbind();
                            evtPickerChanged.unbind();
                            curvePickerOn = false;
                        });
                    }
                };

                // open curve editor on click
                field.on('click', toggleCurvePicker);

                // close picker if field destroyed
                field.on('destroy', function() {
                    if (curvePickerOn) {
                        editor.call('picker:curve:close');
                    }
                });

                panel.append(field);
                break;

            default:
                field = new ui.Label();
                field.flexGrow = 1;
                field.text = args.value || '';

                if (args.placeholder)
                    field.placeholder = args.placeholder;

                linkField();

                panel.append(field);
                break;
        }

        return field;
    });

    editor.method('attributes:addAssetsList', function(args) {
        var link = args.link;
        var title = args.title;
        var assetType = args.type;
        var path = args.path;
        var panel = args.panel;
        var events = [ ];

        // assets
        var fieldAssetsList = new ui.List();
        fieldAssetsList.flexGrow = 1;

        // drop
        var dropRef = editor.call('drop:target', {
            ref: fieldAssetsList.element,
            type: 'asset.' + type,
            filter: function(type, data) {
                // type
                if ((assetType && assetType !== '*' && type !== 'asset.' + assetType) || ! type.startsWith('asset') || editor.call('assets:get', parseInt(data.id, 10)).get('source'))
                    return false;

                // overflowed
                var rectA = root.innerElement.getBoundingClientRect();
                var rectB = fieldAssetsList.element.getBoundingClientRect();
                if (rectB.top <= rectA.top || rectB.bottom >= rectA.bottom)
                    return false;

                // already added
                var id = parseInt(data.id, 10);
                for(var i = 0; i < link.length; i++) {
                    if (link[i].get(path).indexOf(id) === -1)
                        return true;
                }

                return false;
            },
            drop: function(type, data) {
                if ((assetType && assetType !== '*' && type !== 'asset.' + assetType) || ! type.startsWith('asset') || editor.call('assets:get', parseInt(data.id, 10)).get('source'))
                    return;

                var records = [ ];

                var id = parseInt(data.id, 10);

                for(var i = 0; i < link.length; i++) {
                    if (link[i].get(path).indexOf(id) !== -1)
                        continue;

                    records.push({
                        get: link[i].history !== undefined ? link[i].history._getItemFn : null,
                        item: link[i],
                        path: path,
                        value: id
                    });

                    historyState(link[i], false);
                    link[i].insert(path, id);
                    historyState(link[i], true);
                }

                editor.call('history:add', {
                    name: path,
                    undo: function() {
                        for(var i = 0; i < records.length; i++) {
                            var item;
                            if (records[i].get) {
                                item = records[i].get();
                                if (! item)
                                    continue;
                            } else {
                                item = records[i].item;
                            }

                            historyState(item, false);
                            item.removeValue(records[i].path, records[i].value);
                            historyState(item, true);
                        }
                    },
                    redo: function() {
                        for(var i = 0; i < records.length; i++) {
                            var item;
                            if (records[i].get) {
                                item = records[i].get();
                                if (! item)
                                    continue;
                            } else {
                                item = records[i].item;
                            }

                            historyState(item, false);
                            item.insert(records[i].path, records[i].value);
                            historyState(item, true);
                        }
                    }
                });
            }
        });
        dropRef.disabled = panel.disabled;
        panel.on('enable', function() {
            dropRef.disabled = false;
        });
        panel.on('disable', function() {
            dropRef.disabled = true;

            // clear list item
            var items = fieldAssetsList.element.children;
            var i = items.length;
            while(i-- > 1) {
                if (! items[i].ui || ! (items[i].ui instanceof ui.ListItem))
                    continue;

                items[i].ui.destroy();
            }

            assetIndex = { };
        });
        fieldAssetsList.on('destroy', function() {
            dropRef.unregister();
        });

        var fieldAssets = editor.call('attributes:addField', {
            parent: panel,
            name: 'Assets',
            type: 'element',
            element: fieldAssetsList,
            reference: args.reference
        });
        fieldAssets.class.add('assets');

        // reference assets
        editor.call('attributes:reference:' + assetType + ':assets:attach', fieldAssets.parent.innerElement.firstChild.ui);

        // assets list
        var itemAdd = new ui.ListItem({
            text: 'Add ' + title
        });
        itemAdd.class.add('add-asset');
        fieldAssetsList.append(itemAdd);

        // add asset icon
        var iconAdd = document.createElement('span');
        iconAdd.classList.add('icon');
        itemAdd.element.appendChild(iconAdd);

        // index list items by asset id
        var assetIndex = { };

        // add asset
        var addAsset = function(assetId, after) {
            assetId = parseInt(assetId, 10);

            var item = assetIndex[assetId];
            if (item) {
                item.count++;
                item.text = (item.count === link.length ? '' : '* ') + item._assetText;
                return;
            }

            var asset = editor.call('assets:get', assetId);
            var text = assetId;
            if (asset && asset.get('name'))
                text = asset.get('name');

            item = new ui.ListItem({
                text: (link.length === 1) ? text : '* ' + text
            });
            item.count = 1;
            item._assetText = text;

            if (after) {
                fieldAssetsList.appendAfter(item, after);
            } else {
                fieldAssetsList.append(item);
            }

            assetIndex[assetId] = item;

            // remove button
            var btnRemove = new ui.Button();
            btnRemove.class.add('remove');
            btnRemove.on('click', function() {
                var records = [ ];

                for(var i = 0; i < link.length; i++) {
                    var ind = link[i].get(path).indexOf(assetId);
                    if (ind === -1)
                        continue;

                    records.push({
                        get: link[i].history !== undefined ? link[i].history._getItemFn : null,
                        item: link[i],
                        path: path,
                        value: assetId,
                        ind: ind
                    });

                    historyState(link[i], false);
                    link[i].removeValue(path, assetId);
                    historyState(link[i], true);
                }

                editor.call('history:add', {
                    name: path,
                    undo: function() {
                        for(var i = 0; i < records.length; i++) {
                            var item;
                            if (records[i].get) {
                                item = records[i].get();
                                if (! item)
                                    continue;
                            } else {
                                item = records[i].item;
                            }

                            historyState(item, false);
                            item.insert(records[i].path, records[i].value, records[i].ind);
                            historyState(item, true);
                        }
                    },
                    redo: function() {
                        for(var i = 0; i < records.length; i++) {
                            var item;
                            if (records[i].get) {
                                item = records[i].get();
                                if (! item)
                                    continue;
                            } else {
                                item = records[i].item;
                            }

                            historyState(item, false);
                            item.removeValue(records[i].path, records[i].value);
                            historyState(item, true);
                        }
                    }
                });
            });
            btnRemove.parent = item;
            item.element.appendChild(btnRemove.element);

            item.once('destroy', function() {
                delete assetIndex[assetId];
            });
        };

        var removeAsset = function(assetId) {
            var item = assetIndex[assetId];

            if (! item)
                return;

            item.count--;

            if (item.count === 0) {
                item.destroy();
            } else {
                item.text = (item.count === link.length ? '' : '* ') + item._assetText;
            }
        };

        // on adding new asset
        itemAdd.on('click', function() {
            // call picker
            editor.call('picker:asset', assetType, null);

            // on pick
            var evtPick = editor.once('picker:asset', function(asset) {
                if (asset.get('type') === 'script')
                    return;

                var records = [ ];
                var assetId = parseInt(asset.get('id'), 10);

                for(var i = 0; i < link.length; i++) {
                    // already in list
                    if (link[i].get(path).indexOf(assetId) !== -1)
                        continue;

                    records.push({
                        get: link[i].history !== undefined ? link[i].history._getItemFn : null,
                        item: link[i],
                        path: path,
                        value: assetId
                    });

                    historyState(link[i], false);
                    link[i].insert(path, assetId);
                    historyState(link[i], true);
                    evtPick = null;
                }

                editor.call('history:add', {
                    name: path,
                    undo: function() {
                        for(var i = 0; i < records.length; i++) {
                            var item;
                            if (records[i].get) {
                                item = records[i].get();
                                if (! item)
                                    continue;
                            } else {
                                item = records[i].item;
                            }

                            historyState(item, false);
                            item.removeValue(records[i].path, records[i].value);
                            historyState(item, true);
                        }
                    },
                    redo: function() {
                        for(var i = 0; i < records.length; i++) {
                            var item;
                            if (records[i].get) {
                                item = records[i].get();
                                if (! item)
                                    continue;
                            } else {
                                item = records[i].item;
                            }

                            historyState(item, false);
                            item.insert(records[i].path, records[i].value);
                            historyState(item, true);
                        }
                    }
                });
            });

            editor.once('picker:asset:close', function() {
                if (evtPick) {
                    evtPick.unbind();
                    evtPick = null;
                }
            });
        });

        // list
        for(var i = 0; i < link.length; i++) {
            var assets = link[i].get(path);
            if (assets) {
                for(var a = 0; a < assets.length; a++)
                    addAsset(assets[a]);
            }

            events.push(link[i].on(path + ':set', function(assets, assetsOld) {
                if (! (assets instanceof Array))
                    return;

                if (! (assetsOld instanceof Array))
                    assetsOld = [ ];

                var assetIds = { };
                for(var a = 0; a < assets.length; a++)
                    assetIds[assets[a]] = true;

                var assetOldIds = { };
                for(var a = 0; a < assetsOld.length; a++)
                    assetOldIds[assetsOld[a]] = true;

                // remove
                for(var id in assetOldIds) {
                    if (assetIds[id])
                        continue;

                    removeAsset(id);
                }

                // add
                for(var id in assetIds)
                    addAsset(id);
            }));

            events.push(link[i].on(path + ':insert', function(assetId, ind) {
                var before;
                if (ind === 0) {
                    before = itemAdd;
                } else {
                    before = assetIndex[this.get(path + '.' + ind)];
                }
                addAsset(assetId, before);
            }));

            events.push(link[i].on(path + ':remove', removeAsset));
        }

        fieldAssetsList.once('destroy', function() {
            for(var i = 0; i < events.length; i++)
                events[i].unbind();
        });

        return fieldAssetsList;
    });

    var inspectedItems = [ ];

    editor.on('attributes:clear', function() {
        for(var i = 0; i < inspectedItems.length; i++) {
            inspectedItems[i].unbind();
        }
        inspectedItems = [ ];
    });

    editor.method('attributes:inspect', function(type, item) {
        clearPanel();

        // clear if destroyed
        inspectedItems.push(item.once('destroy', function() {
            editor.call('attributes:clear');
        }));

        root.header = type;
        editor.emit('attributes:inspect[' + type + ']', [ item ]);
        editor.emit('attributes:inspect[*]', type, [ item ]);
    });

    editor.on('selector:change', function(type, items) {
        clearPanel();

        // nothing selected
        if (items.length === 0) {
            var label = new ui.Label({ text: 'Select anything to Inspect' });
            label.style.display = 'block';
            label.style.textAlign = 'center';
            root.append(label);

            root.header = title;

            return;
        }

        // clear if destroyed
        for(var i = 0; i < items.length; i++) {
            inspectedItems.push(items[i].once('destroy', function() {
                editor.call('attributes:clear');
            }));
        }

        root.header = type;
        editor.emit('attributes:inspect[' + type + ']', items);
        editor.emit('attributes:inspect[*]', type, items);
    });

    editor.emit('selector:change', null, [ ]);
});


/* editor/attributes/attributes-reference.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');
    var panel = editor.call('layout.right');


    editor.method('attributes:reference', function(args) {
        var tooltip = new ui.Tooltip({
            align: 'right'
        });
        tooltip.hoverable = true;
        tooltip.class.add('reference');

        var html = '';
        if (args.title)
            html += '<h1>' + args.title + '</h1>';
        if (args.subTitle)
            html += '<h2>' + args.subTitle + '</h2>';
        if (args.description)
            html += '<p>' + args.description + '</p>';
        if (args.url)
            html += '<a class="reference" href="' + args.url + '" target="_blank">API Reference</a>';
        tooltip.html = html;

        var links = { };
        var timerHover = null;
        var timerBlur = null;

        tooltip.attach = function(args) {
            var target = args.target;
            var element = args.element;

            var show = function() {
                if (! target || target.hidden) return;
                tooltip.position(panel.element.getBoundingClientRect().left, element.getBoundingClientRect().top + 16);
                tooltip.hidden = false;
            };

            var evtHide = function() {
                clearTimeout(timerHover);
                clearTimeout(timerBlur);
                tooltip.hidden = true;
            };

            var evtHover = function() {
                clearTimeout(timerBlur);
                timerHover = setTimeout(show, 500);
            };

            var evtBlur = function() {
                clearTimeout(timerHover);
                timerBlur = setTimeout(hide, 200);
            };

            var evtClick = function() {
                clearTimeout(timerBlur);
                clearTimeout(timerHover);
                show();
            };

            target.on('hide', evtHide);

            target.once('destroy', function() {
                element.removeEventListener('mouseover', evtHover);
                element.removeEventListener('mouseout', evtBlur);
                element.removeEventListener('click', evtClick);
                target.unbind('hide', evtHide);
                target = null;
                element = null;
                clearTimeout(timerHover);
                clearTimeout(timerBlur);
                tooltip.hidden = true;
            });

            element.addEventListener('mouseover', evtHover, false);
            element.addEventListener('mouseout', evtBlur, false);
            element.addEventListener('click', evtClick, false);
        };

        var hide = function() {
            tooltip.hidden = true;
        };

        tooltip.on('hover', function() {
            clearTimeout(timerBlur);
        });

        root.append(tooltip);

        return tooltip;
    });
});


/* editor/attributes/reference/attributes-settings-reference.js */
editor.once('load', function() {
    'use strict';

    var create = function(args) {
        var tooltip = editor.call('attributes:reference', args);

        editor.method('attributes:reference:settings' + (args.name ? (':' + args.name) : '') + ':attach', function(target, element) {
            tooltip.attach({
                target: target,
                element: element || target.element
            });
        });
    };

    var fields = [
        {
            title: 'name',
            subTitle: '{String}',
            description: 'Name of the Scene for better navigation across content.'
        }, {
            name: 'designer',
            description: 'Editor Settings are applied per user basis and only visible to you, and not team collaborators. Although rest of other sections are shared for the Scene for all collaborators.'
        }, {
            name: 'snap',
            description: 'Change increment value for Snap gizmo state. Use SHIFT or Snap Toggle on toolbar to enable Snapping during use of Gizmos.'
        }, {
            name: 'grid',
            description: 'To disable grid set Divisions to 0. Divisions specify number of grid rectangles in each horizontal direction. And Size specifies the size of a rectangles.'
        }, {
            name: 'cameraClip',
            description: 'If your scene is too large or objects needs to be too close, change Near/Far clip values of a camera for Editor. This setting does not affects the game.'
        }, {
            name: 'clearColor',
            description: 'Set the Camera Clear Color of your preference to affect Editor. This color will not affect the game.'
        }, {
            name: 'localServer',
            description: 'Set a URL to use as the local server. When you click on "Launch Local" all your scripts will be loaded from this URL.'
        }, {
            title: 'gravity',
            subTitle: '{pc.Vec3}',
            description: 'Gravity is the acceleration applied every frame to all rigid bodies in your scene. By default, it is set to -9.8 meters per second per second, which essentially approximates Earth\'s gravity. If you are making a game in space, you might want to set this to 0, 0, 0 (zero g).',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.RigidBodyComponentSystem.html#setGravity'
        }, {
            title: 'ambientColor',
            subTitle: '{pc.Color}',
            description: 'The color of the scene\'s ambient light source. PlayCanvas allows you to create directional, point and spot lights. These lights account for direct light that falls on objects. But in reality, light actually bounces around the environment and we call this indirect light. A global ambient light is a crude approximation of this and allows you to set a light source that appears to shine from all directions. The global ambient color is multiplied with the Ambient property of a Phong Material to add a contribution to the final color of an object.<br /><br />Note, if you are using a Skybox and Physical Materials the Ambient Color has no effect.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Scene.html#ambientLight'
        }, {
            title: 'skybox',
            subTitle: '{pc.Texture}',
            description: 'The Skybox is a cubemap asset that is rendered behind your 3D scene. This lets your use a set of 6 2D images to display the distant world beyond the 3D models in your scene.<br /><br />To add a skybox, create a cubemap asset and then assign it to the cubemap slot in the settings panel.<br /><br />Note, if you are using a Prefiltered Cubemap, the skybox will be used as the default environment map for all Physical materials.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Scene.html#skybox'
        }, {
            title: 'skyboxIntensity',
            subTitle: '{Number}',
            description: 'Intensity of the skybox to match the exposure levels.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Scene.html#skyboxIntensity'
        }, {
            title: 'skyboxMip',
            subTitle: '{Number}',
            description: 'Mip level of the prefiletered skybox, higher value is lower mip level which is lower resolution and more prefiltered (blured).',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Scene.html#skyboxMip'
        }, {
            title: 'toneMapping',
            subTitle: '{Number}',
            description: 'Tonemapping is the process of compressing High Dynamic Range (HDR) colors into limited Low Dynamic Range (e.g. into visible monitor output values). There are two options for tonemapping.<br />Linear: imply scales HDR colors by exposure.<br />Filmic: More sophisticated curve, good at softening overly bright spots, while preserving dark shades as well.<br /><br />Linear tonemapping is active by default, it\'s simply (color * exposure). You can tweak exposure to make quick changes to brightness. Note that it\'s not just simple brightness  la Photoshop because your input can be HDR. e.g. If you have a light source with intensity = 8, it will still be quite bright (4) after exposure = 0.5. So, all visible things won\'t just fade out linearly.<br /><br />Filmic tonemapping is a good choice in high-contrast environments, like scenes lit by bright Sun, or interiors with bright lights being close to walls/ceiling. It will nicely remap out-of-range super bright values to something more perceptually realistic (our eyes and film do tonemapping as well, we don\'t see physically linear values). Well, ask any photographer: nobody likes to leave extremely bright spots as well as pitch black spots on a photo. Filmic tonemapping gives you nice abilities to get rid of such spots.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Scene.html#tomeMapping'
        }, {
            title: 'exposure',
            subTitle: '{Number}',
            description: 'The exposure value tweaks the overall brightness of the scene.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Scene.html#exposure'
        }, {
            title: 'gammaCorrection',
            subTitle: '{pc.GAMMA_*}',
            description: 'Computer screens are set up to output not physically linear, but perceptually linear (sRGB) signal. However, for correct appearance when performing lighting calculations, color textures must be converted to physically linear space, and then the fully lit image must be fit again into sRGB. Rendering with gamma correction enabled reduces the number of ugly, overly saturated highlights and better preserves color after lighting, and it\'s generally recommended that this be enabled in your scene. The following image shows a simple scene with a sphere. On the left the scene has been gamma corrected while on the right, the scene is uncorrected.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Scene.html#gammaCorrection'
        }, {
            title: 'fog',
            subTitle: '{pc.FOG_*}',
            description: 'The Fog Type property can be used to control an approximation of an ambient fog in your scene. Here is an example of fog being enabled:<br /><br />The types available are as follows:<br />None - Fog is disabled<br />Linear - Fog fades in linearly between a Fog Start and Fog End distance<br />Exp - Fog fades in from the view position according to an exponential function<br />Exp2 - Fog fades in from the view position according to an exponential squared function',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Scene.html#fog'
        }, {
            title: 'fogDensity',
            subTitle: '{Number}',
            description: 'The fog density controls the rate at which fog fades in for Exp and Exp2 fog types. Larger values cause fog to fade in more quickly. Fog density must be a positive number.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Scene.html#fogDensity'
        }, {
            name: 'fogDistance',
            title: 'fogStart / fogEnd',
            subTitle: '{Number}',
            description: 'The distance in scene units from the viewpoint from where the fog starts to fade in and reaches a maximum. Any objects beyond maximum distance will be rendered with the fog color.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Scene.html#fogEnd'
        }, {
            title: 'fogColor',
            subTitle: '{pc.Color}',
            description: 'The color of the fog. This color is blended with a surface\'s color more as the fog fades in.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Scene.html#fogColor'
        }, {
            name: 'loadingScreenScript',
            title: 'Loading Screen Script',
            subTitle: '{String}',
            description: 'The name of the script to use for creating the loading screen of the application. The script needs to call pc.script.createLoadingScreen.',
            url: 'http://developer.playcanvas.com/en/engine/api/stable/symbols/pc.script.html#createLoadingScreen'
        }
    ];

    // fields reference
    for(var i = 0; i < fields.length; i++) {
        fields[i].name = fields[i].name || fields[i].title;
        create(fields[i]);
    }
});


/* editor/attributes/reference/attributes-entity-reference.js */
editor.once('load', function() {
    'use strict';

    var create = function(args) {
        var tooltip = editor.call('attributes:reference', args);

        editor.method('attributes:reference:entity' + (args.name ? (':' + args.name) : '') + ':attach', function(target, element) {
            tooltip.attach({
                target: target,
                element: element || target.element
            });
        });
    };

    var fields = [
        {
            title: 'enabled',
            subTitle: '{Boolean}',
            description: 'If unchecked, entity wont be processed nor any of its components.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Entity.html'
        }, {
            title: 'name',
            subTitle: '{String}',
            description: 'Human-readable name for this graph node.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Entity.html'
        }, {
            title: 'position',
            subTitle: '{pc.Vec3}',
            description: 'Position in Local Space',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Entity.html'
        }, {
            title: 'rotation',
            subTitle: '{pc.Vec3}',
            description: 'Rotation in Local Space',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Entity.html'
        }, {
            title: 'scale',
            subTitle: '{pc.Vec3}',
            description: 'Scale in Local Space',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Entity.html'
        },
    ];

    // fields reference
    for(var i = 0; i < fields.length; i++) {
        fields[i].name = fields[i].title;
        create(fields[i]);
    }
});


/* editor/attributes/reference/attributes-components-animation-reference.js */
editor.once('load', function() {
    'use strict';

    var create = function(args) {
        var tooltip = editor.call('attributes:reference', args);

        editor.method('attributes:reference:animation' + (args.name ? (':' + args.name) : '') + ':attach', function(target, element) {
            tooltip.attach({
                target: target,
                element: element || target.element
            });
        });
    };

    var fields = [
        {
            title: 'assets',
            subTitle: '{Number[]}',
            description: 'The animation assets that can be utilized by this entity. Multiple animations can be assigned via the picker control.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.AnimationComponent.html#assets'
        }, {
            title: 'speed',
            subTitle: '{Number}',
            description: 'A multiplier for animation playback speed. 0 will freeze animation playback, and 1 represents the normal playback speed of the asset.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.AnimationComponent.html#speed'
        }, {
            title: 'activate',
            subTitle: '{Boolean}',
            description: 'If checked, the component will start playing the animation on load.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.AnimationComponent.html#activate'
        }, {
            title: 'loop',
            subTitle: '{Boolean}',
            description: 'If checked, the animation will continue to loop back to the start on completion. Otherwise, the animation will come to a stop on its final frame.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.AnimationComponent.html#loop'
        }
    ];

    // component reference
    create({
        title: 'pc.AnimationComponent',
        subTitle: '{pc.Component}',
        description: 'Enables an entity to specify which animations can be applied to the model assigned to its model component.',
        url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.AnimationComponent.html'
    });

    // fields reference
    for(var i = 0; i < fields.length; i++) {
        fields[i].name = fields[i].title;
        create(fields[i]);
    }
});


/* editor/attributes/reference/attributes-components-audiolistener-reference.js */
editor.once('load', function() {
    'use strict';

    var create = function(args) {
        var tooltip = editor.call('attributes:reference', args);

        editor.method('attributes:reference:audiolistener' + (args.name ? (':' + args.name) : '') + ':attach', function(target, element) {
            tooltip.attach({
                target: target,
                element: element || target.element
            });
        });
    };

    var fields = [ ];

    // component reference
    create({
        title: 'pc.AudioListenerComponent',
        subTitle: '{pc.Component}',
        description: 'Specifies the listener\'s position in 3D space. All 3D audio playback will be relative to this position.',
        url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.AudioListenerComponent.html'
    });

    // fields reference
    for(var i = 0; i < fields.length; i++) {
        fields[i].name = fields[i].title;
        create(fields[i]);
    }
});


/* editor/attributes/reference/attributes-components-audiosource-reference.js */
editor.once('load', function() {
    'use strict';

    var create = function(args) {
        var tooltip = editor.call('attributes:reference', args);

        editor.method('attributes:reference:audiosource' + (args.name ? (':' + args.name) : '') + ':attach', function(target, element) {
            tooltip.attach({
                target: target,
                element: element || target.element
            });
        });
    };

    var fields = [
        {
            title: '3d',
            subTitle: '{Boolean}',
            description: 'If checked, the component will play back audio assets as if played from the location of the entity in 3D space.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.AudioSourceComponent.html#3d'
        }, {
            title: 'activate',
            subTitle: '{Boolean}',
            description: 'If checked, the first audio asset specified by the Assets property will be played on load. Otherwise, audio assets will need to be played using script.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.AudioSourceComponent.html#activate'
        }, {
            title: 'assets',
            subTitle: '{Number[]}',
            description: 'The audio assets that can be played from this audio source. Multiple audio assets can be specified by the picker control.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.AudioSourceComponent.html#assets'
        }, {
            title: 'loop',
            subTitle: '{Boolean}',
            description: 'If checked, the component will loop played audio assets continuously. Otherwise, audio assets are played once to completion.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.AudioSourceComponent.html#loop'
        }, {
            title: 'distance',
            subTitle: '{Number}',
            description: 'minDistance - the distance at which the volume of playback begins to fall from its maximum.<br />maxDistance - The distance at which the volume of playback falls to zero.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.AudioSourceComponent.html#maxDistance'
        }, {
            title: 'pitch',
            subTitle: '{Number}',
            description: 'The pitch to playback the audio at. A value of 1 means the audio is played back at the original pitch.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.AudioSourceComponent.html#pitch'
        }, {
            title: 'rollOffFactor',
            subTitle: '{Number}',
            description: 'The rate at which volume fall-off occurs.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.AudioSourceComponent.html#rollOffFactor'
        }, {
            title: 'volume',
            subTitle: '{Number}',
            description: 'The volume of the audio assets played back by the component.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.AudioSourceComponent.html#volume'
        }
    ];

    // component reference
    create({
        title: 'pc.AudioSourceComponent',
        subTitle: '{pc.Component}',
        description: 'Specifies the listener\'s position in 3D space. All 3D audio playback will be relative to this position.',
        url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.AudioSourceComponent.html'
    });

    // fields reference
    for(var i = 0; i < fields.length; i++) {
        fields[i].name = fields[i].title;
        create(fields[i]);
    }
});


/* editor/attributes/reference/attributes-components-camera-reference.js */
editor.once('load', function() {
    'use strict';

    var create = function(args) {
        var tooltip = editor.call('attributes:reference', args);

        editor.method('attributes:reference:camera' + (args.name ? (':' + args.name) : '') + ':attach', function(target, element) {
            tooltip.attach({
                target: target,
                element: element || target.element
            });
        });
    };

    var fields = [
        {
            title: 'clearColor',
            subTitle: '{pc.Color}',
            description: 'The color used to clear the camera\'s render target.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.CameraComponent.html#clearColor'
        }, {
            title: 'clearColorBuffer',
            subTitle: '{Boolean}',
            description: 'If selected, the camera will explicitly clear its render target to the chosen clear color before rendering the scene.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.CameraComponent.html#clearColorBuffer'
        }, {
            title: 'clearDepthBuffer',
            subTitle: '{Boolean}',
            description: 'If selected, the camera will explicitly clear the depth buffer of its render target before rendering the scene.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.CameraComponent.html#clearDepthBuffer'
        }, {
            name: 'clip',
            title: 'nearClip / farClip',
            subTitle: '{Number}',
            description: 'The distance in camera space from the camera\'s eye point to the near and far clip planes.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.CameraComponent.html#farClip'
        }, {
            title: 'fov',
            subTitle: '{Number}',
            description: 'Field of View is the angle between top and bottom clip planes of a perspective camera.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.CameraComponent.html#fov'
        }, {
            title: 'orthoHeight',
            subTitle: '{Number}',
            description: 'The distance in world units between the top and bottom clip planes of an orthographic camera.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.CameraComponent.html#orthoHeight'
        }, {
            title: 'priority',
            subTitle: '{Number}',
            description: 'A number that defines the order in which camera views are rendered by the engine. Smaller numbers are rendered first.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.CameraComponent.html#priority'
        }, {
            title: 'projection',
            subTitle: '{pc.PROJECTION_*}',
            description: 'The projection type of the camera.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.CameraComponent.html#projection'
        }, {
            title: 'rect',
            subTitle: '{pc.Vec4}',
            description: 'A rectangle that specifies the viewport onto the camera\'s attached render target. This allows you to implement features like split-screen or picture-in-picture. It is defined by normalised coordinates (0 to 1) in the following format:<br />x: The lower left x coordinate<br />y: The lower left y coordinate<br />w: The width of the rectangle<br />h: The height of the rectangle',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.CameraComponent.html#rect'
        }
    ];

    // component reference
    create({
        title: 'pc.CameraComponent',
        subTitle: '{pc.Component}',
        description: 'Enables an entity to render a scene from a certain viewpoint.',
        url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.CameraComponent.html'
    });

    // fields reference
    for(var i = 0; i < fields.length; i++) {
        fields[i].name = fields[i].title;
        create(fields[i]);
    }
});


/* editor/attributes/reference/attributes-components-collision-reference.js */
editor.once('load', function() {
    'use strict';

    var create = function(args) {
        var tooltip = editor.call('attributes:reference', args);

        editor.method('attributes:reference:collision' + (args.name ? (':' + args.name) : '') + ':attach', function(target, element) {
            tooltip.attach({
                target: target,
                element: element || target.element
            });
        });
    };

    var fields = [
        {
            title: 'asset',
            subTitle: '{Number}',
            description: 'The model asset that will be used as a source for the triangle-based collision mesh.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.CollisionComponent.html#asset'
        }, {
            title: 'axis',
            subTitle: '{Number}',
            description: 'Aligns the capsule/cylinder with the local-space X, Y or Z axis of the entity',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.CollisionComponent.html#axis'
        }, {
            title: 'halfExtents',
            subTitle: '{pc.Vec3}',
            description: 'The half-extents of the collision box. This is a 3-dimensional vector: local space half-width, half-height, and half-depth.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.CollisionComponent.html#halfExtents'
        }, {
            title: 'height',
            subTitle: '{Number}',
            description: 'The tip-to-tip height of the capsule/cylinder.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.CollisionComponent.html#height'
        }, {
            title: 'radius',
            subTitle: '{Number}',
            description: 'The radius of the capsule/cylinder body.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.CollisionComponent.html#radius'
        }, {
            title: 'type',
            subTitle: '{String}',
            description: 'The type of collision primitive. Can be: box, sphere, capsulse, cylinder, mesh.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.CollisionComponent.html#type'
        }
    ];

    // component reference
    create({
        title: 'pc.CollisionComponent',
        subTitle: '{pc.Component}',
        description: 'A collision volume. use this in conjunction with a pc.RigidBodyComponent to make a collision volume that can be simulated using the physics engine.<br /><br />If the pc.Entity does not have a pc.RigidBodyComponent then this collision volume will act as a trigger volume. When an entity with a dynamic or kinematic body enters or leaves an entity with a trigger volume, both entities will receive trigger events.',
        url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.CollisionComponent.html'
    });

    // fields reference
    for(var i = 0; i < fields.length; i++) {
        fields[i].name = fields[i].title;
        create(fields[i]);
    }
});


/* editor/attributes/reference/attributes-components-light-reference.js */
editor.once('load', function() {
    'use strict';

    var create = function(args) {
        var tooltip = editor.call('attributes:reference', args);

        editor.method('attributes:reference:light' + (args.name ? (':' + args.name) : '') + ':attach', function(target, element) {
            tooltip.attach({
                target: target,
                element: element || target.element
            });
        });
    };

    var fields = [
        {
            title: 'castShadows',
            subTitle: '{Boolean}',
            description: 'If checked, the light will cause shadow casting models to cast shadows.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.LightComponent.html#castShadows'
        }, {
            title: 'color',
            subTitle: '{pc.Color}',
            description: 'The color of the emitted light.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.LightComponent.html#color'
        }, {
            title: 'falloffMode',
            subTitle: '{pc.LIGHTFALLOFF_*}',
            description: 'Controls the rate at which a light attentuates from its position.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.LightComponent.html#falloffMode'
        }, {
            title: 'coneAngles',
            subTitle: '{Number}',
            description: 'The angles from the spotlight\'s direction at which light begins to fall from its maximum (innerConeAngle) and zero value (outerConeAngle).',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.LightComponent.html#innerConeAngle'
        }, {
            title: 'intensity',
            subTitle: '{Number}',
            description: 'The intensity of the light, this acts as a scalar value for the light\'s color. This value can exceed 1.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.LightComponent.html#intensity'
        }, {
            title: 'normalOffsetBias',
            subTitle: '{Number}',
            description: 'Normal offset depth bias.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.LightComponent.html#normalOffsetBias'
        }, {
            title: 'range',
            subTitle: '{Number}',
            description: 'The distance from the spotlight source at which its contribution falls to zero.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.LightComponent.html#range'
        }, {
            title: 'shadowBias',
            subTitle: '{Number}',
            description: 'Constant depth offset applied to a shadow map that enables the tuning of shadows in order to eliminate rendering artifacts, namely \'shadow acne\' and \'peter-panning\'.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.LightComponent.html#shadowBias'
        }, {
            title: 'shadowDistance',
            subTitle: '{Number}',
            description: 'The shadow distance is the maximum distance from the camera beyond which shadows that come from Directional Lights are no longer visible. Smaller values produce more detailed shadows. The closer the limit the less shadow data has to be mapped to, and represented by, any shadow map; shadow map pixels are mapped spatially and so the less distance the shadow map has to cover, the smaller the pixels and so the more resolution any shadow has.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.LightComponent.html#shadowDistance'
        }, {
            title: 'shadowResolution',
            subTitle: '{Number}',
            description: 'The size of the texture used for the shadow map.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.LightComponent.html#shadowResolution'
        },{
            title: 'type',
            subTitle: '{string}',
            description: 'The type of light. Can be: directional, point, spot.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.LightComponent.html#type'
        }
    ];

    // component reference
    create({
        title: 'pc.LightComponent',
        subTitle: '{pc.Component}',
        description: 'The Light Component enables the Entity to light the scene.',
        url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.LightComponent.html'
    });

    // fields reference
    for(var i = 0; i < fields.length; i++) {
        fields[i].name = fields[i].title;
        create(fields[i]);
    }
});


/* editor/attributes/reference/attributes-components-model-reference.js */
editor.once('load', function() {
    'use strict';

    var create = function(args) {
        var tooltip = editor.call('attributes:reference', args);

        editor.method('attributes:reference:model' + (args.name ? (':' + args.name) : '') + ':attach', function(target, element) {
            tooltip.attach({
                target: target,
                element: element || target.element
            });
        });
    };

    var fields = [
        {
            title: 'asset',
            subTitle: '{Number}',
            description: 'The model asset rendered by this model component. Only a single model can be rendered per model component.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ModelComponent.html#asset'
        }, {
            title: 'castShadows',
            subTitle: '{Boolean}',
            description: 'If enabled, the model rendered by this component will cast shadows onto other models in the scene.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ModelComponent.html#castShadows'
        }, {
            title: 'materialAsset',
            subTitle: '{Number}',
            description: 'The material that will be used to render the model (only applies to primitives)',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ModelComponent.html#materialAsset'
        }, {
            title: 'receiveShadows',
            subTitle: '{Boolean}',
            description: 'If enabled, the model rendered by this component will receive shadows cast by other models in the scene.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ModelComponent.html#receiveShadows'
        }, {
            title: 'type',
            subTitle: '{String}',
            description: 'The type of the model to be rendered. Can be: asset, box, capsule, cone, cylinder, sphere.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ModelComponent.html#type'
        }
    ];

    // component reference
    create({
        title: 'pc.ModelComponent',
        subTitle: '{pc.Component}',
        description: 'Enables an Entity to render a model or a primitive shape. This Component attaches additional model geometry in to the scene graph below the Entity.',
        url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ModelComponent.html'
    });

    // fields reference
    for(var i = 0; i < fields.length; i++) {
        fields[i].name = fields[i].title;
        create(fields[i]);
    }
});


/* editor/attributes/reference/attributes-components-particlesystem-reference.js */
editor.once('load', function() {
    'use strict';

    var create = function(args) {
        var tooltip = editor.call('attributes:reference', args);

        editor.method('attributes:reference:particlesystem' + (args.name ? (':' + args.name) : '') + ':attach', function(target, element) {
            tooltip.attach({
                target: target,
                element: element || target.element
            });
        });
    };

    var fields = [
        {
            title: 'autoPlay',
            subTitle: '{Boolean}',
            description: 'If checked, the particle system will play immediately on creation. If this option is left unchecked, you will need to call the particle system component\'s play function from script.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#autoPlay'
        }, {
            title: 'alignToMotion',
            subTitle: '{Boolean}',
            description: 'Orient particle in their direction of motion.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#alignToMotion'
        }, {
            title: 'alphaGraph',
            subTitle: '{pc.Curve}',
            description: 'A curve defining how each particle\'s opacity changes over time. If two curves are specified in the curve editor, the opacity will be a random lerp between both curves.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#alphaGraph'
        }, {
            title: 'animTilesX',
            subTitle: '{Number}',
            description: 'Number of horizontal tiles in the sprite sheet',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#animTilesX'
        }, {
            title: 'animTilesY',
            subTitle: '{Number}',
            description: 'Number of vertical tiles in the sprite sheet',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#animTilesY'
        }, {
            title: 'animNumFrames',
            subTitle: '{Number}',
            description: 'Number of sprite sheet frames to play',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#animNumFrames'
        }, {
            title: 'animSpeed',
            subTitle: '{Number}',
            description: 'Sprite sheet animation speed. 1 = particle lifetime, 2 = twice during lifetime etc...',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#animSpeed'
        }, {
            title: 'animLoop',
            subTitle: '{Boolean}',
            description: 'If true then the sprite sheet animation will repeat indefinitely',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#animLoop'
        }, {
            title: 'blend',
            subTitle: '{pc.BLEND_*}',
            description: 'The blending mode determines how particles are composited when they are written to the frame buffer. Let\'s consider that Prgb is the RGB color of a particle\'s pixel, Pa is its alpha value, and Drgb is the RGB color already in the frame buffer.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#blend'
        }, {
            title: 'colorGraph',
            subTitle: '{pc.CurveSet}',
            description: 'A curve defining how each particle\'s color changes over time.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#colorGraph'
        }, {
            title: 'colorMap',
            subTitle: '{pc.Texture}',
            description: 'The color map texture to apply to all particles in the system. If no texture asset is assigned, a default spot texture is used.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#colorMap'
        }, {
            title: 'depthSoftening',
            subTitle: '{Number}',
            description: 'This variable value determines how much particles fade out as they get closer to another surface. This avoids the situation where particles appear to cut into surfaces.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#depthSoftening'
        }, {
            title: 'depthWrite',
            subTitle: '{Boolean}',
            description: 'If checked, the particles will write depth information to the depth buffer. If unchecked, the depth buffer is left unchanged and particles will be guaranteed to overwrite one another in the order in which they are rendered.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#depthWrite'
        }, {
            title: 'emitterExtents',
            subTitle: '{pc.Vec3}',
            description: 'The half extents of a local space bounding box within which particles are spawned at random positions.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#emitterExtents'
        }, {
            title: 'emitterRadius',
            subTitle: '{Number}',
            description: 'The radius within which particles are spawned at random positions.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#emitterRadius'
        }, {
            title: 'emitterShape',
            subTitle: '{pc.EMITTERSHAPE_*}',
            description: 'Shape of the emitter. Can be: pc.EMITTERSHAPE_BOX, pc.EMITTERSHAPE_SPHERE.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#emitterShape'
        }, {
            title: 'halfLambert',
            subTitle: '{Boolean}',
            description: 'Enabling Half Lambert lighting avoids particles looking too flat when lights appear to be shining towards the back sides of the particles. It is a completely non-physical lighting model but can give more pleasing visual results. This option is only available when Lighting is enabled.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#halfLambert'
        }, {
            title: 'intensity',
            subTitle: '{Number}',
            description: 'Scales the color of particles to allow them to have arbitrary brightness.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#intensity'
        }, {
            title: 'lifetime',
            subTitle: '{Number}',
            description: 'The length of time in seconds between a particle\'s birth and its death.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#lifetime'
        }, {
            title: 'lighting',
            subTitle: '{Boolean}',
            description: 'If checked, the particle will be lit by the directional and ambient light in the scene. In some circumstances, it may be advisable to set a normal map on the particle system in order to achieve more realistic lighting.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#lighting'
        }, {
            title: 'localVelocityGraph',
            subTitle: '{pc.CurveSet}',
            description: 'A curve defining how each particle\'s velocity with respect to the particle system\'s local coordinate system changes over time. If two curves are specified in the curve editor, local velocity will be a random lerp between both curves.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#localVelocityGraph'
        }, {
            title: 'loop',
            subTitle: '{Boolean}',
            description: 'If checked, the particle system will emit indefinitely. Otherwise, it will emit the number of particles specified by the \'Particle Count\' property and then stop.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#loop'
        }, {
            title: 'mesh',
            subTitle: '{pc.Mesh}',
            description: 'A model asset. The first mesh found in the model is used to represent all particles rather than a flat billboard.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#mesh'
        }, {
            title: 'normalMap',
            subTitle: '{pc.Texture}',
            description: 'The normal map texture to apply to all particles in the system. Applying a normal map can make billboard particles appear more consistent with the scenes lighting.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#normalMap'
        }, {
            title: 'numParticles',
            subTitle: '{Number}',
            description: 'The maximum number of particles managed by this particle system.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#numParticles'
        }, {
            title: 'paused',
            subTitle: '{Boolean}',
            description: 'Pauses or unpauses the simulation.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#paused'
        }, {
            title: 'preWarm',
            subTitle: '{Boolean}',
            description: 'If enabled, the particle system will be initialized as though it had already completed a full cycle. This option is only available for looping particle systems.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#preWarm'
        }, {
            title: 'rate',
            subTitle: '{Number}',
            description: 'The bounds of the time range defining the interval in seconds between particle births. The time for the next particle emission will be chosen at random between rate and rate2.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#rate'
        }, {
            title: 'rotationSpeedGraph',
            subTitle: '{pc.Curve}',
            description: 'A curve defining how each particle\'s angular velocity changes over time. If two curves are specified in the curve editor, the angular velocity will be a random lerp between both curves.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#rotationSpeedGraph'
        }, {
            title: 'scaleGraph',
            subTitle: '{pc.Curve}',
            description: 'A curve defining how each particle\'s scale changes over time. By default, a particle is 1 unit in width and height. If two curves are specified in the curve editor, the scale will be a random lerp between both curves.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#scaleGraph'
        }, {
            title: 'sort',
            subTitle: '{pc.PARTICLESORT_*}',
            description: 'Sorting mode gives you control over the order in which particles are rendered. The options are:<br />None: Particles are rendered in arbitrary order. When this option is selected, the particle system is simulated on the GPU (if the underlying hardware supports floating point textures) and it is recommended you use this setting to get the best performance.<br />Camera Distance: Particles are sorted on the CPU and rendered in back to front order (in terms of camera z depth).<br />Newer First: Particles are sorted on the CPU and rendered in age order, youngest first.<br />Older First: Particles are sorted on the CPU and rendered in age order, oldest first.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#sort'
        }, {
            title: 'startAngle',
            subTitle: '{Number}',
            description: 'The bounds of the initial particle rotation specified in degrees. For each particle, this angle is chosen at random between startAngle and startAngle2.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#startAngle'
        }, {
            title: 'stretch',
            subTitle: '{Number}',
            description: 'A value in world units that controls the amount by which particles are stretched based on their velocity. Particles are stretched from their center towards their previous position.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#stretch'
        }, {
            title: 'velocityGraph',
            subTitle: '{pc.CurveSet}',
            description: 'A curve defining how each particle\'s velocity with respect to the world coordinate system changes over time. If two curves are specified in the curve editor, velocity will be a random lerp between both curves.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#velocityGraph'
        }, {
            title: 'wrap',
            subTitle: '{Boolean}',
            description: 'Enables wrap bounds.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#wrap'
        }, {
            title: 'wrapBounds',
            subTitle: '{pc.Vec3}',
            description: 'World space AABB volume centered on the owner entity\'s position. If a particle crosses the boundary of one side of the volume, it teleports to the opposite side. You can use this to make environmental effects like rain by moving a wrapped emitter\'s owner entity.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html#wrapBounds'
        }
    ];

    // component reference
    create({
        title: 'pc.ParticleSystemComponent',
        subTitle: '{pc.Component}',
        description: 'Used to simulate particles and produce renderable particle mesh in scene.',
        url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ParticleSystemComponent.html'
    });

    // fields reference
    for(var i = 0; i < fields.length; i++) {
        fields[i].name = fields[i].title;
        create(fields[i]);
    }
});


/* editor/attributes/reference/attributes-components-rigidbody-reference.js */
editor.once('load', function() {
    'use strict';

    var create = function(args) {
        var tooltip = editor.call('attributes:reference', args);

        editor.method('attributes:reference:rigidbody' + (args.name ? (':' + args.name) : '') + ':attach', function(target, element) {
            tooltip.attach({
                target: target,
                element: element || target.element
            });
        });
    };

    var fields = [
        {
            name: 'damping',
            title: 'angularDamping / linearDamping',
            subTitle: '{Number}',
            description: 'Controls the rate at which a body loses angular/linear velocity over time.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.RigidBodyComponent.html#angularDamping'
        }, {
            title: 'angularFactor',
            subTitle: '{pc.Vec3}',
            description: 'Scaling factor for angular movement of the body in each axis.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.RigidBodyComponent.html#angularFactor'
        }, {
            title: 'friction',
            subTitle: '{Number}',
            description: 'The friction value used when contacts occur between two bodies.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.RigidBodyComponent.html#friction'
        }, {
            title: 'group',
            subTitle: '{Number}',
            description: 'description',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.RigidBodyComponent.html#group'
        }, {
            title: 'linearFactor',
            subTitle: '{pc.Vec3}',
            description: 'Scaling factor for linear movement of the body in each axis.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.RigidBodyComponent.html#linearFactor'
        }, {
            title: 'mass',
            subTitle: '{Number}',
            description: 'The mass of the body.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.RigidBodyComponent.html#mass'
        }, {
            title: 'restitution',
            subTitle: '{Number}',
            description: 'The amount of energy lost when two objects collide, this determines the bounciness of the object.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.RigidBodyComponent.html#restitution'
        }, {
            title: 'type',
            subTitle: '{pc.RIGIDBODY_TYPE_*}',
            description: 'The type of RigidBody determines how it is simulated.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.RigidBodyComponent.html#type'
        },
    ];

    // component reference
    create({
        title: 'pc.RigidBodyComponent',
        subTitle: '{pc.Component}',
        description: 'The rigidbody Component, when combined with a pc.CollisionComponent, allows your Entities to be simulated using realistic physics. A rigidbody Component will fall under gravity and collide with other rigid bodies, using scripts you can apply forces to the body.',
        url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.RigidBodyComponent.html'
    });

    // fields reference
    for(var i = 0; i < fields.length; i++) {
        fields[i].name = fields[i].name || fields[i].title;
        create(fields[i]);
    }
});


/* editor/attributes/reference/attributes-components-script-reference.js */
editor.once('load', function() {
    'use strict';

    var create = function(args) {
        var tooltip = editor.call('attributes:reference', args);

        editor.method('attributes:reference:script' + (args.name ? (':' + args.name) : '') + ':attach', function(target, element) {
            tooltip.attach({
                target: target,
                element: element || target.element
            });
        });
    };

    var fields = [
        {
            title: 'scripts',
            subTitle: '{Object[]}',
            description: 'Add scripts by clicking on the button or drag scripts on the script component.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ScriptComponent.html#scripts'
        }
    ];

    // component reference
    create({
        title: 'pc.ScriptComponent',
        subTitle: '{pc.Component}',
        description: 'The ScriptComponent allows you to extend the functionality of an Entity by attaching your own javascript files to be executed with access to the Entity. For more details on scripting see Scripting.',
        url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.ScriptComponent.html'
    });

    // fields reference
    for(var i = 0; i < fields.length; i++) {
        fields[i].name = fields[i].title;
        create(fields[i]);
    }
});


/* editor/attributes/reference/attributes-asset-reference.js */
editor.once('load', function() {
    'use strict';

    var create = function(args) {
        var tooltip = editor.call('attributes:reference', args);

        editor.method('attributes:reference:asset' + (args.name ? (':' + args.name) : '') + ':attach', function(target, element) {
            tooltip.attach({
                target: target,
                element: element || target.element
            });
        });
    };

    var fields = [
        {
            title: 'id',
            subTitle: '{Number}',
            description: 'Unique identifier of an Asset.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.asset.Asset.html'
        }, {
            title: 'name',
            subTitle: '{String}',
            description: 'The name of the asset.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.asset.Asset.html#name'
        }, {
            title: 'type',
            subTitle: '{String}',
            description: 'The type of the asset. One of: animation, audio, image, json, material, model, text, texture.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.asset.Asset.html#type'
        }, {
            name: 'size',
            description: 'Size of an asset. Keeping this value as tiny as possible will lead to faster application loading and less bandwidth required to launch the app.'
        }
    ];

    // fields reference
    for(var i = 0; i < fields.length; i++) {
        fields[i].name = fields[i].name || fields[i].title;
        create(fields[i]);
    }
});


/* editor/attributes/reference/attributes-asset-animation-reference.js */
editor.once('load', function() {
    'use strict';

    var create = function(args) {
        var tooltip = editor.call('attributes:reference', args);

        editor.method('attributes:reference:asset:animation' + (args.name ? (':' + args.name) : '') + ':attach', function(target, element) {
            tooltip.attach({
                target: target,
                element: element || target.element
            });
        });
    };

    var fields = [
        {
            name: 'asset',
            title: 'pc.Animation',
            subTitle: '{Class}',
            description: 'An animation is a sequence of keyframe arrays which map to the nodes of a skeletal hierarchy. It controls how the nodes of the hierarchy are transformed over time.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Animation.html'
        }, {
            title: 'duration',
            description: 'Duration of the animation in seconds.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Animation.html'
        }
    ];

    // fields reference
    for(var i = 0; i < fields.length; i++) {
        fields[i].name = fields[i].name || fields[i].title;
        create(fields[i]);
    }
});


/* editor/attributes/reference/attributes-asset-css-reference.js */
editor.once('load', function() {
    'use strict';

    var create = function(args) {
        var tooltip = editor.call('attributes:reference', args);

        editor.method('attributes:reference:asset:css' + (args.name ? (':' + args.name) : '') + ':attach', function(target, element) {
            tooltip.attach({
                target: target,
                element: element || target.element
            });
        });
    };

    var fields = [
        {
            name: 'asset',
            title: 'CSS',
            subTitle: '{String}',
            description: 'CSS string to be used in application.'
        }
    ];

    // fields reference
    for(var i = 0; i < fields.length; i++) {
        fields[i].name = fields[i].name || fields[i].title;
        create(fields[i]);
    }
});


/* editor/attributes/reference/attributes-asset-cubemap-reference.js */
editor.once('load', function() {
    'use strict';

    var create = function(args) {
        var tooltip = editor.call('attributes:reference', args);

        editor.method('attributes:reference:asset:cubemap' + (args.name ? (':' + args.name) : '') + ':attach', function(target, element) {
            tooltip.attach({
                target: target,
                element: element || target.element
            });
        });
    };

    var fields = [
        {
            name: 'asset',
            title: 'pc.Texture',
            subTitle: '{Class}',
            description: 'Cube maps are a special type of texture asset. They are formed from 6 texture assets where each texture represents the face of a cube. They typically have two uses:<br /><br />A cube map can define your scene\'s sky box. A sky box contains imagery of the distant visuals of your scene such as hills, mountains, the sky and so on.<br /><br />A cube map can add reflections to any material. Imagine a shiny, chrome ball bearing in your scene. The ball reflects the surrounding scene. For open environments, you would normally set the scene\'s sky box cube map as the cube map on a reflective object\'s materials.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Texture.html'
        }, {
            title: 'anisotropy',
            subTitle: '{Number}',
            description: 'Integer value specifying the level of anisotropic to apply to the texture ranging from 1 (no anisotropic filtering) to the pc.GraphicsDevice property maxAnisotropy.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Texture.html#anisotropy'
        }, {
            title: 'magFilter',
            subTitle: '{pc.FILTER_*}',
            description: 'The magnification filter to be applied to the texture.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Texture.html#magFilter'
        }, {
            title: 'mipFilter',
            subTitle: '{pc.FILTER_*}',
            description: 'The minification mipmap filter to be applied to the texture.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Texture.html#mipFilter'
        }, {
            title: 'minFilter',
            subTitle: '{pc.FILTER_*}',
            description: 'The minification filter to be applied to the texture.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Texture.html#minFilter'
        }, {
            name: 'slots',
            title: 'Texture Slots',
            description: 'The six texture assets that correspond to the faces of a cube. Helping you to connect faces together correctly. Think of the preview as a box unfolded to a flat plane.'
        }, {
            name: 'prefilter',
            title: 'Prefiltering',
            description: 'Prefilter button generates a set of low-resolution filtered textures which are used in the environment map of the Physical material. Prefiltering the cube map is essential for using the Physical material.'
        }
    ];

    // fields reference
    for(var i = 0; i < fields.length; i++) {
        fields[i].name = fields[i].name || fields[i].title;
        create(fields[i]);
    }
});


/* editor/attributes/reference/attributes-asset-html-reference.js */
editor.once('load', function() {
    'use strict';

    var create = function(args) {
        var tooltip = editor.call('attributes:reference', args);

        editor.method('attributes:reference:asset:html' + (args.name ? (':' + args.name) : '') + ':attach', function(target, element) {
            tooltip.attach({
                target: target,
                element: element || target.element
            });
        });
    };

    var fields = [
        {
            name: 'asset',
            title: 'HTML',
            subTitle: '{String}',
            description: 'HTML string to be used in application.'
        }
    ];

    // fields reference
    for(var i = 0; i < fields.length; i++) {
        fields[i].name = fields[i].name || fields[i].title;
        create(fields[i]);
    }
});


/* editor/attributes/reference/attributes-asset-json-reference.js */
editor.once('load', function() {
    'use strict';

    var create = function(args) {
        var tooltip = editor.call('attributes:reference', args);

        editor.method('attributes:reference:asset:json' + (args.name ? (':' + args.name) : '') + ':attach', function(target, element) {
            tooltip.attach({
                target: target,
                element: element || target.element
            });
        });
    };

    var fields = [
        {
            name: 'asset',
            title: 'JSON',
            subTitle: '{Object}',
            description: 'JSON data to be used in application.'
        }
    ];

    // fields reference
    for(var i = 0; i < fields.length; i++) {
        fields[i].name = fields[i].name || fields[i].title;
        create(fields[i]);
    }
});


/* editor/attributes/reference/attributes-asset-material-reference.js */
editor.once('load', function() {
    'use strict';

    var create = function(args) {
        var tooltip = editor.call('attributes:reference', args);

        editor.method('attributes:reference:asset:material' + (args.name ? (':' + args.name) : '') + ':attach', function(target, element) {
            tooltip.attach({
                target: target,
                element: element || target.element
            });
        });
    };

    var fields = [
        {
            name: 'asset',
            title: 'pc.Material',
            subTitle: '{Class}',
            description: 'Every surface on a 3D model is rendered using a material. The material defines the properties of that surface, such as its color, shininess, bumpiness.<br /><br />In PlayCanvas, a material is an Asset type which collects all these properties together. By default, it represents a Physical material. This exposes the fundamental properties that can be used to create many different types for visual effects, from smooth plastic, to rough wood, or scratched metal.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html'
        }, {
            name: 'ambientOverview',
            description: 'Ambient properties determine how the material appears in ambient light.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html'
        }, {
            title: 'ambient',
            subTitle: '{pc.Color}',
            description: 'The tint color to multiply the scene\'s global ambient color.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#ambient'
        }, {
            title: 'ambientTint',
            subTitle: '{Boolean}',
            description: 'Check this to multiply the scene\'s global ambient color with a material specific color.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#ambientTint'
        }, {
            title: 'aoMap',
            subTitle: '{pc.Texture}',
            description: 'An ambient occlusion map containing pre-baked ambient occlusion.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#aoMap'
        }, {
            title: 'aoMapChannel',
            subTitle: '{String}',
            description: 'An ambient occlusion map color channel to extract color value from texture. Can be: r, g, b, a',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#aoMapChannel'
        }, {
            title: 'aoMapUvSet',
            subTitle: '{Number}',
            description: 'Defines UV set used for AO map.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#aoMapUvSet'
        }, {
            title: 'blendType',
            subTitle: '{pc.BLEND_*}',
            description: 'The type of blending for this material. Options are:<br />None {pc.BLEND_NONE}: The mesh is opaque. This is the default.<br />Normal {pc.BLEND_NORMAL}: The mesh is transparent, like stained glass.<br />Additive {pc.BLEND_ADDITIVE}: The mesh color is added to whatever has already been rendered to the frame buffer.<br />Pre-multiply {pc.BLEND_PREMULTIPLIED}: Like \'Normal\' blending except it is assumed that the color of the mesh being rendered with this material has already been modulated by its alpha value.<br />Multiply {pc.BLEND_MULTIPLICATIVE}: When rendered, the mesh color is multiplied by whatever has already been rendered to the frame buffer.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#blendType'
        }, {
            title: 'bumpiness',
            subTitle: '{Number}',
            description: 'The strength of the applied normal map. This is a value between 0 (the normal map has no effect) and 2 (the effect of the normal map is exagerrated). It defaults to 1.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#bumpiness'
        }, {
            title: 'conserveEnergy',
            subTitle: '{Boolean}',
            description: 'Defines how diffuse and specular components are combined when Fresnel is on. It is recommended that you leave this option enabled, although you may want to disable it in case when all reflection comes only from a few light sources, and you don\'t use an environment map, therefore having mostly black reflection.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#conserveEnergy'
        }, {
            title: 'cubeMap',
            subTitle: '{pc.Texture}',
            description: 'A cube map texture asset that approximates environment reflection (with greater accuracy than is possible with a sphere map). If scene has SkyBox set, then it will be used as default cubeMap',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#cubeMap'
        }, {
            title: 'cull',
            subTitle: '{pc.CULLFACE_*}',
            description: 'Options are:<br />None {pc.CULLFACE_NONE}: Both front faces and back faces are rendered.<br />Front Faces {pc.CULLFACE_FRONT}: front faces are rendered and back faces are not.<br />Back Faces {pc.CULLFACE_BACK}: back faces are rendered and front faces are not. This is the default.<br />PlayCanvas dictates that a counter-clockwise vertex winding specifies a front face triangle. Note that backface culling is often good for performance because backface pixels are often overwritten (for convex meshes) which can result in redundant filling of pixels.'
        }, {
            title: 'depthTest',
            subTitle: '{Boolean}',
            description: 'If checked, when a mesh with the material is rendered, a per pixel check is performed to determine if the pixel passes the engine\'s depth test. By default, the test is that the pixel must have a z depth less than or equal to whatever is already in the depth buffer. In other words, the mesh is only visible if nothing is in front of it. If unchecked, the mesh is rendered regardless of what is already in the depth buffer. Defaults to on.'
        }, {
            title: 'depthWrite',
            subTitle: '{Boolean}',
            description: 'If checked, when a mesh with the material is rendered, its depth information is written to the depth buffer. This ensures that when subsequent meshes are rendered, they can be successfully depth tested against meshes rendered with this material. Defaults to on.'
        }, {
            name: 'diffuseOverview',
            description: 'Diffuse properties define the how a material reflects diffuse light emitted by dynamic light sources in the scene.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html'
        }, {
            title: 'diffuse',
            subTitle: '{pc.Color}',
            description: 'If no diffuse map is set or tint is enabled, this is the diffuse color of the material.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#diffuse'
        }, {
            title: 'diffuseMap',
            subTitle: '{pc.Texture}',
            description: 'The diffuse map that specifies the per-pixel diffuse material color. If no diffuse map is set, the diffuse color is used instead.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#diffuseMap'
        }, {
            title: 'diffuseMapChannel',
            subTitle: '{String}',
            description: 'An diffuse map color channel to extract color value from texture. Can be: r, g, b, a, rgb',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#diffuseMapChannel'
        }, {
            title: 'diffuseMapOffset',
            subTitle: '{pc.Vec2}',
            description: 'The offset in U and V to apply to the first UV channel referenced by maps in this material.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#diffuseMapOffset'
        }, {
            title: 'diffuseMapTiling',
            subTitle: '{pc.Vec2}',
            description: 'The scale in U and V to apply to the first UV channel referenced by maps in this material.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#diffuseMapTiling'
        }, {
            title: 'diffuseMapTint',
            subTitle: '{Boolean}',
            description: 'Check this to modulate the material\'s diffuse map with a material specific diffuse color.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#diffuseMapTint'
        }, {
            name: 'emissiveOverview',
            description: 'Emissive properties control how the material emits light (as opposed to reflecting light).',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html'
        }, {
            title: 'emissive',
            subTitle: '{pc.Color}',
            description: 'If no emissive map is set or tint is enabled, this is the emissive color of the material.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#emissive'
        }, {
            title: 'emissiveIntensity',
            subTitle: '{Number}',
            description: 'A multiplier for emissive color that can achieve overbright effects for exceptionally bright emissive materials.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#emissiveIntensity'
        }, {
            title: 'emissiveMap',
            subTitle: '{pc.Texture}',
            description: 'The emissive map that specifies the per-pixel emissive color. If no emissive map is set, the emissive color is used instead.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#emissiveMap'
        }, {
            title: 'emissiveMapChannel',
            subTitle: '{String}',
            description: 'An emissive map color channel to extract color value from texture. Can be: r, g, b, a, rgb',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#emissiveMapChannel'
        }, {
            title: 'emissiveMapOffset',
            subTitle: '{pc.Vec2}',
            description: 'The offset in U and V to apply to the first UV channel referenced by maps in this material.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#emissiveMapOffset'
        }, {
            title: 'emissiveMapTiling',
            subTitle: '{pc.Vec2}',
            description: 'The scale in U and V to apply to the first UV channel referenced by maps in this material.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#emissiveMapTiling'
        }, {
            title: 'emissiveMapTint',
            subTitle: '{Boolean}',
            description: 'Check this to modulate the material\'s emissive map with a material specific emissive color.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#emissiveMapTint'
        }, {
            name: 'environmentOverview',
            description: 'Environment properties determine how a material reflects and refracts the environment.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html'
        }, {
            title: 'fresnelFactor',
            subTitle: '{Number}',
            description: 'description',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#fresnelFactor'
        }, {
            title: 'fresnelModel',
            subTitle: '{pc.FRESNEL_*}',
            description: 'A parameter for Fresnel. May mean different things depending on fresnelModel.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#fresnelModel'
        }, {
            title: 'glossMap',
            subTitle: '{pc.Texture}',
            description: 'The gloss map that specifies a per-pixel shininess value. The gloss map is modulated by the shininess property.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#glossMap'
        }, {
            title: 'glossMapChannel',
            subTitle: '{String}',
            description: 'An gloss map color channel to extract color value from texture. Can be: r, g, b, a',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#glossMapChannel'
        }, {
            title: 'glossMapOffset',
            subTitle: '{pc.Vec2}',
            description: 'The offset in U and V to apply to the first UV channel referenced by maps in this material.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#glossMapOffset'
        }, {
            title: 'glossMapTiling',
            subTitle: '{pc.Vec2}',
            description: 'The scale in U and V to apply to the first UV channel referenced by maps in this material.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#glossMapTiling'
        }, {
            title: 'heightMap',
            subTitle: '{pc.Texture}',
            description: 'The height map that specifies the per-pixel strength of the parallax effect. White is full height and black is zero height.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#heightMap'
        }, {
            title: 'heightMapChannel',
            subTitle: '{String}',
            description: 'An height map color channel to extract color value from texture. Can be: r, g, b, a',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#heightMapChannel'
        }, {
            title: 'heightMapFactor',
            subTitle: '{Number}',
            description: 'The strength of a parallax effect (a value between 0 and 2, defaulting to 1).',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#heightMapFactor'
        }, {
            title: 'heightMapOffset',
            subTitle: '{pc.Vec2}',
            description: 'The offset in U and V to apply to the first UV channel referenced by maps in this material.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#heightMapOffset'
        }, {
            title: 'heightMapTiling',
            subTitle: '{pc.Vec2}',
            description: 'The scale in U and V to apply to the first UV channel referenced by maps in this material.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#heightMapTiling'
        }, {
            name: 'lightMapOverview',
            description: 'Light maps contain pre-baked diffuse lighting. Using light maps is considered an optimization in that runtime dynamic lighting calculations can be pre-calculated.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html'
        }, {
            title: 'lightMap',
            subTitle: '{pc.Texture}',
            description: 'The lightmap texture that contains pre-baked diffuse lighting. The lightmap usually is applied to the second UV set.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#lightMap'
        }, {
            title: 'lightMapChannel',
            subTitle: '{String}',
            description: 'An light map color channel to extract color value from texture. Can be: r, g, b, a, rgb',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#lightMapChannel'
        }, {
            title: 'metalness',
            subTitle: '{Number}',
            description: 'Metalness factor multiplier.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#metalness'
        }, {
            title: 'metalnessMap',
            subTitle: '{pc.Texture}',
            description: 'This map specifies per-pixel metalness values. A value of 1 is metal and a value of 0 is non-metal.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#metalnessMap'
        }, {
            title: 'metalnessMapChannel',
            subTitle: '{String}',
            description: 'An metalness map color channel to extract color value from texture. Can be: r, g, b, a',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#metalnessMapChannel'
        }, {
            name: 'normalOverview',
            description: 'Use this to specify normal maps in order to simulate \'Bumpiness\' effect.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html'
        }, {
            title: 'normalMap',
            subTitle: '{pc.Texture}',
            description: 'The normal map that specifies the per-pixel surface normals. The normal map is modulated by the \'Bumpiness\' property.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#normalMap'
        }, {
            title: 'normalMapOffset',
            subTitle: '{pc.Vec2}',
            description: 'The offset in U and V to apply to the first UV channel referenced by maps in this material.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#normalMapOffset'
        }, {
            title: 'normalMapTiling',
            subTitle: '{pc.Vec2}',
            description: 'The scale in U and V to apply to the first UV channel referenced by maps in this material.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#normalMapTiling'
        }, {
            title: 'occludeSpecular',
            subTitle: '{Boolean}',
            description: 'If checked, ambient color will occlude specular factor of a material.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#occludeSpecular'
        }, {
            name: 'other',
            description: 'Other Render States gives additional controls over how a mesh is rendered with the specified material.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html'
        }, {
            name: 'offset',
            description: 'The offset in U and V to apply to the first UV channel referenced by maps in this material.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html'
        }, {
            name: 'offsetTiling',
            description: 'The offset and tiling in U and V to apply to the UV channel referenced by all maps in this material.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html'
        }, {
            name: 'opacityOverview',
            description: 'Opacity sets the transparency level.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html'
        }, {
            title: 'opacity',
            subTitle: '{Number}',
            description: 'The opacity of the material. This is a value between 0 (completely transparent) and 1 (complately opaque. It defaults to 1.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#opacity'
        }, {
            title: 'opacityMap',
            subTitle: '{pc.Texture}',
            description: 'The opacity map that specifies the per-pixel opacity. The opacity map is modulated by the \'Amount\' property.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#opacityMap'
        }, {
            title: 'opacityMapChannel',
            subTitle: '{String}',
            description: 'An opacity map color channel to extract color value from texture. Can be: r, g, b, a',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#opacityMapChannel'
        }, {
            title: 'opacityMapOffset',
            subTitle: '{pc.Vec2}',
            description: 'The offset in U and V to apply to the first UV channel referenced by maps in this material.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#opacityMapOffset'
        }, {
            title: 'opacityMapTiling',
            subTitle: '{pc.Vec2}',
            description: 'The scale in U and V to apply to the first UV channel referenced by maps in this material.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#opacityMapTiling'
        }, {
            name: 'parallaxOverview',
            description: 'A height map gives further realism to a normal map by giving the illusion of depth to a surface. Note that parallax options are only enabled if you have set a normal map on the material.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html'
        }, {
            title: 'reflectivity',
            subTitle: '{Number}',
            description: 'A factor to determin what portion of light is reflected from the material. This value defaults to 1 (full reflectivity).',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#reflectivity'
        }, {
            title: 'refraction',
            subTitle: '{Number}',
            description: 'A factor to determine what portion of light passes through the material.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#refraction'
        }, {
            title: 'refractionIndex',
            subTitle: '{Number}',
            description: 'Determines the amount of distortion of light passing through the material.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#refractionIndex'
        }, {
            title: 'shadingModel',
            subTitle: '{pc.SPECULAR_*}',
            description: 'Defines the shading model.<br />Phong {pc.SPECULAR_PHONG}: Phong without energy conservation. You should only use it as a backwards compatibility with older projects.<br />Physical {pc.SPECULAR_BLINN}: Energy-conserving Blinn-Phong.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#shadingModel'
        }, {
            title: 'shadowSampleType',
            subTitle: '{Number}',
            description: 'Options are:<br />Hard<br />PCF 3x3',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#shadowSampleType'
        }, {
            title: 'shininess',
            subTitle: '{Number}',
            description: 'A value determining the smoothness of a surface. For smaller shininess values, a surface is rougher and specular highlights will be broader. For larger shininess values, a surface is smoother and will exhibit more concentrated specular highlights (as is the surace is polished and shiny).',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#shininess'
        }, {
            name: 'specularOverview',
            description: 'Specular properties defines the color of the specular highlights. i.e. the shininess',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html'
        }, {
            title: 'specular',
            subTitle: '{pc.Color}',
            description: 'If no specular map is set or tint is checked, this is the specular color of the material.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#specular'
        }, {
            title: 'specularAntialias',
            subTitle: '{Boolean}',
            description: 'Enables Toksvig AA for mipmapped normal maps with specular.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#specularAntialias'
        }, {
            title: 'specularMap',
            subTitle: '{pc.Texture}',
            description: 'The specular map that specifies the per-pixel specular color. If no specular map is set, the specular color is used instead.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#specularMap'
        }, {
            title: 'specularMapChannel',
            subTitle: '{String}',
            description: 'An specular map color channel to extract color value from texture. Can be: r, g, b, a, rgb',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#specularMapChannel'
        }, {
            title: 'specularMapOffset',
            subTitle: '{pc.Vec2}',
            description: 'The offset in U and V to apply to the first UV channel referenced by maps in this material.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#specularMapOffset'
        }, {
            title: 'specularMapTiling',
            subTitle: '{pc.Vec2}',
            description: 'The scale in U and V to apply to the first UV channel referenced by maps in this material.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#specularMapTiling'
        }, {
            title: 'specularMapTint',
            subTitle: '{Boolean}',
            description: 'Check this to modulate the material\'s specular map with a material specific specular color.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#specularMapTint'
        }, {
            title: 'sphereMap',
            subTitle: '{pc.Texture}',
            description: 'A sphere map texture asset that approximates environment reflection. If a sphere map is set, the Cube Map property will be hidden (since these properties are mutually exclusive).',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#sphereMap'
        }, {
            name: 'tiling',
            description: 'The scale in U and V to apply to the first UV channel referenced by maps in this material.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html'
        }, {
            title: 'useMetalness',
            subTitle: '{Boolean}',
            description: 'Toggle between specular and metalness workflow.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Material.html#useMetalness'
        }
    ];

    // fields reference
    for(var i = 0; i < fields.length; i++) {
        fields[i].name = fields[i].name || fields[i].title;
        create(fields[i]);
    }
});


/* editor/attributes/reference/attributes-asset-model-reference.js */
editor.once('load', function() {
    'use strict';

    var create = function(args) {
        var tooltip = editor.call('attributes:reference', args);

        editor.method('attributes:reference:asset:model' + (args.name ? (':' + args.name) : '') + ':attach', function(target, element) {
            tooltip.attach({
                target: target,
                element: element || target.element
            });
        });
    };

    var fields = [
        {
            title: 'meshInstances',
            subTitle: '{pc.MeshInstance[]}',
            description: 'An array of meshInstances contained in this model. Materials are defined for each individual Mesh Instance.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Model.html#meshInstances'
        }
    ];

    // fields reference
    for(var i = 0; i < fields.length; i++) {
        fields[i].name = fields[i].title;
        create(fields[i]);
    }
});


/* editor/attributes/reference/attributes-asset-script-reference.js */
editor.once('load', function() {
    'use strict';

    var create = function(args) {
        var tooltip = editor.call('attributes:reference', args);

        editor.method('attributes:reference:asset:script' + (args.name ? (':' + args.name) : '') + ':attach', function(target, element) {
            tooltip.attach({
                target: target,
                element: element || target.element
            });
        });
    };

    var fields = [
        {
            title: 'filename',
            subTitle: '{String}',
            description: 'Filename of a script..'
        }
    ];

    // fields reference
    for(var i = 0; i < fields.length; i++) {
        fields[i].name = fields[i].name || fields[i].title;
        create(fields[i]);
    }
});


/* editor/attributes/reference/attributes-asset-text-reference.js */
editor.once('load', function() {
    'use strict';

    var create = function(args) {
        var tooltip = editor.call('attributes:reference', args);

        editor.method('attributes:reference:asset:text' + (args.name ? (':' + args.name) : '') + ':attach', function(target, element) {
            tooltip.attach({
                target: target,
                element: element || target.element
            });
        });
    };

    var fields = [
        {
            name: 'asset',
            title: 'TEXT',
            subTitle: '{String}',
            description: 'String data to be used in application.'
        }
    ];

    // fields reference
    for(var i = 0; i < fields.length; i++) {
        fields[i].name = fields[i].name || fields[i].title;
        create(fields[i]);
    }
});


/* editor/attributes/reference/attributes-asset-texture-reference.js */
editor.once('load', function() {
    'use strict';

    var create = function(args) {
        var tooltip = editor.call('attributes:reference', args);

        editor.method('attributes:reference:asset:texture' + (args.name ? (':' + args.name) : '') + ':attach', function(target, element) {
            tooltip.attach({
                target: target,
                element: element || target.element
            });
        });
    };

    var fields = [
        {
            name: 'asset',
            title: 'pc.Texture',
            subTitle: '{Class}',
            description: 'Textures assets are image files which are used as part of a material to give a 3D model a realistic appearance.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Texture.html'
        }, {
            name: 'dimensions',
            title: 'width / height',
            subTitle: '{Number}',
            description: 'The width and height of the texture.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Texture.html#width'
        }, {
            title: 'magFilter',
            subTitle: '{pc.FILTER_*}',
            description: 'The magnification filter to be applied to the texture.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Texture.html#magFilter'
        }, {
            title: 'mipFilter',
            subTitle: '{pc.FILTER_*}',
            description: 'The minification mipmap filter to be applied to the texture.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Texture.html#mipFilter'
        }, {
            title: 'minFilter',
            subTitle: '{pc.FILTER_*}',
            description: 'The minification filter to be applied to the texture.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Texture.html#minFilter'
        }, {
            title: 'addressU',
            subTitle: '{pc.ADDRESS_*}',
            description: 'The addressing mode to be applied to the texture.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Texture.html#addressU'
        }, {
            title: 'addressV',
            subTitle: '{pc.ADDRESS_*}',
            description: 'The addressing mode to be applied to the texture.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Texture.html#addressV'
        }, {
            title: 'anisotropy',
            subTitle: '{Number}',
            description: 'Integer value specifying the level of anisotropic to apply to the texture ranging from 1 (no anisotropic filtering) to the pc.GraphicsDevice property maxAnisotropy.',
            url: 'http://developer.playcanvas.com/engine/api/stable/symbols/pc.Texture.html#anisotropy'
        }
    ];

    // fields reference
    for(var i = 0; i < fields.length; i++) {
        fields[i].name = fields[i].name || fields[i].title;
        create(fields[i]);
    }
});


/* editor/attributes/reference/attributes-asset-shader-reference.js */
editor.once('load', function() {
    'use strict';

    var create = function(args) {
        var tooltip = editor.call('attributes:reference', args);

        editor.method('attributes:reference:asset:shader' + (args.name ? (':' + args.name) : '') + ':attach', function(target, element) {
            tooltip.attach({
                target: target,
                element: element || target.element
            });
        });
    };

    var fields = [
        {
            name: 'asset',
            title: 'Shader',
            subTitle: '{String}',
            description: 'Text containing GLSL to be used in the application.'
        }
    ];

    // fields reference
    for(var i = 0; i < fields.length; i++) {
        fields[i].name = fields[i].name || fields[i].title;
        create(fields[i]);
    }
});


/* editor/attributes/attributes-entity.js */
editor.once('load', function() {
    'use strict';

    var panelComponents;

    editor.method('attributes:entity.panelComponents', function() {
        return panelComponents;
    });

    // add component menu
    var menuAddComponent = new ui.Menu();
    var components = editor.call('components:schema');
    var list = editor.call('components:list');
    for(var i = 0; i < list.length; i++) {
        menuAddComponent.append(new ui.MenuItem({
            text: components[list[i]].title,
            value: list[i]
        }));
    }
    menuAddComponent.on('open', function() {
        var items = editor.call('selector:items');
        for(var i = 0; i < list.length; i++) {
            var different = false;
            var disabled = items[0].has('components.' + list[i]);

            for(var n = 1; n < items.length; n++) {
                if (disabled !== items[n].has('components.' + list[i])) {
                    var different = true;
                    break;
                }
            }
            this.findByPath([ list[i] ]).disabled = different ? false : disabled;
        }
    });
    menuAddComponent.on('select', function(path) {
        var componentData = editor.call('components:getDefault', path[0]);
        var items = editor.call('selector:items');
        var records = [ ];
        var component = path[0];

        for(var i = 0; i < items.length; i++) {
            if (items[i].has('components.' + component))
                continue;

            records.push({
                get: items[i].history._getItemFn,
                value: componentData
            });

            items[i].history.enabled = false;
            items[i].set('components.' + component, componentData);
            items[i].history.enabled = true;
        }

        // if it's a collision or rigidbody component then enable physics
        if (component === 'collision' || component === 'rigidbody')
            editor.call('project:enablePhysics');

        editor.call('history:add', {
            name: 'entities.' + component,
            undo: function() {
                for(var i = 0; i < records.length; i++) {
                    var item = records[i].get();
                    if (! item)
                        continue;
                    item.history.enabled = false;
                    item.unset('components.' + component);
                    item.history.enabled = true;
                }
            },
            redo: function() {
                for(var i = 0; i < records.length; i++) {
                    var item = records[i].get();
                    if (! item)
                        continue;
                    item.history.enabled = false;
                    item.set('components.' + component, records[i].value);
                    item.history.enabled = true;
                }
            }
        });
    });
    editor.call('layout.root').append(menuAddComponent);


    editor.method('attributes:entity:addComponentPanel', function(args) {
        var title = args.title;
        var name = args.name;
        var entities = args.entities;
        var events = [ ];

        // panel
        var panel = editor.call('attributes:addPanel', {
            parent: panelComponents,
            name: title
        });
        panel.class.add('component', 'entity', name);
        // reference
        editor.call('attributes:reference:' + name + ':attach', panel, panel.headerElementTitle);

        // show/hide panel
        var checkingPanel;
        var checkPanel = function() {
            checkingPanel = false;

            var show = entities[0].has('components.' + name);
            for(var i = 1; i < entities.length; i++) {
                if (show !== entities[i].has('components.' + name)) {
                    show = false;
                    break;
                }
            }

            panel.disabled = ! show;
            panel.hidden = ! show;
        };
        var queueCheckPanel = function() {
            if (checkingPanel)
                return;

            checkingPanel = true;
            setTimeout(checkPanel);
        }
        checkPanel();
        for(var i = 0; i < entities.length; i++) {
            events.push(entities[i].on('components.' + name + ':set', queueCheckPanel));
            events.push(entities[i].on('components.' + name + ':unset', queueCheckPanel));
        }
        panel.once('destroy', function() {
            for(var i = 0; i < entities.length; i++)
                events[i].unbind();
        });

        // remove
        var fieldRemove = new ui.Button();
        fieldRemove.class.add('component-remove');
        fieldRemove.on('click', function() {
            var records = [ ];

            for(var i = 0; i < entities.length; i++) {
                records.push({
                    get: entities[i].history._getItemFn,
                    value: entities[i].get('components.' + name)
                });

                entities[i].history.enabled = false;
                entities[i].unset('components.' + name);
                entities[i].history.enabled = true;
            }

            editor.call('history:add', {
                name: 'entities.set[components.' + name + ']',
                undo: function() {
                    for(var i = 0; i < records.length; i++) {
                        var item = records[i].get();
                        if (! item)
                            continue;

                        item.history.enabled = false;
                        item.set('components.' + name, records[i].value);
                        item.history.enabled = true;
                    }
                },
                redo: function() {
                    for(var i = 0; i < records.length; i++) {
                        var item = records[i].get();
                        if (! item)
                            continue;

                        item.history.enabled = false;
                        item.unset('components.' + name);
                        item.history.enabled = true;
                    }
                }
            });
        });
        panel.headerAppend(fieldRemove);

        // enable/disable
        var fieldEnabled = editor.call('attributes:addField', {
            panel: panel,
            type: 'checkbox',
            link: entities,
            path: 'components.' + name + '.enabled'
        });
        fieldEnabled.class.remove('tick');
        fieldEnabled.class.add('component-toggle');
        fieldEnabled.element.parentNode.removeChild(fieldEnabled.element);
        panel.headerAppend(fieldEnabled);

        // toggle-label
        var labelEnabled = new ui.Label();
        labelEnabled.renderChanges = false;
        labelEnabled.class.add('component-toggle-label');
        panel.headerAppend(labelEnabled);
        labelEnabled.text = fieldEnabled.value ? 'On' : 'Off';
        fieldEnabled.on('change', function(value) {
            labelEnabled.text = value ? 'On' : 'Off';
        });

        return panel;
    });


    editor.on('attributes:inspect[entity]', function(entities) {
        if (entities.length > 1) {
            editor.call('attributes:header', entities.length + ' Entities');
        } else {
            editor.call('attributes:header', 'Entity');
        }

        // panel
        var panel = editor.call('attributes:addPanel');
        panel.class.add('component');


        // enabled
        var fieldEnabled = editor.call('attributes:addField', {
            parent: panel,
            name: 'Enabled',
            type: 'checkbox',
            link: entities,
            path: 'enabled'
        });
        // reference
        editor.call('attributes:reference:entity:enabled:attach', fieldEnabled.parent.innerElement.firstChild.ui);


        // name
        var fieldName = editor.call('attributes:addField', {
            parent: panel,
            name: 'Name',
            type: 'string',
            link: entities,
            path: 'name'
        });
        // reference
        editor.call('attributes:reference:entity:name:attach', fieldName.parent.innerElement.firstChild.ui);


        // position
        var fieldPosition = editor.call('attributes:addField', {
            parent: panel,
            name: 'Position',
            placeholder: [ 'X', 'Y', 'Z' ],
            precision: 3,
            step: .05,
            type: 'vec3',
            link: entities,
            path: 'position'
        });
        // reference
        editor.call('attributes:reference:entity:position:attach', fieldPosition[0].parent.innerElement.firstChild.ui);


        // rotation
        var fieldRotation = editor.call('attributes:addField', {
            parent: panel,
            name: 'Rotation',
            placeholder: [ 'X', 'Y', 'Z' ],
            precision: 2,
            step: .1,
            type: 'vec3',
            link: entities,
            path: 'rotation'
        });
        // reference
        editor.call('attributes:reference:entity:rotation:attach', fieldRotation[0].parent.innerElement.firstChild.ui);


        // scale
        var fieldScale = editor.call('attributes:addField', {
            parent: panel,
            name: 'Scale',
            placeholder: [ 'X', 'Y', 'Z' ],
            precision: 3,
            step: .05,
            type: 'vec3',
            link: entities,
            path: 'scale'
        });
        // reference
        editor.call('attributes:reference:entity:scale:attach', fieldScale[0].parent.innerElement.firstChild.ui);


        // components
        panelComponents = editor.call('attributes:addPanel');

        // add component
        var btnAddComponent = new ui.Button();
        btnAddComponent.text = 'Add Component';
        btnAddComponent.class.add('add-component');
        btnAddComponent.on('click', function(evt) {
            menuAddComponent.position(evt.clientX, evt.clientY);
            menuAddComponent.open = true;
        });
        panel.append(btnAddComponent);

        // if (entities.length === 1) {
        //     // json panel
        //     var panelJson = editor.call('attributes:addPanel', {
        //         name: 'JSON'
        //     });

        //     // code
        //     var fieldJson = editor.call('attributes:addField', {
        //         parent: panelJson,
        //         type: 'code'
        //     });

        //     fieldJson.text = JSON.stringify(entities[0].json(), null, 4);

        //     // changes
        //     var evtSet = entities[0].on('*:set', function() {
        //         // console.log('set', arguments)
        //         fieldJson.text = JSON.stringify(entities[0].json(), null, 4);
        //     });
        //     var evtUnset = entities[0].on('*:unset', function() {
        //         // console.log('unset', arguments)
        //         fieldJson.text = JSON.stringify(entities[0].json(), null, 4);
        //     });
        //     var evtInsert = entities[0].on('*:insert', function() {
        //         // console.log('insert', arguments)
        //         fieldJson.text = JSON.stringify(entities[0].json(), null, 4);
        //     });
        //     var evtRemove = entities[0].on('*:remove', function() {
        //         // console.log('remove', arguments)
        //         fieldJson.text = JSON.stringify(entities[0].json(), null, 4);
        //     });
        //     var evtMove = entities[0].on('*:move', function() {
        //         // console.log('move', arguments)
        //         fieldJson.text = JSON.stringify(entities[0].json(), null, 4);
        //     });

        //     fieldJson.on('destroy', function() {
        //         evtSet.unbind();
        //         evtUnset.unbind();
        //         evtInsert.unbind();
        //         evtRemove.unbind();
        //         evtMove.unbind();
        //     });
        // }
    });
});


/* editor/attributes/components/attributes-components-animation.js */
editor.once('load', function() {
    'use strict';


    editor.on('attributes:inspect[entity]', function(entities) {
        var panelComponents = editor.call('attributes:entity.panelComponents');
        if (! panelComponents)
            return;


        var panel = editor.call('attributes:entity:addComponentPanel', {
            title: 'Animation',
            name: 'animation',
            entities: entities
        });

        // animation.assets
        var fieldAssets = editor.call('attributes:addAssetsList', {
            panel: panel,
            title: 'Animation',
            type: 'animation',
            link: entities,
            path: 'components.animation.assets'
        });

        // animation.speed
        var fieldSpeed = editor.call('attributes:addField', {
            parent: panel,
            name: 'Speed',
            type: 'number',
            precision: 2,
            step: .1,
            link: entities,
            path: 'components.animation.speed'
        });
        // reference speed
        editor.call('attributes:reference:animation:speed:attach', fieldSpeed.parent.innerElement.firstChild.ui);

        // animation.playback
        var panelPlayback = new ui.Panel();
        editor.call('attributes:addField', {
            parent: panel,
            name: 'Playback',
            type: 'element',
            element: panelPlayback
        });

        // animation.activate
        var fieldActivate = editor.call('attributes:addField', {
            panel: panelPlayback,
            type: 'checkbox',
            link: entities,
            path: 'components.animation.activate'
        });
        // label
        var label = new ui.Label({ text: 'Activate' });
        label.class.add('label-infield');
        label.style.paddingRight = '12px';
        panelPlayback.append(label);
        // reference activate
        editor.call('attributes:reference:animation:activate:attach', label);

        // animation.loop
        var fieldLoop = editor.call('attributes:addField', {
            panel: panelPlayback,
            type: 'checkbox',
            link: entities,
            path: 'components.animation.loop'
        });
        // label
        var label = new ui.Label({ text: 'Loop' });
        label.class.add('label-infield');
        panelPlayback.append(label);
        // reference loop
        editor.call('attributes:reference:animation:loop:attach', label);
    });
});


/* editor/attributes/components/attributes-components-audiolistener.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[entity]', function(entities) {
        var panelComponents = editor.call('attributes:entity.panelComponents');
        if (! panelComponents)
            return;

        var panel = editor.call('attributes:entity:addComponentPanel', {
            title: 'Audio Listener',
            name: 'audiolistener',
            entities: entities
        });
    });
});


/* editor/attributes/components/attributes-components-audiosource.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[entity]', function(entities) {
        var panelComponents = editor.call('attributes:entity.panelComponents');
        if (! panelComponents)
            return;

        var panel = editor.call('attributes:entity:addComponentPanel', {
            title: 'Audio Source',
            name: 'audiosource',
            entities: entities
        });

        // audiosource.assets
        var fieldAssets = editor.call('attributes:addAssetsList', {
            title: 'Audio',
            type: 'audio',
            link: entities,
            panel: panel,
            path: 'components.audiosource.assets'
        });

        // audiosource.playback
        var panelPlayback = new ui.Panel();
        editor.call('attributes:addField', {
            parent: panel,
            name: 'Playback',
            type: 'element',
            element: panelPlayback
        });

        // audiosource.activate
        var fieldActivate = editor.call('attributes:addField', {
            panel: panelPlayback,
            type: 'checkbox',
            link: entities,
            path: 'components.audiosource.activate'
        });
        // label
        var label = new ui.Label({ text: 'Activate' });
        label.class.add('label-infield');
        panelPlayback.append(label);
        // reference
        editor.call('attributes:reference:audiosource:activate:attach', label);

        // audiosource.loop
        var fieldLoop = editor.call('attributes:addField', {
            panel: panelPlayback,
            type: 'checkbox',
            link: entities,
            path: 'components.audiosource.loop'
        });
        // label
        var label = new ui.Label({ text: 'Loop' });
        label.class.add('label-infield');
        panelPlayback.append(label);
        // reference
        editor.call('attributes:reference:audiosource:loop:attach', label);

        // audiosource.3d
        var field3d = editor.call('attributes:addField', {
            panel: panelPlayback,
            type: 'checkbox',
            link: entities,
            path: 'components.audiosource.3d'
        });
        field3d.on('change', function (value) {
            panelDistance.hidden = fieldRollOffFactor.parent.hidden = ! (field3d.value || field3d.class.contains('null'));
        });
        // label
        label = new ui.Label({ text: '3D' });
        label.class.add('label-infield');
        panelPlayback.append(label);
        // reference
        editor.call('attributes:reference:audiosource:3d:attach', label);


        // volume
        var fieldVolume = editor.call('attributes:addField', {
            parent: panel,
            name: 'Volume',
            type: 'number',
            precision: 2,
            step: 0.01,
            min: 0,
            max: 1,
            link: entities,
            path: 'components.audiosource.volume'
        });
        fieldVolume.style.width = '32px';
        // reference
        editor.call('attributes:reference:audiosource:volume:attach', fieldVolume.parent.innerElement.firstChild.ui);

        // metalness slider
        var fieldVolumeSlider = editor.call('attributes:addField', {
            panel: fieldVolume.parent,
            precision: 2,
            step: 0.01,
            min: 0,
            max: 1,
            type: 'number',
            slider: true,
            link: entities,
            path: 'components.audiosource.volume'
        });
        fieldVolumeSlider.flexGrow = 4;

        // pitch
        var fieldPitch = editor.call('attributes:addField', {
            parent: panel,
            name: 'Pitch',
            type: 'number',
            precision: 2,
            step: 0.1,
            min: 0,
            link: entities,
            path: 'components.audiosource.pitch'
        });
        // reference
        editor.call('attributes:reference:audiosource:pitch:attach', fieldPitch.parent.innerElement.firstChild.ui);


        // distance
        var panelDistance = editor.call('attributes:addField', {
            parent: panel,
            name: 'Distance'
        });
        var label = panelDistance;
        panelDistance = panelDistance.parent;
        label.destroy();
        panelDistance.hidden = ! (field3d.value || field3d.class.contains('null'));

        // reference
        editor.call('attributes:reference:audiosource:distance:attach', panelDistance.innerElement.firstChild.ui);

        // minDistance
        var fieldMinDistance = editor.call('attributes:addField', {
            panel: panelDistance,
            placeholder: 'Min',
            type: 'number',
            precision: 2,
            step: 1,
            min: 0,
            link: entities,
            path: 'components.audiosource.minDistance'
        });
        fieldMinDistance.style.width = '32px';
        fieldMinDistance.flexGrow = 1;

        // maxDistance
        var fieldMaxDistance = editor.call('attributes:addField', {
            panel: panelDistance,
            placeholder: 'Max',
            type: 'number',
            precision: 2,
            step: 1,
            min: 0,
            link: entities,
            path: 'components.audiosource.maxDistance'
        });
        fieldMaxDistance.style.width = '32px';
        fieldMaxDistance.flexGrow = 1;

        // audiosource.rollOffFactor
        var fieldRollOffFactor = editor.call('attributes:addField', {
            parent: panel,
            name: 'Roll-off factor',
            type: 'number',
            precision: 2,
            step: 0.1,
            min: 0,
            link: entities,
            path: 'components.audiosource.rollOffFactor'
        });
        fieldRollOffFactor.parent.hidden = ! (field3d.value || field3d.class.contains('null'));
        // reference
        editor.call('attributes:reference:audiosource:rollOffFactor:attach', fieldRollOffFactor.parent.innerElement.firstChild.ui);
    });
});


/* editor/attributes/components/attributes-components-camera.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[entity]', function(entities) {
        var panelComponents = editor.call('attributes:entity.panelComponents');
        if (! panelComponents)
            return;

        var panel = editor.call('attributes:entity:addComponentPanel', {
            title: 'Camera',
            name: 'camera',
            entities: entities
        });


        // clearColorBuffer
        var fieldClearColorBuffer = editor.call('attributes:addField', {
            parent: panel,
            type: 'checkbox',
            name: 'Clear Buffers',
            link: entities,
            path: 'components.camera.clearColorBuffer'
        });
        // label
        var label = new ui.Label({ text: 'Color' });
        label.class.add('label-infield');
        label.style.paddingRight = '12px';
        fieldClearColorBuffer.parent.append(label);
        // reference
        editor.call('attributes:reference:camera:clearColorBuffer:attach', label);


        // clearDepthBuffer
        var fieldCastShadows = editor.call('attributes:addField', {
            panel: fieldClearColorBuffer.parent,
            type: 'checkbox',
            link: entities,
            path: 'components.camera.clearDepthBuffer'
        });
        // label
        var label = new ui.Label({ text: 'Depth' });
        label.class.add('label-infield');
        fieldClearColorBuffer.parent.append(label);
        // reference
        editor.call('attributes:reference:camera:clearDepthBuffer:attach', label);


        // camera.clearColor
        var fieldClearColor = editor.call('attributes:addField', {
            parent: panel,
            name: 'Clear Color',
            type: 'rgb',
            link: entities,
            path: 'components.camera.clearColor'
        });
        fieldClearColor.parent.hidden = ! (fieldClearColorBuffer.value || fieldClearColorBuffer.class.contains('null'));
        fieldClearColorBuffer.on('change', function(value) {
            fieldClearColor.parent.hidden = ! (value || this.class.contains('null'));
        });
        // reference
        editor.call('attributes:reference:camera:clearColor:attach', fieldClearColor.parent.innerElement.firstChild.ui);


        // camera.projection
        var fieldProjection = editor.call('attributes:addField', {
            parent: panel,
            name: 'Projection',
            type: 'number',
            enum: [
                { v: '', t: '...' },
                { v: 0, t: 'Perspective' }, // pc.PROJECTION_PERSPECTIVE
                { v: 1, t: 'Orthographic' } // pc.PROJECTION_ORTHOGRAPHIC
            ],
            link: entities,
            path: 'components.camera.projection'
        });
        // reference
        editor.call('attributes:reference:camera:projection:attach', fieldProjection.parent.innerElement.firstChild.ui);

        // frustumCulling
        var fieldFrustumCulling = editor.call('attributes:addField', {
            parent: panel,
            type: 'checkbox',
            name: 'Frustum Culling',
            link: entities,
            path: 'components.camera.frustumCulling'
        });
        // reference
        editor.call('attributes:reference:camera:frustumCulling:attach', fieldFrustumCulling.parent.innerElement.firstChild.ui);

        // camera.fov
        var fieldFov = editor.call('attributes:addField', {
            parent: panel,
            name: 'Field of View',
            placeholder: '\u00B0',
            type: 'number',
            precision: 2,
            step: 1,
            min: 0,
            max: 90,
            link: entities,
            path: 'components.camera.fov'
        });
        fieldFov.style.width = '32px';
        fieldFov.parent.hidden = fieldProjection.value !== 0 && fieldProjection.value !== '';
        fieldProjection.on('change', function(value) {
            fieldFov.parent.hidden = value !== 0 && value !== '';
        });
        // reference
        editor.call('attributes:reference:camera:fov:attach', fieldFov.parent.innerElement.firstChild.ui);

        // fov slider
        var fieldFovSlider = editor.call('attributes:addField', {
            panel: fieldFov.parent,
            precision: 2,
            step: 1,
            min: 0,
            max: 90,
            type: 'number',
            slider: true,
            link: entities,
            path: 'components.camera.fov'
        });
        fieldFovSlider.flexGrow = 4;

        // camera.orthoHeight
        var fieldOrthoHeight = editor.call('attributes:addField', {
            parent: panel,
            name: 'Ortho Height',
            type: 'number',
            link: entities,
            path: 'components.camera.orthoHeight'
        });
        fieldOrthoHeight.parent.hidden = fieldProjection.value !== 1 && fieldProjection.value !== '';
        fieldProjection.on('change', function(value) {
            fieldOrthoHeight.parent.hidden = value !== 1 && value !== '';
        });
        // reference
        editor.call('attributes:reference:camera:orthoHeight:attach', fieldOrthoHeight.parent.innerElement.firstChild.ui);


        // nearClip
        var fieldNearClip = editor.call('attributes:addField', {
            parent: panel,
            name: 'Clip',
            placeholder: 'Near',
            type: 'number',
            precision: 2,
            step: .1,
            min: 0,
            link: entities,
            path: 'components.camera.nearClip'
        });
        fieldNearClip.style.width = '32px';
        // reference
        editor.call('attributes:reference:camera:clip:attach', fieldNearClip.parent.innerElement.firstChild.ui);


        // farClip
        var fieldFarClip = editor.call('attributes:addField', {
            panel: fieldNearClip.parent,
            placeholder: 'Far',
            type: 'number',
            precision: 2,
            step: .1,
            min: 0,
            link: entities,
            path: 'components.camera.farClip'
        });
        fieldFarClip.style.width = '32px';


        // camera.priority
        var fieldPriority = editor.call('attributes:addField', {
            parent: panel,
            name: 'Priority',
            type: 'number',
            precision: 1,
            step: 1,
            min: 0,
            link: entities,
            path: 'components.camera.priority'
        });
        // reference
        editor.call('attributes:reference:camera:priority:attach', fieldPriority.parent.innerElement.firstChild.ui);


        // camera.rect
        var fieldRect = editor.call('attributes:addField', {
            parent: panel,
            name: 'Viewport',
            placeholder: [ 'X', 'Y', 'W', 'H' ],
            type: 'vec4',
            precision: 3,
            step: 0.01,
            min: 0,
            max: 1,
            link: entities,
            path: 'components.camera.rect'
        });
        // reference
        editor.call('attributes:reference:camera:rect:attach', fieldRect[0].parent.innerElement.firstChild.ui);
    });
});


/* editor/attributes/components/attributes-components-collision.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[entity]', function(entities) {
        var panelComponents = editor.call('attributes:entity.panelComponents');
        if (! panelComponents)
            return;

        var events = [ ];

        var panel = editor.call('attributes:entity:addComponentPanel', {
            title: 'Collision',
            name: 'collision',
            entities: entities
        });


        // type
        var fieldType = editor.call('attributes:addField', {
            parent: panel,
            name: 'Type',
            type: 'string',
            enum: {
                '': '...',
                'box': 'Box',
                'sphere': 'Sphere',
                'capsule': 'Capsule',
                'cylinder': 'Cylinder',
                'mesh': 'Mesh'
            },
            link: entities,
            path: 'components.collision.type'
        });
        // reference
        editor.call('attributes:reference:collision:type:attach', fieldType.parent.innerElement.firstChild.ui);


        // halfExtents
        var fieldHalfExtents = editor.call('attributes:addField', {
            parent: panel,
            name: 'Half Extents',
            placeholder: [ 'X', 'Y', 'Z' ],
            precision: 2,
            step: 0.1,
            min: 0,
            type: 'vec3',
            link: entities,
            path: 'components.collision.halfExtents'
        });
        fieldHalfExtents[0].parent.hidden = fieldType.value !== 'box' && fieldType.value !== '';
        fieldType.on('change', function(value) {
            fieldHalfExtents[0].parent.hidden = value !== 'box' && value !== '';
        });
        // reference
        editor.call('attributes:reference:collision:halfExtents:attach', fieldHalfExtents[0].parent.innerElement.firstChild.ui);


        // radius
        var fieldRadius = editor.call('attributes:addField', {
            parent: panel,
            name: 'Radius',
            type: 'number',
            precision: 2,
            step: 0.1,
            min: 0,
            link: entities,
            path: 'components.collision.radius'
        });
        fieldRadius.parent.hidden = fieldType.value !== '' && [ 'sphere', 'capsule', 'cylinder' ].indexOf(fieldType.value) === -1;
        fieldType.on('change', function(value) {
            fieldRadius.parent.hidden = value !== '' && [ 'sphere', 'capsule', 'cylinder' ].indexOf(value) === -1;
        });
        // reference
        editor.call('attributes:reference:collision:radius:attach', fieldRadius.parent.innerElement.firstChild.ui);


        // height
        var fieldHeight = editor.call('attributes:addField', {
            parent: panel,
            name: 'Height',
            type: 'number',
            precision: 2,
            step: 0.1,
            min: 0,
            link: entities,
            path: 'components.collision.height'
        });
        // show/hide
        fieldHeight.parent.hidden = fieldType.value !== '' && [ 'capsule', 'cylinder' ].indexOf(fieldType.value) === -1;
        fieldType.on('change', function(value) {
            fieldHeight.parent.hidden = value !== '' && [ 'capsule', 'cylinder' ].indexOf(value) === -1;
        });
        // reference
        editor.call('attributes:reference:collision:height:attach', fieldHeight.parent.innerElement.firstChild.ui);


        // axis
        var fieldAxis = editor.call('attributes:addField', {
            parent: panel,
            name: 'Axis',
            type: 'number',
            enum: [
                { v: '', t: '...' },
                { v: 0, t: 'X' },
                { v: 1, t: 'Y' },
                { v: 2, t: 'Z' }
            ],
            link: entities,
            path: 'components.collision.axis'
        });
        fieldAxis.parent.hidden = fieldType.value !== '' && [ 'capsule', 'cylinder' ].indexOf(fieldType.value) === -1;
        fieldType.on('change', function(value) {
            fieldAxis.parent.hidden = value !== '' && [ 'capsule', 'cylinder' ].indexOf(value) === -1;
        });
        // reference
        editor.call('attributes:reference:collision:axis:attach', fieldAxis.parent.innerElement.firstChild.ui);


        // asset
        var fieldAsset = editor.call('attributes:addField', {
            parent: panel,
            name: 'Asset',
            type: 'asset',
            kind: 'model',
            link: entities,
            path: 'components.collision.asset'
        });
        fieldAsset.parent.hidden = fieldType.value !== '' && fieldType.value !== 'mesh';
        fieldType.on('change', function(value) {
            fieldAsset.parent.hidden = value !== '' && value !== 'mesh';
        });
        // reference
        editor.call('attributes:reference:collision:asset:attach', fieldAsset.parent.innerElement.firstChild.ui);
    });
});


/* editor/attributes/components/attributes-components-light.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[entity]', function(entities) {
        // if (entities.length !== 1)
        //     return;

        // var entity = entities[0];

        var panelComponents = editor.call('attributes:entity.panelComponents');
        if (! panelComponents)
            return;

        var events = [ ];

        var panel = editor.call('attributes:entity:addComponentPanel', {
            title: 'Light',
            name: 'light',
            entities: entities
        });


        // type
        var fieldType = editor.call('attributes:addField', {
            parent: panel,
            name: 'Type',
            type: 'string',
            enum: {
                '': '...',
                'directional': 'Directional',
                'spot': 'Spot',
                'point': 'Point'
            },
            link: entities,
            path: 'components.light.type'
        });
        // reference
        editor.call('attributes:reference:light:type:attach', fieldType.parent.innerElement.firstChild.ui);


        // color
        var fieldColor = editor.call('attributes:addField', {
            parent: panel,
            name: 'Color',
            type: 'rgb',
            link: entities,
            path: 'components.light.color'
        });
        // reference
        editor.call('attributes:reference:light:color:attach', fieldColor.parent.innerElement.firstChild.ui);


        // intensity
        var fieldIntensity = editor.call('attributes:addField', {
            parent: panel,
            name: 'Intensity',
            type: 'number',
            precision: 2,
            step: .1,
            min: 0,
            max: 32,
            link: entities,
            path: 'components.light.intensity'
        });
        fieldIntensity.style.width = '32px';
        // reference
        editor.call('attributes:reference:light:intensity:attach', fieldIntensity.parent.innerElement.firstChild.ui);

        // intensity slider
        var fieldIntensitySlider = editor.call('attributes:addField', {
            panel: fieldIntensity.parent,
            precision: 2,
            step: .1,
            min: 0,
            max: 32,
            type: 'number',
            slider: true,
            link: entities,
            path: 'components.light.intensity'
        });
        fieldIntensitySlider.flexGrow = 4;


        // range
        var fieldRange = editor.call('attributes:addField', {
            parent: panel,
            name: 'Range',
            type: 'number',
            precision: 2,
            step: .1,
            min: 0,
            link: entities,
            path: 'components.light.range'
        });
        fieldRange.parent.hidden = ! (fieldType.value === '' || fieldType.value !== 'directional');
        fieldType.on('change', function(value) {
            fieldRange.parent.hidden = ! (value === '' || value !== 'directional');
        });
        // reference
        editor.call('attributes:reference:light:range:attach', fieldRange.parent.innerElement.firstChild.ui);


        // falloffMode
        var fieldFalloffMode = editor.call('attributes:addField', {
            parent: panel,
            name: 'Falloff Mode',
            type: 'number',
            enum: {
                0: 'Linear',
                1: 'Inverse Squared'
            },
            link: entities,
            path: 'components.light.falloffMode'
        });
        fieldFalloffMode.parent.hidden = ! (fieldType.value === '' || fieldType.value !== 'directional');
        fieldType.on('change', function(value) {
            fieldFalloffMode.parent.hidden = ! (value === '' || value !== 'directional');
        });
        // reference
        editor.call('attributes:reference:light:falloffMode:attach', fieldFalloffMode.parent.innerElement.firstChild.ui);


        // innerConeAngle
        var fieldInnerConeAngle = editor.call('attributes:addField', {
            parent: panel,
            name: 'Cone Angles',
            placeholder: 'Inner',
            type: 'number',
            precision: 2,
            step: 1,
            min: 0,
            max: 90,
            link: entities,
            path: 'components.light.innerConeAngle'
        });
        fieldInnerConeAngle.style.width = '32px';
        fieldInnerConeAngle.parent.hidden = ! (fieldType.value === '' || fieldType.value === 'spot');
        fieldType.on('change', function(value) {
            fieldInnerConeAngle.parent.hidden = ! (value === '' || value === 'spot');
        });
        // reference
        editor.call('attributes:reference:light:coneAngles:attach', fieldInnerConeAngle.parent.innerElement.firstChild.ui);


        // outerConeAngle
        var fieldOuterConeAngle = editor.call('attributes:addField', {
            panel: fieldInnerConeAngle.parent,
            placeholder: 'Outer',
            type: 'number',
            precision: 2,
            step: 1,
            min: 0,
            max: 90,
            link: entities,
            path: 'components.light.outerConeAngle'
        });
        fieldOuterConeAngle.style.width = '32px';



        // castShadows
        var fieldCastShadows = editor.call('attributes:addField', {
            parent: panel,
            name: 'Cast Shadows',
            type: 'checkbox',
            link: entities,
            path: 'components.light.castShadows'
        });
        // reference
        editor.call('attributes:reference:light:castShadows:attach', fieldCastShadows.parent.innerElement.firstChild.ui);


        // shadows panel
        var panelShadows = editor.call('attributes:addPanel', {
            parent: panel
        });
        panelShadows.hidden = ! fieldCastShadows.value && ! fieldCastShadows.class.contains('null');
        fieldCastShadows.on('change', function(value) {
            panelShadows.hidden = ! value && ! this.class.contains('null');
        });


        // shadowDistance
        var fieldShadowDistance = editor.call('attributes:addField', {
            parent: panelShadows,
            name: 'Shadow Distance',
            type: 'number',
            precision: 2,
            step: 1,
            min: 0,
            link: entities,
            path: 'components.light.shadowDistance'
        });
        fieldShadowDistance.parent.hidden = ! (fieldType.value === '' || fieldType.value === 'directional');
        fieldType.on('change', function(value) {
            fieldShadowDistance.parent.hidden = ! (value === '' || value === 'directional');
        });
        // reference
        editor.call('attributes:reference:light:shadowDistance:attach', fieldShadowDistance.parent.innerElement.firstChild.ui);


        // shadowResolution
        var fieldShadowResolution = editor.call('attributes:addField', {
            parent: panelShadows,
            name: 'Shadow Resolution',
            type: 'number',
            enum: [
                { v: '', t: '...' },
                { v: 128, t: '128 x 128' },
                { v: 256, t: '256 x 256' },
                { v: 512, t: '512 x 512' },
                { v: 1024, t: '1024 x 1024' },
                { v: 2048, t: '2048 x 2048' }
            ],
            link: entities,
            path: 'components.light.shadowResolution'
        });
        // reference
        editor.call('attributes:reference:light:shadowResolution:attach', fieldShadowResolution.parent.innerElement.firstChild.ui);


        // shadowBias
        var fieldShadowBias = editor.call('attributes:addField', {
            parent: panelShadows,
            name: 'Shadow Bias',
            type: 'number',
            precision: 3,
            step: .001,
            min: 0,
            max: 1,
            link: entities,
            path: 'components.light.shadowBias'
        });
        fieldShadowBias.style.width = '32px';
        // reference
        editor.call('attributes:reference:light:shadowBias:attach', fieldShadowBias.parent.innerElement.firstChild.ui);


        // normalOffsetBias
        var fieldShadowBiasNormalOffset = editor.call('attributes:addField', {
            panel: fieldShadowBias.parent,
            type: 'number',
            placeholder: 'Normal Offset',
            precision: 3,
            step: .001,
            min: 0,
            max: 1,
            link: entities,
            path: 'components.light.normalOffsetBias'
        });
        fieldShadowBiasNormalOffset.style.width = '32px';
        fieldShadowBiasNormalOffset.flexGrow = 2;
    });
});


/* editor/attributes/components/attributes-components-model.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[entity]', function(entities) {
        var panelComponents = editor.call('attributes:entity.panelComponents');
        if (! panelComponents)
            return;

        var events = [ ];

        var panel = editor.call('attributes:entity:addComponentPanel', {
            title: 'Model',
            name: 'model',
            entities: entities
        });


        // type
        var fieldType = editor.call('attributes:addField', {
            parent: panel,
            name: 'Type',
            type: 'string',
            enum: {
                '': '...',
                'asset': 'Asset',
                'box': 'Box',
                'capsule': 'Capsule',
                'sphere': 'Sphere',
                'cylinder': 'Cylinder',
                'cone': 'Cone',
                'plane': 'Plane'
            },
            link: entities,
            path: 'components.model.type'
        });
        fieldType.on('change', function(value) {
            fieldAsset.parent.hidden = value !== 'asset';
            fieldMaterial.parent.hidden = value === 'asset' || value === '';
            toggleMaterials();
        });
        // reference
        editor.call('attributes:reference:model:type:attach', fieldType.parent.innerElement.firstChild.ui);


        // asset
        var fieldAsset = editor.call('attributes:addField', {
            parent: panel,
            name: 'Model',
            type: 'asset',
            kind: 'model',
            link: entities,
            path: 'components.model.asset'
        });
        fieldAsset.parent.hidden = fieldType.value !== 'asset';
        // reference
        editor.call('attributes:reference:model:asset:attach', fieldAsset._label);


        // material
        var fieldMaterial = editor.call('attributes:addField', {
            parent: panel,
            name: 'Material',
            type: 'asset',
            kind: 'material',
            link: entities,
            path: 'components.model.materialAsset'
        });
        fieldMaterial.class.add('material-asset');
        fieldMaterial.parent.hidden = fieldType.value === 'asset' || fieldType.value === '';
        // reference
        editor.call('attributes:reference:model:materialAsset:attach', fieldMaterial._label);


        // castShadows
        var fieldCastShadows = editor.call('attributes:addField', {
            parent: panel,
            type: 'checkbox',
            name: 'Shadows',
            link: entities,
            path: 'components.model.castShadows'
        });
        // label
        var label = new ui.Label({ text: 'Cast' });
        label.class.add('label-infield');
        label.style.paddingRight = '12px';
        fieldCastShadows.parent.append(label);
        // reference
        editor.call('attributes:reference:model:castShadows:attach', label);


        // receiveShadows
        var fieldReceiveShadows = editor.call('attributes:addField', {
            panel: fieldCastShadows.parent,
            type: 'checkbox',
            link: entities,
            path: 'components.model.receiveShadows'
        });
        // label
        var label = new ui.Label({ text: 'Receive' });
        label.class.add('label-infield');
        fieldCastShadows.parent.append(label);
        // reference
        editor.call('attributes:reference:model:receiveShadows:attach', label);

        panel.on('destroy', function() {
            for(var i = 0; i < events.length; i++)
                events[i].unbind();
        });


        // gather all mappings for all selected entities
        var allMappings = {};
        for (var i = 0, len = entities.length; i < len; i++) {
            var mapping = entities[i].get('components.model.mapping');
            if (mapping) {
                for (var key in mapping) {
                    if (!allMappings[key])
                        allMappings[key] = [entities[i].get('resource_id')];
                    else
                        allMappings[key].push(entities[i].get('resource_id'));
                }
            }
        }

        var panelMaterialButtons = editor.call('attributes:addPanel');
        panelMaterialButtons.class.add('flex', 'component', 'override-material');
        panel.append(panelMaterialButtons);

        var panelMaterials = editor.call('attributes:addPanel');
        panelMaterials.class.add('component', 'override-material');
        panel.append(panelMaterials);

        // check if we should show the override button
        // mainly if all entities have a model component
        // and are referencing an asset
        var toggleMaterials = function ()  {
            var referencedModelAsset = entities[0].get('components.model.asset');
            for (var i = 0, len = entities.length; i < len; i++) {
                if (entities[i].get('components.model.type') !== 'asset' ||
                    entities[i].get('components.model.asset') !== referencedModelAsset) {
                    panelMaterials.hidden = true;
                    panelMaterialButtons.hidden = true;
                    return;
                }
            }

            panelMaterials.hidden = false;
            panelMaterialButtons.hidden = false;
        };

        // turn override panel off / on
        toggleMaterials();

        var assetMaterials = new ui.Button({
            text: 'Asset Materials'
        });

        assetMaterials.class.add('override-material');
        panelMaterialButtons.append(assetMaterials);
        assetMaterials.on('click', function () {
            var modelAsset = editor.call('assets:get', entities[0].get('components.model.asset'));
            editor.call('selector:set', 'asset', [modelAsset]);
        });

        // add button to add material override
        var entityMaterials = new ui.Button({
            text: 'Entity Materials'
        });
        entityMaterials.class.add('override-material');
        panelMaterialButtons.append(entityMaterials);

        entityMaterials.on('click', function () {
            editor.call('picker:node', entities);
        });

        var framework = editor.call('viewport:framework');

        // get one of the Entities to use for finding the mesh instances names
        var engineEntity = framework.root.findByGuid(entities[0].get('resource_id'));

        var removeOverride = function (index) {
            var resourceIds = [];
            var previous = [];

            entities.forEach(function (entity) {
                resourceIds.push(entity.get('resource_id'));
                var history = entity.history.enabled;
                entity.history.enabled = false;
                previous.push(entity.has('components.model.mapping.' + index) ? entity.get('components.model.mapping.' + index) : undefined);
                entity.unset('components.model.mapping.' + index);
                entity.history.enabled = history;
            });

            editor.call('history:add', {
                name: 'entities.' + (resourceIds.length > 1 ? '*' : resourceIds[0]) + '.components.model.mapping',
                undo: function() {
                    for(var i = 0; i < resourceIds.length; i++) {
                        var item = editor.call('entities:get', resourceIds[i]);
                        if (! item)
                            continue;

                        var history = item.history.enabled;
                        item.history.enabled = false;
                        if (previous[i] === undefined)
                            item.unset('components.model.mapping.' + index);
                        else
                            item.set('components.model.mapping.' + index, previous[i]);

                        item.history.enabled = history;
                    }
                },
                redo: function() {
                    for(var i = 0; i < resourceIds.length; i++) {
                        var item = editor.call('entities:get', resourceIds[i]);
                        if (! item)
                            continue;

                        var history = item.history.enabled;
                        item.history.enabled = false;
                        item.unset('components.model.mapping.' + index);
                        item.history.enabled = history;
                    }
                }
            });
        };

        var addOverride = function (index) {
            var valuesBefore;

            var meshInstances = engineEntity.model.model.meshInstances;

            var field = editor.call('attributes:addField', {
                parent: panelMaterials,
                type: 'asset',
                kind: 'material',
                name: meshInstances[index] ? meshInstances[index].node.name : 'node ' + index,
                link: entities,
                path: 'components.model.mapping.' + index,
                over: function(type, data) {
                    valuesBefore = entities.map(function (entity) {
                        var path = 'components.model.mapping.' + index;
                        return entity.has(path) ? entity.get(path) : undefined;
                    });

                    entities.forEach(function (entity) {
                        var engineEntity = framework.root.findByGuid(entity.get('resource_id'));
                        if (engineEntity) {
                            var mapping = engineEntity.model.mapping;
                            if (engineEntity.model.mapping && engineEntity.model.mapping[index] !== undefined) {
                                mapping[index] = parseInt(data.id, 10);
                                engineEntity.model.mapping = mapping;
                            }
                        }
                    });

                    editor.call('viewport:render');
                },
                leave: function() {
                    if (!valuesBefore) return;

                    entities.forEach(function (entity, i) {
                        var engineEntity = framework.root.findByGuid(entity.get('resource_id'));
                        if (engineEntity) {
                            var mapping = engineEntity.model.mapping;
                            if (! mapping) return;

                            if (valuesBefore[i] === undefined)
                                delete mapping[index];
                            else
                                mapping[index] = valuesBefore[i] === null ? null : parseInt(valuesBefore[i], 10);

                            engineEntity.model.mapping = mapping;
                        }
                    });

                    editor.call('viewport:render');
                }
            });

            field.parent.class.add('node-' + index);

            field.parent.on('click', function () {
                field.parent.class.remove('active');
            });

            // button to remove mapping entry
            var removeButton = new ui.Button({
                text: '&#57636;'
            });
            removeButton.style.fontWeight = 200;
            removeButton.class.add('remove');
            field.parent.append(removeButton);

            removeButton.on('click', function () {
                removeOverride(index);
            });
        };

        // add field for each mapping
        for (var key in allMappings) {
            addOverride(key);
        }

        // subscribe to mapping change events
        entities.forEach(function (entity) {
            events.push(entity.on('*:set', function (path) {
                if (! /^components.model.mapping/.test(path)) return;

                var value = entity.get('components.model.mapping');

                if (! value) value = {};

                var resourceId = entity.get('resource_id');

                // remove deleted overrides
                for (var key in allMappings) {
                    if (value[key] === undefined) {
                        var ind = allMappings[key].indexOf(resourceId);
                        if (ind !== -1) {
                            allMappings[key].splice(ind, 1);
                            if (allMappings[key].length === 0) {
                                var field = panelMaterials.element.querySelector('.field-asset.node-' + key);
                                if (field)
                                    field.parentElement.removeChild(field);

                                delete allMappings[key];
                            }
                        }
                    }
                }


                // add new
                for (var key in value) {
                    if (!allMappings[key]) {
                        allMappings[key] = [resourceId];
                        addOverride(key);
                    }
                    else {
                        if (allMappings[key].indexOf(resourceId) === -1)
                            allMappings[key].push(resourceId);
                    }
                }

            }));

            events.push(entity.on('*:unset', function (path, value) {
                if (! /^components.model.mapping/.test(path)) return;

                var parts = path.split('.');
                var index = parts[parts.length-1];
                if (!allMappings[index]) return;

                var resourceId = entity.get('resource_id');

                var ind = allMappings[index].indexOf(resourceId);
                if (ind === -1) return;

                allMappings[index].splice(ind, 1);
                if (allMappings[index].length) return;

                delete allMappings[index];

                var field = panelMaterials.element.querySelector('.field-asset.node-' + index);
                if (field)
                    field.parentElement.removeChild(field);

            }));
        });
    });
});


/* editor/attributes/components/attributes-components-particlesystem.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[entity]', function(entities) {
        var panelComponents = editor.call('attributes:entity.panelComponents');
        if (! panelComponents)
            return;


        // particlesystem
        var panel = editor.call('attributes:entity:addComponentPanel', {
            title: 'Particles',
            name: 'particlesystem',
            entities: entities
        });


        // autoPlay
        var fieldAutoPlay = editor.call('attributes:addField', {
            parent: panel,
            name: 'Auto Play',
            type: 'checkbox',
            link: entities,
            path: 'components.particlesystem.autoPlay'
        });
        // reference
        editor.call('attributes:reference:particlesystem:autoPlay:attach', fieldAutoPlay.parent.innerElement.firstChild.ui);


        // numParticles
        var fieldNumParticles = editor.call('attributes:addField', {
            parent: panel,
            name: 'Particle Count',
            type: 'number',
            link: entities,
            path: 'components.particlesystem.numParticles'
        });
        // reference
        editor.call('attributes:reference:particlesystem:numParticles:attach', fieldNumParticles.parent.innerElement.firstChild.ui);


        // lifetime
        var fieldLifetime = editor.call('attributes:addField', {
            parent: panel,
            name: 'Lifetime',
            placeholder: 'Seconds',
            type: 'number',
            link: entities,
            path: 'components.particlesystem.lifetime'
        });
        // reference
        editor.call('attributes:reference:particlesystem:lifetime:attach', fieldLifetime.parent.innerElement.firstChild.ui);


        // emission rate
        var panelEmissionRate = editor.call('attributes:addField', {
            parent: panel,
            name: 'Emission Rate'
        });
        var label = panelEmissionRate;
        panelEmissionRate = panelEmissionRate.parent;
        label.destroy();
        // reference
        editor.call('attributes:reference:particlesystem:rate:attach', panelEmissionRate.innerElement.firstChild.ui);

        // emission rate from
        var fieldEmissionRateFrom = editor.call('attributes:addField', {
            panel: panelEmissionRate,
            placeholder: 'From',
            type: 'number',
            link: entities,
            path: 'components.particlesystem.rate'
        });
        fieldEmissionRateFrom.style.width = '32px';

        // emission rate to
        var fieldEmissionRateTo = editor.call('attributes:addField', {
            panel: panelEmissionRate,
            placeholder: 'To',
            type: 'number',
            link: entities,
            path: 'components.particlesystem.rate2'
        });
        fieldEmissionRateTo.style.width = '32px';


        // start angle
        var panelStartAngle = editor.call('attributes:addField', {
            parent: panel,
            name: 'Start Angle'
        });
        var label = panelStartAngle;
        panelStartAngle = panelStartAngle.parent;
        label.destroy();
        // reference
        editor.call('attributes:reference:particlesystem:startAngle:attach', panelStartAngle.innerElement.firstChild.ui);

        // start angle from
        var fieldStartAngleFrom = editor.call('attributes:addField', {
            panel: panelStartAngle,
            placeholder: 'From',
            type: 'number',
            link: entities,
            path: 'components.particlesystem.startAngle'
        });
        fieldStartAngleFrom.style.width = '32px';

        // start angle to
        var fieldStartAngleTo = editor.call('attributes:addField', {
            panel: panelStartAngle,
            placeholder: 'To',
            type: 'number',
            link: entities,
            path: 'components.particlesystem.startAngle2'
        });
        fieldStartAngleTo.style.width = '32px';


        // playback
        var panelPlayback = editor.call('attributes:addField', {
            parent: panel,
            name: 'Playback'
        });
        var label = panelPlayback;
        panelPlayback = panelPlayback.parent;
        label.destroy();

        // loop
        var fieldLoop = editor.call('attributes:addField', {
            panel: panelPlayback,
            type: 'checkbox',
            link: entities,
            path: 'components.particlesystem.loop'
        });
        // label
        var label = new ui.Label({ text: 'Loop' });
        label.class.add('label-infield');
        label.style.paddingRight = '12px';
        panelPlayback.append(label);
        // reference
        editor.call('attributes:reference:particlesystem:loop:attach', label);


        // preWarm
        var fieldPreWarm = editor.call('attributes:addField', {
            panel: panelPlayback,
            type: 'checkbox',
            link: entities,
            path: 'components.particlesystem.preWarm'
        });
        // label
        var labelPreWarm = new ui.Label({ text: 'Pre Warm' });
        labelPreWarm.class.add('label-infield');
        labelPreWarm.style.paddingRight = '12px';
        panelPlayback.append(labelPreWarm);
        // states
        fieldPreWarm.hidden = labelPreWarm.hidden = ! fieldLoop.value && ! fieldLoop.class.contains('null');
        fieldLoop.on('change', function(value) {
            fieldPreWarm.hidden = labelPreWarm.hidden = ! value && ! this.class.contains('null');
        });
        // reference
        editor.call('attributes:reference:particlesystem:preWarm:attach', labelPreWarm);



        // lighting
        var panelLighting = editor.call('attributes:addField', {
            parent: panel,
            name: 'Lighting'
        });
        var label = panelLighting;
        panelLighting = panelLighting.parent;
        label.destroy();

        // lighting
        var fieldLighting = editor.call('attributes:addField', {
            panel: panelLighting,
            type: 'checkbox',
            link: entities,
            path: 'components.particlesystem.lighting'
        });
        // label
        var label = new ui.Label({ text: 'Enabled' });
        label.class.add('label-infield');
        label.style.paddingRight = '12px';
        label.class.add('label-infield');
        panelLighting.append(label);
        // reference
        editor.call('attributes:reference:particlesystem:lighting:attach', label);


        // halfLambert
        var fieldHalfLambert = editor.call('attributes:addField', {
            panel: panelLighting,
            type: 'checkbox',
            link: entities,
            path: 'components.particlesystem.halfLambert'
        });
        // label
        var labelHalfLambert = new ui.Label({ text: 'Half Lambert' });
        labelHalfLambert.class.add('label-infield');
        labelHalfLambert.style.paddingRight = '12px';
        panelLighting.append(labelHalfLambert);
        // state
        fieldHalfLambert.hidden = labelHalfLambert.hidden = ! fieldHalfLambert.value && ! fieldHalfLambert.class.contains('null');
        fieldLighting.on('change', function(value) {
            fieldHalfLambert.hidden = labelHalfLambert.hidden = ! value && ! this.class.contains('null');
        });
        // reference
        editor.call('attributes:reference:particlesystem:halfLambert:attach', labelHalfLambert);


        // intensity
        var fieldIntensity = editor.call('attributes:addField', {
            parent: panel,
            name: 'Intensity',
            type: 'number',
            link: entities,
            path: 'components.particlesystem.intensity'
        });
        // reference
        editor.call('attributes:reference:particlesystem:intensity:attach', fieldIntensity.parent.innerElement.firstChild.ui);


        // depth
        var panelDepth = editor.call('attributes:addField', {
            parent: panel,
            name: 'Depth'
        });
        var label = panelDepth;
        panelDepth = panelDepth.parent;
        label.destroy();

        // depthWrite
        var fieldDepthWrite = editor.call('attributes:addField', {
            panel: panelDepth,
            type: 'checkbox',
            link: entities,
            path: 'components.particlesystem.depthWrite'
        });
        // label
        var label = new ui.Label({ text: 'Write' });
        label.class.add('label-infield');
        label.style.paddingRight = '12px';
        panelDepth.append(label);
        // reference
        editor.call('attributes:reference:particlesystem:depthWrite:attach', label);

        // depthSoftening
        var fieldDepthSoftening = editor.call('attributes:addField', {
            panel: panelDepth,
            placeholder: 'Softening',
            type: 'number',
            link: entities,
            path: 'components.particlesystem.depthSoftening'
        });
        // reference
        editor.call('attributes:reference:particlesystem:depthSoftening:attach', fieldDepthSoftening);


        // sort
        var fieldSort = editor.call('attributes:addField', {
            parent: panel,
            name: 'Sort',
            type: 'number',
            enum: [
                { v: '', t: '...' },
                { v: 0, t: 'None' },
                { v: 1, t: 'Camera Distance' },
                { v: 2, t: 'Newest First' },
                { v: 3, t: 'Oldest First' }
            ],
            link: entities,
            path: 'components.particlesystem.sort'
        });
        // reference
        editor.call('attributes:reference:particlesystem:sort:attach', fieldSort.parent.innerElement.firstChild.ui);


        // blendType
        var fieldBlendType = editor.call('attributes:addField', {
            parent: panel,
            name: 'Blend Type',
            type: 'number',
            enum: [
                { v: '', t: '...' },
                { v: 2, t: 'Alpha' },
                { v: 1, t: 'Additive' },
                { v: 5, t: 'Multiply' }
            ],
            link: entities,
            path: 'components.particlesystem.blendType'
        });
        // reference
        editor.call('attributes:reference:particlesystem:blend:attach', fieldBlendType.parent.innerElement.firstChild.ui);


        // stretch
        var fieldStretch = editor.call('attributes:addField', {
            parent: panel,
            name: 'Stretch',
            type: 'number',
            link: entities,
            path: 'components.particlesystem.stretch'
        });
        // reference
        editor.call('attributes:reference:particlesystem:stretch:attach', fieldStretch.parent.innerElement.firstChild.ui);


        // alignToMotion
        var fieldAlignToMotion = editor.call('attributes:addField', {
            parent: panel,
            name: 'Align To Motion',
            type: 'checkbox',
            link: entities,
            path: 'components.particlesystem.alignToMotion'
        });
        // reference
        editor.call('attributes:reference:particlesystem:alignToMotion:attach', fieldAlignToMotion.parent.innerElement.firstChild.ui);


        // emitterShape
        var fieldEmitterShape = editor.call('attributes:addField', {
            parent: panel,
            name: 'Emmiter Shape',
            type: 'number',
            enum: [
                { v: '', t: '...' },
                { v: 0, t: 'Box' },
                { v: 1, t: 'Sphere' }
            ],
            link: entities,
            path: 'components.particlesystem.emitterShape'
        });
        // reference
        editor.call('attributes:reference:particlesystem:emitterShape:attach', fieldEmitterShape.parent.innerElement.firstChild.ui);


        // emitterExtents
        var fieldSpawnBounds = editor.call('attributes:addField', {
            parent: panel,
            name: 'Emmiter Extents',
            placeholder: [ 'X', 'Y', 'Z' ],
            type: 'vec3',
            link: entities,
            path: 'components.particlesystem.emitterExtents'
        });
        fieldSpawnBounds[0].parent.hidden = fieldEmitterShape.value !== 0 || fieldEmitterShape.class.contains('null');
        fieldEmitterShape.on('change', function(value) {
            fieldSpawnBounds[0].parent.hidden = value !== 0 || this.class.contains('null');
        });
        // reference
        editor.call('attributes:reference:particlesystem:emitterExtents:attach', fieldSpawnBounds[0].parent.innerElement.firstChild.ui);


        // emitterRadius
        var fieldSpawnRadius = editor.call('attributes:addField', {
            parent: panel,
            name: 'Emmiter Radius',
            type: 'number',
            link: entities,
            path: 'components.particlesystem.emitterRadius'
        });
        fieldSpawnRadius.parent.hidden = fieldEmitterShape.value !== 1 || fieldEmitterShape.class.contains('null');
        fieldEmitterShape.on('change', function(value) {
            fieldSpawnRadius.parent.hidden = value !== 1 || this.class.contains('null');
        });
        // reference
        editor.call('attributes:reference:particlesystem:emitterRadius:attach', fieldSpawnRadius.parent.innerElement.firstChild.ui);


        // wrap
        var fieldWrap = editor.call('attributes:addField', {
            parent: panel,
            name: 'Wrap',
            type: 'checkbox',
            link: entities,
            path: 'components.particlesystem.wrap'
        });
        // reference
        editor.call('attributes:reference:particlesystem:wrap:attach', fieldWrap.parent.innerElement.firstChild.ui);


        // wrapBounds
        var fieldWrapBounds = editor.call('attributes:addField', {
            parent: panel,
            name: 'Wrap Bounds',
            placeholder: [ 'X', 'Y', 'Z' ],
            type: 'vec3',
            link: entities,
            path: 'components.particlesystem.wrapBounds'
        });
        fieldWrapBounds[0].parent.hidden = ! fieldWrap.value && ! fieldWrap.class.contains('null');
        fieldWrap.on('change', function(value) {
            fieldWrapBounds[0].parent.hidden = ! value && ! this.class.contains('null');
        });
        // reference
        editor.call('attributes:reference:particlesystem:wrapBounds:attach', fieldWrapBounds[0].parent.innerElement.firstChild.ui);


        // colorMapAsset
        var fieldColorMap = editor.call('attributes:addField', {
            parent: panel,
            name: 'Color Map',
            type: 'asset',
            kind: 'texture',
            link: entities,
            path: 'components.particlesystem.colorMapAsset'
        });
        // reference
        editor.call('attributes:reference:particlesystem:colorMap:attach', fieldColorMap._label);

        fieldColorMap.on('change', function (value) {
            panelFrames.hidden = !value && !fieldNormalMap.value;
            fieldAnimatedTextureNumFrames.parent.hidden = panelFrames.hidden;
            panelAnimationPlayback.hidden = panelFrames.hidden;
        });

        // normalMapAsset
        var fieldNormalMap = editor.call('attributes:addField', {
            parent: panel,
            name: 'Normal Map',
            type: 'asset',
            kind: 'texture',
            link: entities,
            path: 'components.particlesystem.normalMapAsset'
        });
        // reference
        editor.call('attributes:reference:particlesystem:normalMap:attach', fieldNormalMap._label);

        fieldNormalMap.on('change', function (value) {
            panelFrames.hidden = !value && !fieldColorMap.value;
            fieldAnimatedTextureNumFrames.hidden = panelFrames.hidden;
            panelAnimationPlayback.hidden = panelFrames.hidden;
        });

        // frames
        var panelFrames = editor.call('attributes:addField', {
            parent: panel,
            name: 'Map Tiles'
        });

        var label = panelFrames;
        panelFrames = panelFrames.parent;
        label.destroy();

        // number of x tiles
        var fieldAnimatedTextureTilesX = editor.call('attributes:addField', {
            parent: panelFrames,
            type: 'number',
            placeholder: 'X',
            min: 1,
            link: entities,
            path: 'components.particlesystem.animTilesX'
        });
        fieldAnimatedTextureTilesX.style.width = '50%';
        // reference
        editor.call('attributes:reference:particlesystem:animTilesX:attach', fieldAnimatedTextureTilesX.parent.innerElement.firstChild.ui);

        // number of y tiles
        var fieldAnimatedTextureTilesY = editor.call('attributes:addField', {
            parent: panelFrames,
            type: 'number',
            placeholder: 'Y',
            min: 1,
            link: entities,
            path: 'components.particlesystem.animTilesY'
        });
        fieldAnimatedTextureTilesY.style.width = '50%';
        // reference
        editor.call('attributes:reference:particlesystem:animTilesY:attach', fieldAnimatedTextureTilesY.parent.innerElement.firstChild.ui);

        panelFrames.hidden = !fieldColorMap.value && !fieldNormalMap.value;

        // frames to play
        var fieldAnimatedTextureNumFrames = editor.call('attributes:addField', {
            parent: panel,
            type: 'number',
            name: 'Frame Count',
            min: 1,
            link: entities,
            path: 'components.particlesystem.animNumFrames'
        });
        // reference
        editor.call('attributes:reference:particlesystem:animNumFrames:attach', fieldAnimatedTextureNumFrames.parent.innerElement.firstChild.nextSibling.ui);

        fieldAnimatedTextureNumFrames.parent.hidden = !fieldColorMap.value && !fieldNormalMap.value;

        var panelAnimationPlayback = editor.call('attributes:addField', {
            parent: panel,
            name: 'Animation'
        });

        var label = panelAnimationPlayback;
        panelAnimationPlayback = panelAnimationPlayback.parent;
        label.destroy();

        // animation speed
        var fieldAnimatedTextureSpeed = editor.call('attributes:addField', {
            parent: panelAnimationPlayback,
            placeholder: 'Speed',
            type: 'number',
            link: entities,
            path: 'components.particlesystem.animSpeed'
        });
        fieldAnimatedTextureSpeed.style.width = '50%';
        // reference
        editor.call('attributes:reference:particlesystem:animSpeed:attach', fieldAnimatedTextureSpeed.parent.innerElement.firstChild.ui);


        // animation loop
        var fieldAnimatedTextureLoop = editor.call('attributes:addField', {
            parent: panelAnimationPlayback,
            type: 'checkbox',
            link: entities,
            path: 'components.particlesystem.animLoop'
        });

        // label
        var label = new ui.Label({ text: 'Loop' });
        label.class.add('label-infield');
        label.style.paddingRight = '12px';
        panelAnimationPlayback.append(label);

        // reference
        editor.call('attributes:reference:particlesystem:animLoop:attach', label);

        panelAnimationPlayback.hidden = !fieldColorMap.value && !fieldNormalMap.value;

        // mesh
        var fieldMesh = editor.call('attributes:addField', {
            parent: panel,
            name: 'Mesh',
            type: 'asset',
            kind: 'model',
            link: entities,
            path: 'components.particlesystem.mesh'
        });
        // reference
        editor.call('attributes:reference:particlesystem:mesh:attach', fieldMesh._label);


        // localVelocityGraph
        var fieldLocalVelocity = editor.call('attributes:addField', {
            parent: panel,
            name: 'Local Velocity',
            type: 'curveset',
            link: entities[0],
            paths: [ 'components.particlesystem.localVelocityGraph', 'components.particlesystem.localVelocityGraph2' ],
            curves: [ 'X', 'Y', 'Z' ]
        });
        // reference
        editor.call('attributes:reference:particlesystem:localVelocityGraph:attach', fieldLocalVelocity.parent.innerElement.firstChild.ui);


        // velocityGraph
        var fieldVelocity = editor.call('attributes:addField', {
            parent: panel,
            name: 'Velocity',
            type: 'curveset',
            link: entities[0],
            paths: [ 'components.particlesystem.velocityGraph', 'components.particlesystem.velocityGraph2' ],
            curves: [ 'X', 'Y', 'Z' ]
        });
        // reference
        editor.call('attributes:reference:particlesystem:velocityGraph:attach', fieldVelocity.parent.innerElement.firstChild.ui);


        // rotationSpeedGraph
        var fieldRotationSpeed = editor.call('attributes:addField', {
            parent: panel,
            name: 'Rotation Speed',
            type: 'curveset',
            link: entities[0],
            paths: [ 'components.particlesystem.rotationSpeedGraph', 'components.particlesystem.rotationSpeedGraph2' ],
            curves: [ 'Angle' ],
            verticalValue: 180
        });
        // reference
        editor.call('attributes:reference:particlesystem:rotationSpeedGraph:attach', fieldRotationSpeed.parent.innerElement.firstChild.ui);


        // scaleGraph
        var fieldScale = editor.call('attributes:addField', {
            parent: panel,
            name: 'Scale',
            type: 'curveset',
            link: entities[0],
            paths: [ 'components.particlesystem.scaleGraph', 'components.particlesystem.scaleGraph2' ],
            curves: [ 'Scale' ],
            verticalValue: 1,
            min: 0
        });
        // reference
        editor.call('attributes:reference:particlesystem:scaleGraph:attach', fieldScale.parent.innerElement.firstChild.ui);


        // colorGraph
        var fieldColor = editor.call('attributes:addField', {
            parent: panel,
            name: 'Color',
            type: 'curveset',
            link: entities[0],
            path: 'components.particlesystem.colorGraph',
            gradient: true,
            curves: [ 'R', 'G', 'B' ],
            max: 1,
            min: 0
        });
        // reference
        editor.call('attributes:reference:particlesystem:colorGraph:attach', fieldColor.parent.innerElement.firstChild.ui);


        // alphaGraph
        var fieldAlpha = editor.call('attributes:addField', {
            parent: panel,
            name: 'Opacity',
            type: 'curveset',
            link: entities[0],
            paths: [ 'components.particlesystem.alphaGraph', 'components.particlesystem.alphaGraph2' ],
            curves: ['Opacity' ],
            min: 0,
            max: 1
        });
        // reference
        editor.call('attributes:reference:particlesystem:alphaGraph:attach', fieldAlpha.parent.innerElement.firstChild.ui);

        if (entities.length > 1) {
            fieldLocalVelocity.disabled = true;
            fieldVelocity.disabled = true;
            fieldRotationSpeed.disabled = true;
            fieldScale.disabled = true;
            fieldColor.disabled = true;
            fieldAlpha.disabled = true;
        }
    });
});


/* editor/attributes/components/attributes-components-rigidbody.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[entity]', function(entities) {
        var panelComponents = editor.call('attributes:entity.panelComponents');
        if (! panelComponents)
            return;

        var events = [ ];

        var panel = editor.call('attributes:entity:addComponentPanel', {
            title: 'Rigid Body',
            name: 'rigidbody',
            entities: entities
        });

        // type
        var fieldType = editor.call('attributes:addField', {
            parent: panel,
            name: 'Type',
            type: 'string',
            enum: {
                '': '...',
                'static': 'Static',
                'dynamic': 'Dynamic',
                'kinematic': 'Kinematic'
            },
            link: entities,
            path: 'components.rigidbody.type'
        });
        // reference
        editor.call('attributes:reference:rigidbody:type:attach', fieldType.parent.innerElement.firstChild.ui);


        // dynamic/kinematic fields
        var panelDynamic = editor.call('attributes:addPanel', {
            parent: panel
        });
        panelDynamic.hidden = fieldType.value !== '' && fieldType.value !== 'dynamic';
        fieldType.on('change', function(value) {
            panelDynamic.hidden = value !== '' && value !== 'dynamic';
        });

        // mass
        var fieldMass = editor.call('attributes:addField', {
            parent: panelDynamic,
            name: 'Mass',
            type: 'number',
            precision: 2,
            step: .1,
            min: 0,
            link: entities,
            path: 'components.rigidbody.mass'
        });
        fieldMass.placeholder = 'Kg';
        // reference
        editor.call('attributes:reference:rigidbody:mass:attach', fieldMass.parent.innerElement.firstChild.ui);


        // linearDamping
        var fieldLinearDamping = editor.call('attributes:addField', {
            parent: panelDynamic,
            name: 'Damping',
            placeholder: 'Linear',
            type: 'number',
            precision: 2,
            step: .01,
            min: 0,
            max: 1,
            link: entities,
            path: 'components.rigidbody.linearDamping'
        });
        fieldLinearDamping.style.width = '32px';
        // reference
        editor.call('attributes:reference:rigidbody:damping:attach', fieldLinearDamping.parent.innerElement.firstChild.ui);


        // angularDamping
        var fieldAngularDamping = editor.call('attributes:addField', {
            panel: fieldLinearDamping.parent,
            placeholder: 'Angular',
            type: 'number',
            precision: 2,
            step: .01,
            min: 0,
            max: 1,
            link: entities,
            path: 'components.rigidbody.angularDamping'
        });
        fieldAngularDamping.style.width = '32px';


        // linearFactor
        var fieldLinearFactor = editor.call('attributes:addField', {
            parent: panelDynamic,
            name: 'Linear Factor',
            placeholder: [ 'X', 'Y', 'Z' ],
            precision: 2,
            step: .01,
            min: 0,
            max: 1,
            type: 'vec3',
            link: entities,
            path: 'components.rigidbody.linearFactor'
        });
        // reference
        editor.call('attributes:reference:rigidbody:linearFactor:attach', fieldLinearFactor[0].parent.innerElement.firstChild.ui);


        // angularFactor
        var fieldAngularFactor = editor.call('attributes:addField', {
            parent: panelDynamic,
            name: 'Angular Factor',
            placeholder: [ 'X', 'Y', 'Z' ],
            precision: 2,
            step: .01,
            min: 0,
            max: 1,
            type: 'vec3',
            link: entities,
            path: 'components.rigidbody.angularFactor'
        });
        // reference
        editor.call('attributes:reference:rigidbody:angularFactor:attach', fieldAngularFactor[0].parent.innerElement.firstChild.ui);


        // friction
        var fieldFriction = editor.call('attributes:addField', {
            parent: panel,
            name: '',
            placeholder: 'Friction',
            type: 'number',
            precision: 2,
            step: .01,
            min: 0,
            max: 1,
            link: entities,
            path: 'components.rigidbody.friction'
        });
        fieldFriction.style.width = '32px';
        // reference
        editor.call('attributes:reference:rigidbody:friction:attach', fieldFriction);


        // restitution
        var fieldRestitution = editor.call('attributes:addField', {
            panel: fieldFriction.parent,
            placeholder: 'Restitution',
            type: 'number',
            precision: 2,
            step: .01,
            min: 0,
            max: 1,
            link: entities,
            path: 'components.rigidbody.restitution'
        });
        fieldRestitution.style.width = '32px';


        var panelFrictionRestitution = editor.call('attributes:addField', {
            parent: panel,
            name: ''
        });
        var label = panelFrictionRestitution;
        panelFrictionRestitution = panelFrictionRestitution.parent;
        label.destroy();

        // friction slider
        var fieldFrictionSlider = editor.call('attributes:addField', {
            panel: panelFrictionRestitution,
            precision: 3,
            min: 0,
            max: 1,
            type: 'number',
            slider: true,
            link: entities,
            path: 'components.rigidbody.friction'
        });
        fieldFrictionSlider.flexGrow = 1;

        // restitution slider
        var fieldRestitutionSlider = editor.call('attributes:addField', {
            panel: panelFrictionRestitution,
            precision: 3,
            min: 0,
            max: 1,
            type: 'number',
            slider: true,
            link: entities,
            path: 'components.rigidbody.restitution'
        });
        fieldRestitutionSlider.flexGrow = 1;
    });
});


/* editor/attributes/components/attributes-components-script.js */
editor.once('load', function() {
    'use strict';

    var scriptAttributeTypes = {
        'number': 'number',
        'string': 'string',
        'boolean': 'checkbox',
        'asset': 'assets', // TEMP
        'rgb': 'rgb',
        'rgba': 'rgb', // TEMP
        'vector': 'vec3',
        'enumeration': 'number',
        'entity': 'entity',
        'curve': 'curveset',
        'colorcurve': 'curveset'
    };

    var scriptAttributeRuntimeTypes = {
        'number': '{Number}',
        'string': '{String}',
        'boolean': '{Boolean}',
        'rgb': '{pc.Color}',
        'rgba': '{pc.Color}',
        'vector': '{pc.Vec3}',
        'enumeration': '{Number}',
        'entity': '{pc.Entity}'
    };

    // index entities with script components
    // so we can easily find them when we need
    // to refresh script attributes
    var entitiesWithScripts = { };

    editor.on('entities:add', function (entity) {
        if (entity.get('components.script'))
            entitiesWithScripts[entity.get('resource_id')] = entity;

        entity.on('components.script:set', function (value) {
            if (! value)
                return;

            entitiesWithScripts[entity.get('resource_id')] = entity;
        });

        entity.on('components.script:unset', function () {
            delete entitiesWithScripts[entity.get('resource_id')];
        });
    });

    editor.on('entities:remove', function (entity) {
        delete entitiesWithScripts[entity.get('resource_id')];
    });

    editor.on('attributes:inspect[entity]', function(entities) {
        var panelComponents = editor.call('attributes:entity.panelComponents');
        if (! panelComponents)
            return;

        var panel = editor.call('attributes:entity:addComponentPanel', {
            title: 'Scripts',
            name: 'script',
            entities: entities
        });

        // holds each script panel
        var events = [ ];
        var scriptsIndex = { };

        for(var i = 0; i < entities.length; i++) {
            events.push(entities[i].on('components.script:unset', function(valueOld) {
                if (! valueOld)
                    return;

                for(var i = 0; i < valueOld.scripts.length; i++) {
                    var scriptPanel = scriptsIndex[valueOld.scripts[i].url];
                    if (! scriptPanel)
                        continue;

                    scriptPanel.count--;
                    scriptPanel._link.textContent = (scriptPanel.count === entities.length ? '' : '* ') + scriptPanel._originalTitle;

                    if (scriptPanel.count === 0) {
                        scriptPanel.destroy();
                        delete scriptsIndex[valueOld.scripts[i].url];
                    }
                }
            }));
        }

        var urlRegex = /^http(s)?:/;
        var jsRegex = /\.js$/;
        var scriptNameRegex = /^(?:[\w\d\.-]+\/)*[\w\d\.-]+(?:\.[j|J][s|S](?:[o|O][n|N])?)?$/;

        // scripts.add
        var btnAddScript = new ui.Button({
            text: 'Add Script'
        });
        btnAddScript.class.add('add-script');
        panel.append(btnAddScript);

        btnAddScript.on('click', function () {
            var evtPick = editor.once("picker:asset", function (asset) {
                addScript(asset.get('filename'));
                evtPick = null;
            });

            // show asset picker
            editor.call("picker:asset", "script", null);

            editor.once('picker:asset:close', function () {
                if (evtPick) {
                    evtPick.unbind();
                    evtPick = null;
                }
            });
        });

        var panelScripts = new ui.Panel();
        panelScripts.class.add('components-scripts');
        panel.append(panelScripts);

        var addScript = function(url) {
            var scriptAdded = false;
            var records = [ ];
            var requestScript = false;

            if (! urlRegex.test(url)) {
                if (! jsRegex.test(url))
                    url += '.js';

                if (! scriptNameRegex.test(url) || url.indexOf('..') >= 0)
                    return false;

                requestScript = true;
            }

            for(var i = 0; i < entities.length; i++) {
                var addScript = true;
                var scripts = entities[i].getRaw('components.script.scripts');
                for(var s = 0; s < scripts.length; s++) {
                    if (scripts[s].get('url') === url) {
                        addScript = false;
                        break;
                    }
                }

                if (addScript) {
                    var script = new Observer({
                        url: url
                    });

                    records.push({
                        get: entities[i].history._getItemFn
                    });

                    entities[i].history.enabled = false;
                    entities[i].insert('components.script.scripts', script);
                    entities[i].history.enabled = true;

                    scriptAdded = true;
                }
            }

            if (requestScript) {
                // try to get the script and if it doesn't exist create it
                editor.call('sourcefiles:content', url, function (err) {
                    // script does not exist so create it
                    if (err === 404) {
                        editor.call('sourcefiles:create', editor.call('sourcefiles:skeleton', url), url);
                    } else if (!err) {
                        refreshScriptAttributes(url);
                    }
                });
            } else {
                refreshScriptAttributes(url);
            }

            editor.call('history:add', {
                name: 'entities.components.script.scripts',
                undo: function() {
                    for(var i = 0; i < records.length; i++) {
                        var item = records[i].get();
                        if (! item)
                            continue;

                        var scripts = item.getRaw('components.script.scripts');
                        if (! scripts)
                            continue;

                        for(var s = 0; s < scripts.length; s++) {
                            if (scripts[s].get('url') !== url)
                                continue;

                            item.history.enabled = false;
                            item.removeValue('components.script.scripts', scripts[s]);
                            item.history.enabled = true;
                            break;
                        }
                    }
                },
                redo: function() {
                    for(var i = 0; i < records.length; i++) {
                        var item = records[i].get();
                        if (! item)
                            continue;

                        var addScript = true;
                        var scripts = item.getRaw('components.script.scripts');
                        for(var s = 0; s < scripts.length; s++) {
                            if (scripts[s].get('url') !== url)
                                continue;
                            addScript = false;
                            break;
                        }

                        if (! addScript)
                            continue;

                        var script = new Observer({
                            url: url
                        });

                        item.history.enabled = false;
                        item.insert('components.script.scripts', script);
                        item.history.enabled = true;
                    }

                    refreshScriptAttributes(url);
                }
            });

            return scriptAdded;
        };

        var refreshScriptAttributes = function(url) {
            if (! editor.call('permissions:write'))
                return;

            var fullUrl = urlRegex.test(url) ? url : editor.call('sourcefiles:url', url);

            editor.call('sourcefiles:scan', fullUrl, function (data) {
                data.url = url;

                // merge old attributes with new attributes for all script components with this script
                for (var key in entitiesWithScripts) {
                    var entity = entitiesWithScripts[key];
                    var scripts = entity.getRaw('components.script.scripts');
                    if (! scripts)
                        continue;

                    for (var i = 0; i < scripts.length; i++) {
                        var scriptInstance = scripts[i];
                        if (scriptInstance.get('url') !== url)
                            continue;

                        var oldAttributes = scriptInstance.get('attributes') || { };
                        for (var attributeName in data.attributes) {
                            if (! data.attributes.hasOwnProperty(attributeName))
                                continue;

                            var value = data.attributes[attributeName].defaultValue;
                            if (attributeName in oldAttributes) {
                                var attributeOld = oldAttributes[attributeName];
                                var attributeNew = data.attributes[attributeName];

                                if (attributeOld.type === 'asset') {
                                    if (attributeOld.options.type !== attributeNew.options.type) {
                                        // different asset.type
                                        if (attributeNew.options.max === 1) {
                                            if (typeof(attributeNew.defaultValue) === 'number') {
                                                value = attributeNew.defaultValue;
                                            } else {
                                                value = null;
                                            }
                                        } else {
                                            if (attributeNew.defaultValue instanceof Array) {
                                                value = attributeNew.defaultValue;
                                            } else {
                                                value = [ ];
                                            }
                                        }
                                    } else if (attributeOld.options.max === 1 && attributeNew.options.max !== 1) {
                                        // now multiple assets
                                        if (attributeOld.value && typeof(attributeOld.value) === 'number') {
                                            value = [ attributeOld.value ];
                                        } else if (attributeNew.defaultValue instanceof Array) {
                                            value = attributeNew.defaultValue;
                                        } else {
                                            value = [ ];
                                        }
                                    } else if (attributeOld.options.max !== 1 && attributeNew.options.max === 1) {
                                        // now single asset
                                        if ((attributeOld.value instanceof Array) && attributeOld.value.length && attributeOld.value[0] && typeof(attributeOld.value[0]) === 'number') {
                                            value = attributeOld.value[0];
                                        } else if (typeof(attributeNew.defaultValue) === 'number') {
                                            value = attributeNew.defaultValue;
                                        } else {
                                            value = null;
                                        }
                                    } else {
                                        // old value
                                        value = attributeOld.value !== attributeOld.defaultValue ? attributeOld.value : value;
                                    }
                                } else if (attributeOld.type === data.attributes[attributeName].type) {
                                    // old value
                                    value = attributeOld.value !== attributeOld.defaultValue ? attributeOld.value : value;
                                }
                            }

                            data.attributes[attributeName].value = value;
                        }

                        // this is not undoable
                        var history = entity.history.enabled;
                        entity.history.enabled = false;
                        entity.getRaw('components.script.scripts.' + i).patch(data);
                        entity.history.enabled = history;
                    }
                }
            });
        };

        var updateAttributeFields = function(script, parent) {
            var attributes = script.get('attributesOrder');
            var children = parent.innerElement.childNodes;
            var list = [ ];
            var index = { };
            var toDestroy = [ ];
            var toCreate = [ ];

            for(var i = 0; i < children.length; i++) {
                var attribute = children[i].ui.attribute;
                var attributeType = children[i].ui.attributeType;
                var attributeUiType = children[i].ui.attributeUiType;

                if (attributes.indexOf(attribute) === -1 || attributeUiType !== script.get('attributes.' + attribute + '.type')) {
                    toDestroy.push(children[i].ui);
                } else {
                    list.push(attribute);
                    index[attribute] = children[i].ui;
                }
            }

            var i = toDestroy.length;
            while(i--) {
                toDestroy[i].destroy();
            }

            if (attributes) {
                for(var i = 0; i < attributes.length; i++) {
                    var ind = list.indexOf(attributes[i]);
                    var panelAttribute = null;

                    if (ind === -1) {
                        // new attibute
                        panelAttribute = createAttributeField(script, attributes[i], parent);
                        list.splice(i, 0, attributes[i]);
                        index[attributes[i]] = panelAttribute;
                    } else if (ind !== i) {
                        // moved attribute
                        panelAttribute = index[attributes[i]];
                        list.splice(ind, 1);
                        list.splice(i, 0, attributes[i]);
                    }

                    if (! panelAttribute)
                        continue;

                    parent.innerElement.removeChild(panelAttribute.element);

                    var ref = null;
                    if (i === 0) {
                        ref = parent.innerElement.firstChild;
                    } else {
                        ref = index[list[i - 1]].element.nextSibling;
                    }

                    if (ref) {
                        parent.innerElement.insertBefore(panelAttribute.element, ref);
                    } else {
                        parent.innerElement.appendChild(panelAttribute.element);
                    }
                }
            }
        };

        var createAttributeField = function(script, attribute, parent) {
            var choices = null;
            attribute = script.get('attributes.' + attribute);

            if (attribute.type === 'enumeration') {
                choices = [ { v: '', t: '...' } ];

                try {
                    for(var e = 0; e < attribute.options.enumerations.length; e++) {
                        choices.push({
                            v: attribute.options.enumerations[e].value,
                            t: attribute.options.enumerations[e].name
                        });
                    }
                } catch(ex) {
                    console.log(ex)
                    console.log('could not recreate enumeration for script attribute, ' + script.get('url'));
                }
            }

            var url = script.get('url');
            var scripts = [ ];
            for(var i = 0; i < entities.length; i++) {
                var items = entities[i].getRaw('components.script.scripts');
                if (! items)
                    continue;

                for(var s = 0; s < items.length; s++) {
                    if (items[s].get('url') === url) {
                        scripts.push(items[s]);
                        break;
                    }
                }
            }

            var field;

            var reference = {
                title: attribute.name,
                subTitle: scriptAttributeRuntimeTypes[attribute.type]
            };

            if (attribute.description)
                reference.description = attribute.description;
            else if (attribute.displayName !== attribute.name)
                reference.description = attribute.displayName;

            var type = scriptAttributeTypes[attribute.type];
            if (attribute.type === 'enumeration' && choices.length >= 2 && typeof(choices[1].v) === 'string') {
                type = 'string';
                reference.subTitle = scriptAttributeRuntimeTypes[type];
            } else if (attribute.type === 'asset') {
                if (attribute.options.max === 1) {
                    reference.subTitle = '{Number}';
                } else {
                    reference.subTitle = '[Number]';
                }
            } else if (attribute.type === 'curve') {
                if (attribute.options.curves.length > 1) {
                    reference.subTitle = '{pc.CurveSet}';
                } else {
                    reference.subTitle = '{pc.Curve}';
                }
            } else if (attribute.type === 'colorcurve') {
                if (attribute.options.type.length === 1) {
                    reference.subTitle = '{pc.Curve}';
                } else {
                    reference.subTitle = '{pc.CurveSet}';
                }
            }

            if (scriptAttributeTypes[attribute.type] !== 'assets') {
                var type = scriptAttributeTypes[attribute.type];
                if (attribute.type === 'enumeration' && choices.length >= 2 && typeof(choices[1].v) === 'string')
                    type = 'string';

                var args = {
                    parent: parent,
                    name: attribute.displayName || attribute.name,
                    type: type,
                    enum: choices,
                    link: scripts,
                    path: 'attributes.' + attribute.name + '.value',
                    reference: reference
                };

                if (attribute.type === 'curve' || attribute.type === 'colorcurve') {
                    // find entity of first script
                    var firstEntity = scripts[0]._parent;
                    while (firstEntity._parent) {
                        firstEntity = firstEntity._parent;
                    }

                    var scriptIndex = firstEntity.getRaw('components.script.scripts').indexOf(scripts[0]);

                    var setCurvePickerArgs = function (options) {
                        if (attribute.type === 'curve') {
                            args.curves = options.curves;
                            args.min = options.min;
                            args.max = options.max;
                            args.gradient = false;
                        } else {
                            args.curves = options.type.split('');
                            args.min = 0;
                            args.max = 1;
                            args.gradient = true;
                        }
                    };

                    setCurvePickerArgs(attribute.options);

                    // use entity as the link for the curve so that history will work as expected
                    args.link = firstEntity;
                    args.path = 'components.script.scripts.' + scriptIndex + '.attributes.' + attribute.name + '.value';
                    args.hideRandomize = true;

                    var curveType = attribute.type;

                    // when argument options change make sure we refresh the curve pickers
                    var evtOptionsChanged = scripts[0].on('attributes.' + attribute.name + '.options:set', function (value, oldValue) {
                        // do this in a timeout to make sure it's done after all of the
                        // attribute fields have been updated like the 'defaultValue' field
                        setTimeout(function () {
                            // argument options changed so get new options and set args
                            var options = value;

                            var prevNumCurves = args.curves.length;

                            setCurvePickerArgs(options);

                            // reset field value which will trigger a refresh of the curve picker as well
                            var attributeValue = scripts[0].get('attributes.' + attribute.name + '.value');
                            if (prevNumCurves !== args.curves.length) {
                                attributeValue = scripts[0].get('attributes.' + attribute.name + '.defaultValue');
                                scripts[0].set('attributes.' + attribute.name + '.value', attributeValue);
                            }

                            field.curveNames = args.curves;
                            field.value = [attributeValue];
                        });
                    });
                    events.push(evtOptionsChanged);

                    // if we change the attribute type then don't listen to options changes
                    var evtTypeChanged = scripts[0].on('attributes.' + attribute.name + '.type:set', function (value) {
                        if (value !== curveType) {
                            evtOptionsChanged.unbind();
                            evtTypeChanged.unbind();
                        }
                    });
                    events.push(evtTypeChanged);
                }

                field = editor.call('attributes:addField', args);

                if (attribute.type === 'curve' || attribute.type === 'colorcurve') {
                    if (entities.length > 1)
                        field.disabled = true;
                }
            }

            if (attribute.type !== 'enumeration' && scriptAttributeTypes[attribute.type] === 'number') {
                field.flexGrow = 1;
                field.style.width = '32px';

                // friction slider
                var slider = editor.call('attributes:addField', {
                    panel: field.parent,
                    min: attribute.options.min || 0,
                    max: attribute.options.max || 1,
                    type: 'number',
                    slider: true,
                    link: scripts,
                    path: 'attributes.' + attribute.name + '.value'
                });
                slider.style.width = '32px';
                slider.flexGrow = 4;

                var evtMin = scripts[0].on('attributes.' + attribute.name + '.options.min:set', function(value) {
                    slider.min = value;
                    slider.hidden = isNaN(scripts[0].get('attributes.' + attribute.name + '.options.min')) || isNaN(scripts[0].get('attributes.' + attribute.name + '.options.max'));
                });
                events.push(evtMin)

                var evtMax = scripts[0].on('attributes.' + attribute.name + '.options.max:set', function(value) {
                    slider.max = value;
                    slider.hidden = isNaN(scripts[0].get('attributes.' + attribute.name + '.options.min')) || isNaN(scripts[0].get('attributes.' + attribute.name + '.options.max'));
                });
                events.push(evtMax);

                var evtMinUnset = scripts[0].on('attributes.' + attribute.name + '.options.min:unset', function() {
                    slider.hidden = true;
                });
                events.push(evtMinUnset);

                var evtMaxUnset = script.on('attributes.' + attribute.name + '.options.max:unset', function() {
                    slider.hidden = true;
                });
                events.push(evtMaxUnset);

                events.push(field.once('destroy', function() {
                    evtMin.unbind();
                    evtMax.unbind();
                    evtMinUnset.unbind();
                    evtMaxUnset.unbind();
                }));
            } else if (scriptAttributeTypes[attribute.type] === 'assets') {
                var options;

                if (attribute.options.max === 1) {
                    // asset
                    options = {
                        parent: parent,
                        name: attribute.displayName || attribute.name,
                        type: 'asset',
                        kind: attribute.options.type || '*',
                        link: scripts,
                        path: 'attributes.' + attribute.name + '.value',
                        single: true,
                        reference: reference
                    };
                    field = editor.call('attributes:addField', options);
                } else {
                    // assets
                    options = {
                        panel: parent,
                        title: 'Asset',
                        type: attribute.options.type || '*',
                        link: scripts,
                        path: 'attributes.' + attribute.name + '.value',
                        reference: reference
                    };
                    field = editor.call('attributes:addAssetsList', options);
                    field.parent._label.text = attribute.displayName || attribute.name;
                }

                field.options = options;

                // if we change asset `type`
                var evtAssetTypeChanged = scripts[0].on('attributes.' + attribute.name + '.options.type:set', function (value) {
                    options.kind = value || '*';
                });
                events.push(evtAssetTypeChanged);

                // if we change `max` to change between single/multiple
                var evtMaxAssetChanged = script.on('attributes.' + attribute.name + '.options.max:set', function(value) {
                    if ((options.single && value === 1) || (! options.single && value !== 1))
                        return;

                    setTimeout(function() {
                        updateAttributeFields(script, parent);
                    }, 0);
                });
                events.push(evtMaxAssetChanged);

                field.once('destroy', function() {
                    evtAssetTypeChanged.unbind();
                    evtMaxAssetChanged.unbind();
                });
            }

            var fieldParent;
            if (field instanceof Array) {
                fieldParent = field[0].parent;
            } else {
                fieldParent = field.parent;
            }

            var evtType = script.on('attributes.' + attribute.name + '.type:set', function(value) {
                setTimeout(function() {
                    updateAttributeFields(script, parent);
                }, 0);
            });
            events.push(evtType);

            events.push(fieldParent.once('destroy', function() {
                evtType.unbind();
            }));

            fieldParent.attribute = attribute.name;
            fieldParent.attributeUiType = scriptAttributeTypes[attribute.type];
            fieldParent.attributeType = attribute.type;

            return fieldParent;
        };

        var createScriptPanel = function(script) {
            var panelScript = scriptsIndex[script.get('url')];
            if (panelScript) {
                panelScript.count++;
                panelScript._link.textContent = (panelScript.count === entities.length ? '' : '* ') + panelScript._originalTitle;
                return;
            }

            panelScript = new ui.Panel(script.get('url'));
            panelScript.class.add('component-script');
            panelScript.count = 1;

            var href = document.createElement('a');

            var url = script.get('url');
            var lowerUrl = url.toLowerCase();
            var isExternalUrl = urlRegex.test(lowerUrl);
            if (! isExternalUrl && ! jsRegex.test(url))
                url += '.js';

            panelScript._originalTitle = script.get('name') || getFilenameFromUrl(url);
            panelScript._link = href;
            href.textContent = (panelScript.count === entities.length ? '' : '* ') + panelScript._originalTitle;
            href.target = '_blank';
            href.href = isExternalUrl ? url : '/editor/code/' + config.project.id + '/' + url;
            panelScript.headerElementTitle.textContent = '';
            panelScript.headerElementTitle.appendChild(href);

            // name change
            events.push(script.on('name:set', function(value) {
                panelScript._originalTitle = value;
                href.textContent = (panelScript.count === entities.length ? '' : '* ') + panelScript._originalTitle;
            }));

            // remove
            var fieldRemoveScript = new ui.Button();
            fieldRemoveScript.parent = panelScript;
            fieldRemoveScript.class.add('remove');
            fieldRemoveScript.on('click', function (value) {
                var records = [ ];

                for(var i = 0; i < entities.length; i++) {
                    entities[i].history.enabled = false;
                    var scripts = entities[i].getRaw('components.script.scripts');
                    for(var s = 0; s < scripts.length; s++) {
                        if (scripts[s].get('url') === script.get('url')) {
                            var data = scripts[s].json();

                            records.push({
                                get: entities[i].history._getItemFn,
                                value: data,
                                ind: s
                            });

                            entities[i].remove('components.script.scripts', s);
                            break;
                        }
                    }
                    entities[i].history.enabled = true;
                }

                delete scriptsIndex[script.get('url')];

                if (! records.length)
                    return;

                editor.call('history:add', {
                    name: 'entities.components.script.scripts',
                    undo: function() {
                        for(var i = 0; i < records.length; i++) {
                            var item = records[i].get();
                            if (! item)
                                continue;

                            var scripts = item.getRaw('components.script.scripts');
                            if (! scripts)
                                continue;

                            var addScript = true;

                            for(var s = 0; s < scripts.length; s++) {
                                if (scripts[s].get('url') === records[i].value.url) {
                                    addScript = false;
                                    break;
                                }
                            }

                            if (! addScript)
                                continue;

                            var script = new Observer(records[i].value);

                            item.history.enabled = false;
                            item.insert('components.script.scripts', script, records[i].ind);
                            item.history.enabled = true;
                        }

                        refreshScriptAttributes(records[0].value.url);
                    },
                    redo: function() {
                        for(var i = 0; i < records.length; i++) {
                            var item = records[i].get();
                            if (! item)
                                continue;

                            var scripts = item.getRaw('components.script.scripts');

                            for(var s = 0; s < scripts.length; s++) {
                                if (scripts[s].get('url') !== records[i].value.url)
                                    continue;

                                item.history.enabled = false;
                                item.removeValue('components.script.scripts', scripts[s]);
                                item.history.enabled = true;
                                break;
                            }
                        }

                        delete scriptsIndex[records[0].value.url];
                    }
                });
            });
            panelScript.headerElement.appendChild(fieldRemoveScript.element);

            // TODO
            // allow reordering scripts if all entities scripts components are identical

            // move down
            var fieldMoveDown = new ui.Button();
            fieldMoveDown.class.add('move-down');
            fieldMoveDown.element.title = 'Move script down';
            fieldMoveDown.on('click', function () {
                var scripts = entities[0].getRaw('components.script.scripts');
                var ind = scripts.indexOf(script);
                if (ind < scripts.length - 1)
                    entities[0].move('components.script.scripts', ind, ind + 1);
            });
            panelScript.headerElement.appendChild(fieldMoveDown.element);
            if (entities.length > 1)
                fieldMoveDown.style.visibility = 'hidden';

            // move up
            var fieldMoveUp = new ui.Button();
            fieldMoveUp.class.add('move-up');
            fieldMoveUp.element.title = 'Move script up';
            fieldMoveUp.on('click', function () {
                var ind = entities[0].getRaw('components.script.scripts').indexOf(script);
                if (ind > 0)
                    entities[0].move('components.script.scripts', ind, ind - 1);
            });
            panelScript.headerElement.appendChild(fieldMoveUp.element);
            if (entities.length > 1)
                fieldMoveUp.style.visibility = 'hidden';

            // refresh attributes
            var fieldRefreshAttributes = new ui.Button();
            fieldRefreshAttributes.class.add('refresh');
            fieldRefreshAttributes.element.title = "Refresh script attributes";
            panelScript.headerElement.appendChild(fieldRefreshAttributes.element);

            fieldRefreshAttributes.on('click', function () {
                refreshScriptAttributes(script.get('url'));
            });

            // attributes panel
            var attributes = new ui.Panel();
            panelScript.append(attributes);

            if (script.has('attributesOrder')) {
                // add attributes if has any
                var order = script.get('attributesOrder');
                if (order) {
                    for(var i = 0; i < order.length; i++) {
                        createAttributeField(script, order[i], attributes);
                    }
                }
            }

            var timerUpdateAttributes = null;
            // when attributes order changed, schedule update
            events.push(script.on('attributesOrder:set', function() {
                if (timerUpdateAttributes)
                    return;

                timerUpdateAttributes = setTimeout(function() {
                    timerUpdateAttributes = null;
                    updateAttributeFields(script, attributes);
                }, 0);
            }));

            return panelScript;
        };

        // Converts URL to script name
        var getFilenameFromUrl = function(url) {
            var filename = url;

            if (jsRegex.test(filename))
                filename = filename.substring(0, filename.length - 3);

            var lastIndexOfSlash = filename.lastIndexOf('/');
            if (lastIndexOfSlash >= 0)
                filename = filename.substring(lastIndexOfSlash + 1, filename.length);

            return filename;
        };

        var addScriptPanel = function(script, ind) {
            var panelScript = createScriptPanel(script);
            if (! panelScript)
                return;

            scriptsIndex[script.get('url')] = panelScript;

            var panels = panelScripts.innerElement.childNodes;

            if (ind === undefined || ind === panels.length) {
                // append at the end
                panelScripts.append(panelScript);
            } else {
                // append before panel at next index
                panelScripts.appendBefore(panelScript, panels[ind]);
            }
        };

        // add existing scripts and subscribe to scripts Observer list
        for(var i = 0; i < entities.length; i++) {
            var scripts = entities[i].getRaw('components.script.scripts');

            if (scripts) {
                for(var s = 0; s < scripts.length; s++)
                    addScriptPanel(scripts[s]);
            }

            // subscribe to scripts:set
            events.push(entities[i].on('components.script.scripts:set', function(value, valueOld) {
                for(var i = 0; i < value.length; i++)
                    addScriptPanel(value[i]);
            }));

            // subscribe to scripts:insert
            events.push(entities[i].on('components.script.scripts:insert', function (script, ind) {
                addScriptPanel(script, ind);
            }));

            events.push(entities[i].on('components.script.scripts:move', function (value, indNew, indOld) {
                var elementOld = scriptsIndex[this.get('components.script.scripts.' + indOld + '.url')];
                var elementNew = scriptsIndex[value.get('url')];

                panelScripts.innerElement.removeChild(elementNew.element);

                if (indNew > indOld) {
                    if (elementOld.element.nextSibling) {
                        panelScripts.innerElement.insertBefore(elementNew.element, elementOld.element.nextSibling);
                    } else {
                        panelScripts.innerElement.appendChild(elementNew.element);
                    }
                } else {
                    panelScripts.innerElement.insertBefore(elementNew.element, elementOld.element);
                }
            }));

            // subscribe to scripts:remove
            events.push(entities[i].on('components.script.scripts:remove', function (script, ind) {
                var scriptPanel = scriptsIndex[script.get('url')];
                if (! scriptPanel)
                    return;

                scriptPanel.count--;
                scriptPanel._link.textContent = (scriptPanel.count === entities.length ? '' : '* ') + scriptPanel._originalTitle;

                if (scriptPanel.count === 0) {
                    scriptsIndex[script.get('url')].destroy();
                    script.destroy();
                    delete scriptsIndex[script.get('url')];
                }
            }));
        }

        // drag drop
        var dropRef = editor.call('drop:target', {
            ref: panel.element,
            filter: function(type, data) {
                if (type !== 'asset.script') return false;

                var root = editor.call('layout.root');
                var rectA = root.innerElement.getBoundingClientRect();
                var rectB = panel.element.getBoundingClientRect();
                if (rectB.top > rectA.top && rectB.bottom < rectA.bottom) {
                    for(var i = 0; i < entities.length; i++) {
                        var addScript = true;
                        var scripts = entities[i].getRaw('components.script.scripts');
                        for(var s = 0; s < scripts.length; s++) {
                            if (scripts[s].get('url') === data.filename) {
                                return false;
                            }
                        }
                    }

                    return true;
                }

                return false;

            },
            drop: function(type, data) {
                if (type !== 'asset.script')
                    return;

                addScript(data.filename);
            }
        });

        // clean up events
        panel.once('destroy', function() {
            for(var i = 0; i < events.length; i++)
                events[i].unbind();
        });
    });
});


/* editor/attributes/attributes-asset.js */
(function() {
    'use strict';

    var bytesToHuman = function(bytes) {
        if (isNaN(bytes) || bytes === 0) return '0 B';
        var k = 1000;
        var sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
        var i = Math.floor(Math.log(bytes) / Math.log(k));
        return (bytes / Math.pow(k, i)).toPrecision(3) + ' ' + sizes[i];
    };

    var sourceRuntimeOptions = {
        '-1': 'various',
        '0': 'yes',
        '1': 'no'
    };

    var assetsPanel = null;

    editor.on('attributes:inspect[asset]', function(assets) {
        // unfold panel
        var panel = editor.call('attributes.rootPanel');
        if (panel.folded)
            panel.folded = false;

        var asset = assets[0];
        var multi = assets.length > 1;
        var type = ((asset.get('source') && asset.get('type') !== 'folder') ? 'source ' : '') + asset.get('type');

        if (multi) {
            editor.call('attributes:header', assets.length + ' assets');

            for(var i = 0; i < assets.length; i++) {
                if (type !== ((asset.get('source') && asset.get('type') !== 'folder') ? 'source ' : '') + assets[i].get('type')) {
                    type = null;
                    break;
                }
            }
        } else {
            editor.call('attributes:header', type);
        }

        // panel
        var panel = editor.call('attributes:addPanel');
        panel.class.add('component');
        assetsPanel = panel;
        panel.once('destroy', function () {
            assetsPanel = null;
        });

        if (multi) {
            var fieldFilename = editor.call('attributes:addField', {
                parent: panel,
                name: 'Assets',
                value: assets.length
            });

            // size
            var size = 0;
            var scriptSelected = false;

            for(var i = 0; i < assets.length; i++) {
                size += assets[i].get('file.size') || 0;

                // scripts are not real assets, and have no preload option
                if (! scriptSelected && assets[i].get('type') === 'script')
                    scriptSelected = true;
            }

            var source = (assets[0].get('type') === 'folder') ? 1 : assets[0].get('source') + 0;

            for(var i = 1; i < assets.length; i++) {
                if ((assets[i].get('type') === 'folder' ? 1 : assets[i].get('source') + 0) !== source) {
                    source = -1;
                    break;
                }
            }

            if (! scriptSelected && source === 0) {
                // tags
                var fieldTags = editor.call('attributes:addField', {
                    parent: panel,
                    name: 'Tags',
                    placeholder: 'Add Tag',
                    type: 'strings',
                    link: assets,
                    path: 'tags'
                });
                // reference
                editor.call('attributes:reference:asset:tags:attach', fieldTags.parent.innerElement.firstChild.ui);
            }

            // runtime
            var fieldRuntime = editor.call('attributes:addField', {
                parent: panel,
                name: 'Runtime',
                value: sourceRuntimeOptions[source]
            });
            // reference
            editor.call('attributes:reference:asset:runtime:attach', fieldRuntime.parent.innerElement.firstChild.ui);

            // type
            var fieldType = editor.call('attributes:addField', {
                parent: panel,
                name: 'Type',
                value: type ? type : 'various'
            });
            // reference
            editor.call('attributes:reference:asset:type:attach', fieldType.parent.innerElement.firstChild.ui);
            if (type)
                editor.call('attributes:reference:asset:' + type + ':asset:attach', fieldType);

            // size
            var fieldSize = editor.call('attributes:addField', {
                parent: panel,
                name: 'Size',
                value: bytesToHuman(size)
            });

            var evtSize = [ ];
            for(var i = 0; i < assets.length; i++) {
                evtSize.push(asset.on('file:set', function (value, valueOld) {
                    size = size - ((valueOld && valueOld.size) || 0) + ((value && value.size) || 0);
                    fieldSize.text = bytesToHuman(size);
                }));

                evtSize.push(asset.on('file.size:set', function(value, valueOld) {
                    size = size - (valueOld || 0) + (value || 0);
                    fieldSize.text = bytesToHuman(size);
                }));
            }

            panel.once('destroy', function () {
                for(var i = 0; i < evtSize.length; i++) {
                    evtSize[i].unbind();
                }
            });

            // reference
            editor.call('attributes:reference:asset:size:attach', fieldSize.parent.innerElement.firstChild.ui);

            if (! scriptSelected && source === 0) {
                var fieldPreload = editor.call('attributes:addField', {
                    parent: panel,
                    name: 'Preload',
                    type: 'checkbox',
                    link: assets,
                    path: 'preload'
                });
                editor.call('attributes:reference:asset:preload:attach', fieldPreload.parent.innerElement.firstChild.ui);
            }

        } else {
            if (asset.get('type') === 'script') {
                // filename
                var fieldFilename = editor.call('attributes:addField', {
                    parent: panel,
                    name: 'Filename',
                    // type: 'string',
                    link: asset,
                    path: 'filename'
                });
                // reference
                editor.call('attributes:reference:asset:script:filename:attach', fieldFilename.parent.innerElement.firstChild.ui);
            } else {
                // id
                var fieldId = editor.call('attributes:addField', {
                    parent: panel,
                    name: 'ID',
                    link: asset,
                    path: 'id'
                });
                // reference
                editor.call('attributes:reference:asset:id:attach', fieldId.parent.innerElement.firstChild.ui);

                // name
                var fieldName = editor.call('attributes:addField', {
                    parent: panel,
                    name: 'Name',
                    type: 'string',
                    link: asset,
                    path: 'name'
                });
                // reference
                editor.call('attributes:reference:asset:name:attach', fieldName.parent.innerElement.firstChild.ui);

                if (! asset.get('source') && asset.get('type') !== 'folder') {
                    // tags
                    var fieldTags = editor.call('attributes:addField', {
                        parent: panel,
                        name: 'Tags',
                        placeholder: 'Add Tag',
                        type: 'strings',
                        link: asset,
                        path: 'tags'
                    });
                    // reference
                    editor.call('attributes:reference:asset:tags:attach', fieldTags.parent.innerElement.firstChild.ui);
                }

                // runtime
                var runtime = sourceRuntimeOptions[asset.get('source') + 0];
                if (asset.get('type') === 'folder')
                    runtime = sourceRuntimeOptions[1];

                var fieldRuntime = editor.call('attributes:addField', {
                    parent: panel,
                    name: 'Runtime',
                    value: runtime
                });
                // reference
                editor.call('attributes:reference:asset:runtime:attach', fieldRuntime.parent.innerElement.firstChild.ui);

                // type
                var fieldType = editor.call('attributes:addField', {
                    parent: panel,
                    name: 'Type',
                    value: type
                });
                // reference
                editor.call('attributes:reference:asset:type:attach', fieldType.parent.innerElement.firstChild.ui);
                // reference type
                if (! asset.get('source'))
                    editor.call('attributes:reference:asset:' + asset.get('type') + ':asset:attach', fieldType);

                if (! asset.get('source') && asset.get('type') !== 'folder') {
                    // preload
                    var fieldPreload = editor.call('attributes:addField', {
                        parent: panel,
                        name: 'Preload',
                        type: 'checkbox',
                        link: asset,
                        path: 'preload'
                    });
                    editor.call('attributes:reference:asset:preload:attach', fieldPreload.parent.innerElement.firstChild.ui);
                }
            }

            // size
            if (asset.has('file')) {
                var fieldSize = editor.call('attributes:addField', {
                    parent: panel,
                    name: 'Size',
                    value: bytesToHuman(asset.get('file.size'))
                });

                var evtFileSet = asset.on('file:set', function (value) {
                    fieldSize.text = bytesToHuman(value ? value.size : 0);
                });

                var evtFileSizeSet = asset.on('file.size:set', function(value) {
                    fieldSize.text = bytesToHuman(value);
                });

                panel.once('destroy', function () {
                    evtFileSet.unbind();
                    evtFileSizeSet.unbind();
                });

                // reference
                editor.call('attributes:reference:asset:size:attach', fieldSize.parent.innerElement.firstChild.ui);
            }

            if (! asset.get('source') && asset.get('type') === 'model' && (! config.project.privateAssets || (config.project.privateAssets && editor.call('permissions:read')))) {
                // export archive
                var fieldExport = editor.call('attributes:addField', {
                    parent: panel,
                    name: 'Export',
                    value: 'archive'
                });
                fieldExport.flexGrow = 'initial';
                fieldExport.class.add('export-model-archive');
                fieldExport.on('click', function() {
                    window.open('/api/assets/' + asset.get('id') + '/download_model?access_token=' + config.accessToken);
                });
            }
        }
    });

    editor.on('attributes:assets:toggleInfo', function (enabled) {
        if (assetsPanel) {
            assetsPanel.hidden = !enabled;
        }
    });
})();


/* editor/attributes/assets/attributes-asset-animation.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[asset]', function(assets) {
        if (assets.length !== 1 || assets[0].get('type') !== 'animation' || assets[0].get('source'))
            return;

        var asset = assets[0];

        // panel
        var panel = editor.call('attributes:addPanel', {
            name: 'Animation'
        });
        panel.class.add('component');
        // reference
        editor.call('attributes:reference:asset:animation:asset:attach', panel, panel.headerElement);


        // duration
        var fieldDuration = editor.call('attributes:addField', {
            parent: panel,
            name: 'Duration',
            placeholder: 'Seconds',
            link: asset,
            path: 'meta.duration'
        });
        // reference
        editor.call('attributes:reference:asset:animation:duration:attach', fieldDuration.parent.innerElement.firstChild.ui);


        // name
        var fieldName = editor.call('attributes:addField', {
            parent: panel,
            name: 'Name',
            link: asset,
            path: 'meta.name'
        });
        // reference
        editor.call('attributes:reference:asset:animation:name:attach', fieldName.parent.innerElement.firstChild.ui);
    });
});


/* editor/attributes/assets/attributes-asset-audio.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[asset]', function(assets) {
        if (assets.length !== 1 || assets[0].get('type') !== 'audio' || assets[0].get('source'))
            return;

        var asset = assets[0];

        var panel = editor.call('attributes:addPanel', {
            name: 'Audio'
        });
        panel.class.add('component');
        // reference
        editor.call('attributes:reference:asset:audio:asset:attach', panel, panel.headerElement);


        // duration
        var fieldDuration = editor.call('attributes:addField', {
            parent: panel,
            name: 'Duration',
            value: '...'
        });
        fieldDuration.renderChanges = false;


        var playing = null;
        var updateTimeline = function() {
            timeline.progress = audio.currentTime / audio.duration;
        };


        // audio
        var audio = new Audio();
        audio.src = config.url.home + asset.get('file.url');
        panel.append(audio);


        // play
        var btnPlay = new ui.Button({
            text: '&#57649;'
        });
        btnPlay.disabled = true;
        btnPlay.class.add('audio-play');
        btnPlay.on('click', function() {
            if (audio.paused) {
                audio.play();
            } else {
                audio.pause();
                audio.currentTime = 0;
            }
        });
        panel.append(btnPlay);


        // timeline
        var timeline = new ui.Progress();
        timeline.class.add('audio-timeline');
        timeline.progress = 1;
        timeline.speed = .9;
        panel.append(timeline);


        // duration information available
        audio.addEventListener('durationchange', function(evt) {
            fieldDuration.text = audio.duration.toFixed(2) + 's';
        }, false);

        // can be played
        audio.addEventListener('canplay', function(evt) {
            btnPlay.enabled = true;
            timeline.progress = 0;
        }, false);

        // on play
        audio.addEventListener('play', function() {
            btnPlay.class.add('active');
            btnPlay.text = '&#57649;';

            if (playing)
                return;

            playing = setInterval(updateTimeline, 1000 / 60);
        }, false);

        // on stop
        audio.addEventListener('pause', function() {
            timeline.progress = 0;
            btnPlay.class.remove('active');
            btnPlay.text = '&#57649;';

            clearInterval(playing);
            playing = null;
        }, false);


        panel.once('destroy', function() {
            clearInterval(playing);
        });
    });
});


/* editor/attributes/assets/attributes-asset-css.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[asset]', function(assets) {
        if (assets.length !== 1 || assets[0].get('type') !== 'css' || assets[0].get('source'))
            return;

        var asset = assets[0];

        // panel
        var panel = editor.call('attributes:addPanel');
        panel.class.add('component');

        // edit
        var btnEdit = new ui.Button();
        btnEdit.text = editor.call('permissions:write') ? 'Edit' : 'View';
        btnEdit.class.add('edit-script');
        btnEdit.hidden = ! asset.has('file.url');
        btnEdit.element.addEventListener('click', function(evt) {
            window.open('/editor/asset/' + asset.get('id'));
        }, false);
        panel.append(btnEdit);
        var evtFileUrl = asset.on('file.url:set', function() {
            btnEdit.hidden = false;
        });
        var evtFileUrlUnset = asset.on('file.url:unset', function() {
            btnEdit.hidden = true;
        });

        var panelRaw = editor.call('attributes:addPanel', {
            name: 'CSS'
        });
        panelRaw.class.add('component');
        // reference
        editor.call('attributes:reference:asset:css:asset:attach', panelRaw, panelRaw.headerElement);

        // loading
        var loading = editor.call('attributes:addField', {
            type: 'progress'
        });
        loading.progress = 1;

        // code
        var fieldCode = editor.call('attributes:addField', {
            parent: panelRaw,
            type: 'code'
        });
        fieldCode.style.margin = '-8px -6px';

        var fieldError = new ui.Label({
            text: 'failed loading data'
        });
        fieldError.class.add('asset-loading-error');
        fieldError.hidden = true;
        editor.call('attributes.rootPanel').append(fieldError);

        var loadContent = function() {
            if (asset.get('file.size') > 128 * 1024) {
                panelRaw.hidden = true;
                loading.hidden = true;
                return;
            } else {
                panelRaw.hidden = false;
                loading.hidden = false;
            }
            // load data
            new AjaxRequest({
                url: '{{url.home}}/' + asset.get('file.url') + '?t=' + asset.get('file.hash'),
                notJson: true
            })
            .on('load', function(status, data) {
                fieldCode.text = data;
                fieldCode.hidden = false;
                fieldError.hidden = true;
                loading.hidden = true;
            })
            .on('error', function() {
                loading.hidden = false;
                loading.failed = true;
                fieldCode.hidden = true;
                fieldError.hidden = false;
            });
        };
        if (asset.has('file.url'))
            loadContent();

        var evtReload = asset.on('file.hash:set', function() {
            loadContent();
        });
        panel.once('destroy', function() {
            evtReload.unbind();
            evtFileUrl.unbind();
            evtFileUrlUnset.unbind();
        });
    });
});


/* editor/attributes/assets/attributes-asset-cubemap.js */
editor.once('load', function() {
    'use strict';


    editor.on('attributes:inspect[asset]', function(assets) {
        for(var i = 0; i < assets.length; i++) {
            if (assets[i].get('type') !== 'cubemap')
                return;
        }

        if (assets.length > 1)
            editor.call('attributes:header', assets.length + ' CubeMaps');

        // properties panel
        var paramsPanel = editor.call('attributes:addPanel', {
            name: 'CubeMap'
        });
        paramsPanel.class.add('component');
        // reference
        editor.call('attributes:reference:asset:cubemap:asset:attach', paramsPanel, paramsPanel.headerElement);



        // filtering
        var fieldFiltering = editor.call('attributes:addField', {
            parent: paramsPanel,
            name: 'Filtering',
            type: 'string',
            enum: {
                '': '...',
                'nearest': 'Point',
                'linear': 'Linear'
            }
        });
        // reference
        editor.call('attributes:reference:asset:texture:filtering:attach', fieldFiltering.parent.innerElement.firstChild.ui);

        var isPrefiltered = false;
        for(var i = 0; i < assets.length; i++) {
            if (!! assets[i].get('file')) {
                isPrefiltered = true;
                break;
            }
        }

        var changingFiltering = false;

        var updateFiltering = function() {
            var value = '';
            var valueDifferent = false;
            var filter = assets[0].get('data.minFilter') + '_' + assets[0].get('data.magFilter');

            for(var i = 1; i < assets.length; i++) {
                if (filter !== (assets[i].get('data.minFilter') + '_' + assets[i].get('data.magFilter'))) {
                    valueDifferent = true;
                    break;
                }
            }

            if (! valueDifferent) {
                if (assets[0].get('data.minFilter') === 5 && assets[0].get('data.magFilter') === 1) {
                    value = 'linear';
                } else if (assets[0].get('data.minFilter') === 2 && assets[0].get('data.magFilter') === 0) {
                    value = 'nearest';
                }
            }

            if (! valueDifferent && value) {
                fieldFiltering.optionElements[''].style.display = 'none';
            } else {
                fieldFiltering.optionElements[''].style.display = '';
            }

            changingFiltering = true;
            fieldFiltering.value = value;
            changingFiltering = false;
        };
        updateFiltering();

        fieldFiltering.on('change', function(value) {
            if (changingFiltering)
                return;

            var values = [ ];
            var valueMin = value === 'nearest' ? 2 : 5;
            var valueMag = value === 'nearest' ? 0 : 1;

            changingFiltering = true;
            for(var i = 0; i < assets.length; i++) {
                values.push({
                    id: assets[i].get('id'),
                    valueMin: assets[i].get('data.minFilter'),
                    valueMag: assets[i].get('data.magFilter')
                });
                assets[i].history.enabled = false;
                assets[i].set('data.minFilter', valueMin);
                assets[i].set('data.magFilter', valueMag);
                assets[i].history.enabled = true;
            }
            changingFiltering = false;

            fieldFiltering.optionElements[''].style.display = 'none';

            // history
            editor.call('history:add', {
                name: 'assets.filtering',
                undo: function() {
                    for(var i = 0; i < values.length; i++) {
                        var asset = editor.call('assets:get', values[i].id);
                        if (! asset)
                            continue;

                        asset.history.enabled = false;
                        asset.set('data.minFilter', values[i].valueMin);
                        asset.set('data.magFilter', values[i].valueMag);
                        asset.history.enabled = true;
                    }
                },
                redo: function() {
                    for(var i = 0; i < values.length; i++) {
                        var asset = editor.call('assets:get', values[i].id);
                        if (! asset)
                            continue;

                        asset.history.enabled = false;
                        asset.set('data.minFilter', valueMin);
                        asset.set('data.magFilter', valueMag);
                        asset.history.enabled = true;
                    }
                }
            });
        });

        var eventsFiltering = [ ];
        var changingQueued = false;
        var changedFiltering = function() {
            if (changingQueued || changingFiltering)
                return;

            changingQueued = true;
            setTimeout(function() {
                changingQueued = false;
                updateFiltering();
            }, 0);
        };
        for(var i = 0; i < assets.length; i++) {
            eventsFiltering.push(assets[i].on('data.minFilter:set', changedFiltering));
            eventsFiltering.push(assets[i].on('data.magFilter:set', changedFiltering));
        }
        fieldFiltering.once('destroy', function() {
            for(var i = 0; i < eventsFiltering.length; i++) {
                eventsFiltering[i].unbind();
            }
        });



        // anisotropy
        var fieldAnisotropy = editor.call('attributes:addField', {
            parent: paramsPanel,
            name: 'Anisotropy',
            type: 'number',
            link: assets,
            path: 'data.anisotropy'
        });
        // reference
        editor.call('attributes:reference:asset:cubemap:anisotropy:attach', fieldAnisotropy.parent.innerElement.firstChild.ui);



        if (assets.length === 1) {
            // preview
            var previewPanel = editor.call('attributes:addPanel', {
                name: 'Preview'
            });
            previewPanel.class.add('cubemap-viewport', 'component');
            // reference
            editor.call('attributes:reference:asset:cubemap:slots:attach', previewPanel, previewPanel.headerElement);


            // faces
            var sides = {
                2: 'top',
                1: 'left',
                4: 'front',
                0: 'right',
                5: 'back',
                3: 'bottom'
            };
            var side = [ 2, 1, 4, 0, 5, 3 ];
            var faces = [ ];

            // set face texture
            var setTexture = function(face, assetId) {
                if (! assetId) {
                    face.style.backgroundImage = '';
                    face.classList.add('empty');
                } else {
                    var texture = editor.call('assets:get', assetId);
                    if (texture && texture.get('type') === 'texture' && (texture.get('thumbnails.l') || texture.get('file.url'))) {
                        face.classList.remove('empty');
                        face.style.backgroundImage = 'url("' + config.url.home + '/' + (texture.get('thumbnails.l') || texture.get('file.url')) + '")';
                    } else {
                        face.classList.add('empty');
                        face.style.backgroundImage = '';
                    }
                }
            };

            var setAssetFace = function (face, texture) {
                var prevFace = assets[0].get('data.textures.' + face);
                var assetId = assets[0].get('id');
                var textureId = texture ? parseInt(texture.get('id'), 10) : null;

                var setRgbmIfNeeded = function (asset) {
                    var allHdr = true;
                    var textures = asset.get('data.textures');
                    for (var i = 0; i < textures.length; i++) {
                        if (textures[i] >= 0) {
                            var texture = editor.call('assets:get', textures[i]);
                            if (texture && !texture.get('data.rgbm')) {
                                allHdr = false;
                                break;
                            }
                        }
                    }

                    if (allHdr)  {
                        asset.set('data.rgbm', true);
                    } else {
                        asset.unset('data.rgbm');
                    }
                };

                var action = {
                    name: 'asset.' + assetId + '.face.' + face,
                    combine: false,
                    undo: function () {
                        var a = editor.call('assets:get', assetId);
                        if (!a) return;

                        var history = a.history.enabled;
                        a.history.enabled = false;
                        a.set('data.textures.' + face, prevFace);
                        setRgbmIfNeeded(a);
                        a.history.enabled = history;
                    },
                    redo: function () {
                        var a = editor.call('assets:get', assetId);
                        if (!a) return;

                        var history = a.history.enabled;
                        a.history.enabled = false;
                        a.set('data.textures.' + face, textureId);
                        // invalidate prefiltered data
                        // if (a.get('file')) a.set('file', null)
                        setRgbmIfNeeded(a);
                        a.history.enabled = history;
                    }
                };

                action.redo();

                assets[0].history.emit('record', 'add', action);
            };

            // create eface
            var createFace = function(ind) {
                // create face element
                var face = faces[ind] = document.createElement('div');
                face.classList.add('face', 'face-' + sides[ind]);
                previewPanel.append(face);

                var name = document.createElement('div');
                name.classList.add('face-name');
                name.innerHTML = sides[ind];
                face.appendChild(name);

                // on face click
                face.addEventListener('click', function() {
                    if (! editor.call('permissions:write'))
                        return;

                    var texture = editor.call('assets:get', assets[0].get('data.textures.' + ind));
                    editor.call('picker:asset', 'texture', texture);

                    var evtPick = editor.once('picker:asset', function(texture) {
                        // clear prefiltered data
                        setAssetFace(ind, texture);
                        evtPick = null;
                    });

                    editor.once('picker:asset:close', function() {
                        if (evtPick) {
                            evtPick.unbind();
                            evtPick = null;
                        }
                    });
                }, false);

                var dropRef = editor.call('drop:target', {
                    ref: face,
                    type: 'asset.texture',
                    drop: function(type, data) {
                        if (type !== 'asset.texture')
                            return;

                        setAssetFace(ind, editor.call('assets:get', parseInt(data.id, 10)));
                    }
                });
                previewPanel.on('destroy', function() {
                    dropRef.unregister();
                });

                // clear button
                var faceClear = document.createElement('div');
                faceClear.classList.add('clear');
                face.appendChild(faceClear);

                // on clear click
                faceClear.addEventListener('click', function(evt) {
                    if (! editor.call('permissions:write'))
                        return;

                    evt.stopPropagation();
                    setAssetFace(ind, null);
                    face.classList.add('empty');
                }, false);

                // load texture asset
                setTexture(face, assets[0].get('data.textures.' + ind));

                // bind to changes
                face.evt = assets[0].on('data.textures.' + ind + ':set', function(value) {
                    clearPrefiltered();
                    setTexture(face, value);
                    prefilterPanel.hidden = !hasAllTextures();
                });
            };

            // create all faces
            for(var i = 0; i < side.length; i++)
                createFace(side[i]);

            // on destroy
            previewPanel.on('destroy', function() {
                // unbind events
                for(var i = 0; i < faces.length; i++)
                    faces[i].evt.unbind();
            });

            // prefiltering
            var prefilterPanel = editor.call('attributes:addPanel', {
                name: 'Prefiltering'
            });
            prefilterPanel.class.add('component');
            // reference
            editor.call('attributes:reference:asset:cubemap:prefilter:attach', prefilterPanel, prefilterPanel.headerElement);

            // prefilter button
            var prefilterBtn = new ui.Button({
                text: 'Prefilter',
            });

            prefilterPanel.append(prefilterBtn);

            prefilterBtn.on('click', function () {
                // disable while prefiltering
                prefilterBtn.disabled = true;
                editor.call('assets:cubemaps:prefilter', assets[0], function (err) {
                    // re-enable button
                    if (err)
                        return editor.call('status:error', err);

                    prefilterBtn.disabled = true;
                });
            });

            // delete prefiltered data button
            var clearPrefilteredBtn = new ui.Button({
                text: 'Delete Prefiltered Data',
            });

            prefilterPanel.append(clearPrefilteredBtn);

            var clearPrefiltered = function () {
                editor.call('realtime:send', 'cubemap:clear:', parseInt(assets[0].get('id'), 10));
            };

            clearPrefilteredBtn.on('click', clearPrefiltered);

            var evtFileChange = assets[0].on('file:set', function (value) {
                prefilterBtn.disabled = false;
                togglePrefilterFields(!!value);
            });

            prefilterPanel.once('destroy', function () {
                evtFileChange.unbind();
            });

            var hasAllTextures = function () {
                var textures = assets[0].get('data.textures');
                if (! textures || textures.length !== 6)
                    return false;

                for (var i = 0; i < 6; i++) {
                    if (isNaN(parseInt(textures[i], 10)))
                        return false;
                }

                return true;
            };

            // show prefilter button or clear prefiltering button depending
            // on current cubemap 'file' field
            var togglePrefilterFields = function (isPrefiltered) {
                prefilterPanel.hidden = ! hasAllTextures();
                prefilterBtn.hidden = isPrefiltered;
                prefilterBtn.disabled = !! assets[0].get('task');
                clearPrefilteredBtn.hidden = ! isPrefiltered;
            };

            togglePrefilterFields(!!assets[0].get('file'));
        }
    });
});


/* editor/attributes/assets/attributes-asset-html.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[asset]', function(assets) {
        if (assets.length !== 1 || assets[0].get('type') !== 'html' || assets[0].get('source'))
            return;

        var asset = assets[0];

        // panel
        var panel = editor.call('attributes:addPanel');
        panel.class.add('component');

        // edit
        var btnEdit = new ui.Button();
        btnEdit.text = editor.call('permissions:write') ? 'Edit' : 'View';
        btnEdit.class.add('edit-script');
        btnEdit.hidden = ! asset.has('file.url');
        btnEdit.element.addEventListener('click', function(evt) {
            window.open('/editor/asset/' + asset.get('id'));
        }, false);
        panel.append(btnEdit);
        var evtFileUrl = asset.on('file.url:set', function() {
            btnEdit.hidden = false;
        });
        var evtFileUrlUnset = asset.on('file.url:unset', function() {
            btnEdit.hidden = true;
        });

        var panelRaw = editor.call('attributes:addPanel', {
            name: 'HTML'
        });
        panelRaw.class.add('component');
        // reference
        editor.call('attributes:reference:asset:html:asset:attach', panelRaw, panelRaw.headerElement);

        // loading
        var loading = editor.call('attributes:addField', {
            type: 'progress'
        });
        loading.progress = 1;

        // code
        var fieldCode = editor.call('attributes:addField', {
            parent: panelRaw,
            type: 'code'
        });
        fieldCode.style.margin = '-8px -6px';

        var fieldError = new ui.Label({
            text: 'failed loading data'
        });
        fieldError.class.add('asset-loading-error');
        fieldError.hidden = true;
        editor.call('attributes.rootPanel').append(fieldError);

        var loadContent = function() {
            if (asset.get('file.size') > 128 * 1024) {
                panelRaw.hidden = true;
                loading.hidden = true;
                return;
            } else {
                panelRaw.hidden = false;
                loading.hidden = false;
            }
            // load data
            new AjaxRequest({
                url: '{{url.home}}/' + asset.get('file.url') + '?t=' + asset.get('file.hash'),
                notJson: true
            })
            .on('load', function(status, data) {
                fieldCode.text = data;
                fieldCode.hidden = false;
                fieldError.hidden = true;
                loading.hidden = true;
            })
            .on('error', function() {
                loading.hidden = false;
                loading.failed = true;
                fieldCode.hidden = true;
                fieldError.hidden = false;
            });
        };
        if (asset.has('file.url'))
            loadContent();

        var evtReload = asset.on('file.hash:set', function() {
            loadContent();
        });
        panel.once('destroy', function() {
            evtReload.unbind();
            evtFileUrl.unbind();
            evtFileUrlUnset.unbind();
        });
    });
});


/* editor/attributes/assets/attributes-asset-json.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[asset]', function(assets) {
        if (assets.length !== 1 || assets[0].get('type') !== 'json' || assets[0].get('source'))
            return;

        var asset = assets[0];

        // panel
        var panel = editor.call('attributes:addPanel');
        panel.class.add('component');

        // edit
        var btnEdit = new ui.Button();
        btnEdit.text = editor.call('permissions:write') ? 'Edit' : 'View';
        btnEdit.class.add('edit-script');
        btnEdit.hidden = ! asset.has('file.url');
        btnEdit.element.addEventListener('click', function(evt) {
            window.open('/editor/asset/' + asset.get('id'));
        }, false);
        panel.append(btnEdit);
        var evtFileUrl = asset.on('file.url:set', function() {
            btnEdit.hidden = false;
        });
        var evtFileUrlUnset = asset.on('file.url:unset', function() {
            btnEdit.hidden = true;
        });

        var panelRaw = editor.call('attributes:addPanel', {
            name: 'JSON'
        });
        panelRaw.class.add('component');
        // reference
        editor.call('attributes:reference:asset:json:asset:attach', panelRaw, panelRaw.headerElement);

        // loading
        var loading = editor.call('attributes:addField', {
            type: 'progress'
        });
        loading.progress = 1;

        // code
        var fieldCode = editor.call('attributes:addField', {
            parent: panelRaw,
            type: 'code'
        });
        fieldCode.style.margin = '-8px -6px';

        var fieldError = new ui.Label({
            text: 'failed loading data'
        });
        fieldError.class.add('asset-loading-error');
        fieldError.hidden = true;
        editor.call('attributes.rootPanel').append(fieldError);

        var loadContent = function() {
            if (asset.get('file.size') > 128 * 1024) {
                panelRaw.hidden = true;
                loading.hidden = true;
                return;
            } else {
                panelRaw.hidden = false;
                loading.hidden = false;
            }
            // load data
            Ajax
            .get('{{url.home}}/' + asset.get('file.url') + '?t=' + asset.get('file.hash'))
            .on('load', function(status, data) {
                fieldCode.text = JSON.stringify(data, null, 4);
                fieldCode.hidden = false;
                fieldError.hidden = true;
                loading.hidden = true;
            })
            .on('error', function() {
                loading.hidden = false;
                loading.failed = true;
                fieldCode.hidden = true;
                fieldError.hidden = false;
            });
        };
        if (asset.has('file.url'))
            loadContent();

        var evtReload = asset.on('file.hash:set', function() {
            loadContent();
        });
        panel.once('destroy', function() {
            evtReload.unbind();
            evtFileUrl.unbind();
            evtFileUrlUnset.unbind();
        });
    });
});


/* editor/attributes/assets/attributes-asset-material.js */
editor.once('load', function() {
    'use strict';

    var mappingTypes = {
        'int': 'float',
        'rgb': 'vec3'
    };

    var mapping = {
        ambient: {
            'default': [ 0, 0, 0 ],
            'type': 'rgb',
        },
        ambientTint: {
            'default': false,
            'type': 'boolean',
        },
        aoMap: {
            'default': 0,
            'type': 'texture',
        },
        aoMapVertexColor: {
            'default': false,
            'type': 'boolean',
        },
        aoMapChannel: {
            'default': 'r',
            'type': 'string'
        },
        aoMapUv: {
            'default': 0,
            'type': 'int',
            'enum': [
                { v: '', t: '...' },
                { v: 0, t: 'UV0' },
                { v: 1, t: 'UV1' }
            ]
        },
        aoMapTiling: {
            'default': [ 1, 1 ],
            'type': 'vec2',
        },
        aoMapOffset: {
            'default': [ 0, 0 ],
            'type': 'vec2',
        },
        occludeSpecular: {
            'default': true,
            'type': 'boolean'
        },
        diffuse: {
            'default': [ 1, 1, 1 ],
            'type': 'rgb',
        },
        diffuseMap: {
            'default': 0,
            'type': 'texture',
        },
        diffuseMapVertexColor: {
            'default': false,
            'type': 'boolean',
        },
        diffuseMapChannel: {
            'default': 'rgb',
            'type': 'string'
        },
        diffuseMapUv: {
            'default': 0,
            'type': 'int',
            'enum': [
                { v: '', t: '...' },
                { v: 0, t: 'UV0' },
                { v: 1, t: 'UV1' }
            ]
        },
        diffuseMapTiling: {
            'default': [ 1, 1 ],
            'type': 'vec2',
        },
        diffuseMapOffset: {
            'default': [ 0, 0 ],
            'type': 'vec2',
        },
        diffuseMapTint: {
            'default': false,
            'type': 'boolean',
        },
        specular: {
            'default': [ .23, .23, .23 ],
            'type': 'rgb',
        },
        specularMapVertexColor: {
            'default': false,
            'type': 'boolean',
        },
        specularMapChannel: {
            'default': 'rgb',
            'type': 'string'
        },
        specularMapUv: {
            'default': 0,
            'type': 'int',
            'enum': [
                { v: '', t: '...' },
                { v: 0, t: 'UV0' },
                { v: 1, t: 'UV1' }
            ]
        },
        specularMap: {
            'default': 0,
            'type': 'texture',
        },
        specularMapTiling: {
            'default': [ 1, 1 ],
            'type': 'vec2',
        },
        specularMapOffset: {
            'default': [ 0, 0 ],
            'type': 'vec2',
        },
        specularMapTint: {
            'default': false,
            'type': 'boolean',
        },
        specularAntialias: {
            'default': true,
            'type': 'boolean',
        },
        useMetalness: {
            'default': false,
            'type': 'boolean',
        },
        metalnessMap: {
            'default': 0,
            'type': 'texture',
        },
        metalnessMapVertexColor: {
            'default': false,
            'type': 'boolean',
        },
        metalnessMapChannel: {
            'default': 'r',
            'type': 'string'
        },
        metalnessMapUv: {
            'default': 0,
            'type': 'int',
            'enum': [
                { v: '', t: '...' },
                { v: 0, t: 'UV0' },
                { v: 1, t: 'UV1' }
            ]
        },
        metalnessMapTiling: {
            'default': [ 1, 1 ],
            'type': 'vec2',
        },
        metalnessMapOffset: {
            'default': [ 0, 0 ],
            'type': 'vec2',
        },
        metalnessMapTint: {
            'default': false,
            'type': 'boolean',
        },
        metalness: {
            'default': 1,
            'min': 0,
            'max': 1,
            'type': 'float',
        },
        conserveEnergy: {
            'default': true,
            'type': 'boolean',
        },
        shininess: {
            'default': 32,
            'min': 0,
            'max': 100,
            'type': 'float',
        },
        glossMap: {
            'default': 0,
            'type': 'texture',
        },
        glossMapVertexColor: {
            'default': false,
            'type': 'boolean',
        },
        glossMapChannel: {
            'default': 'r',
            'type': 'string'
        },
        glossMapUv: {
            'default': 0,
            'type': 'int',
            'enum': [
                { v: '', t: '...' },
                { v: 0, t: 'UV0' },
                { v: 1, t: 'UV1' }
            ]
        },
        glossMapTiling: {
            'default': [ 1, 1 ],
            'type': 'vec2',
        },
        glossMapOffset: {
            'default': [ 0, 0 ],
            'type': 'vec2',
        },
        fresnelModel: {
            'default': 0,
            'type': 'float',
        },
        fresnelFactor: {
            'default': 0,
            'type': 'float',
        },
        emissive: {
            'default': [ 0, 0, 0 ],
            'type': 'rgb',
        },
        emissiveMap: {
            'default': 0,
            'type': 'texture',
        },
        emissiveMapVertexColor: {
            'default': false,
            'type': 'boolean',
        },
        emissiveMapChannel: {
            'default': 'rgb',
            'type': 'string'
        },
        emissiveMapUv: {
            'default': 0,
            'type': 'int',
            'enum': [
                { v: '', t: '...' },
                { v: 0, t: 'UV0' },
                { v: 1, t: 'UV1' }
            ]
        },
        emissiveMapTiling: {
            'default': [ 1, 1 ],
            'type': 'vec2',
        },
        emissiveMapOffset: {
            'default': [ 0, 0 ],
            'type': 'vec2',
        },
        emissiveMapTint: {
            'default': false,
            'type': 'boolean',
        },
        emissiveIntensity: {
            'default': 1,
            'min': 0,
            'max': 10,
            'type': 'float'
        },
        normalMap: {
            'default': 0,
            'type': 'texture',
        },
        normalMapTiling: {
            'default': [ 1, 1 ],
            'type': 'vec2',
        },
        normalMapOffset: {
            'default': [ 0, 0 ],
            'type': 'vec2',
        },
        normalMapUv: {
            'default': 0,
            'type': 'int',
            'enum': [
                { v: '', t: '...' },
                { v: 0, t: 'UV0' },
                { v: 1, t: 'UV1' }
            ]
        },
        bumpMapFactor: {
            'default': 1,
            'type': 'float',
        },
        heightMap: {
            'default': 0,
            'type': 'texture',
        },
        heightMapChannel: {
            'default': 'r',
            'type': 'string'
        },
        heightMapUv: {
            'default': 0,
            'type': 'int',
            'enum': [
                { v: '', t: '...' },
                { v: 0, t: 'UV0' },
                { v: 1, t: 'UV1' }
            ]
        },
        heightMapTiling: {
            'default': [ 1, 1 ],
            'type': 'vec2',
        },
        heightMapOffset: {
            'default': [ 0, 0 ],
            'type': 'vec2',
        },
        heightMapFactor: {
            'default': 1,
            'min': 0,
            'max': 2,
            'type': 'float'
        },
        alphaTest: {
            'default': 0,
            'min': 0,
            'max': 1,
            'type': 'float'
        },
        opacity: {
            'default': 1,
            'min': 0,
            'max': 1,
            'type': 'float',
        },
        opacityMap: {
            'default': 0,
            'type': 'texture',
        },
        opacityMapVertexColor: {
            'default': false,
            'type': 'boolean',
        },
        opacityMapChannel: {
            'default': 'r',
            'type': 'string'
        },
        opacityMapUv: {
            'default': 0,
            'type': 'int',
            'enum': [
                { v: '', t: '...' },
                { v: 0, t: 'UV0' },
                { v: 1, t: 'UV1' }
            ]
        },
        opacityMapTiling: {
            'default': [ 1, 1 ],
            'type': 'vec2',
        },
        opacityMapOffset: {
            'default': [ 0, 0 ],
            'type': 'vec2',
        },
        reflectivity: {
            'default': 1,
            'min': 0,
            'max': 1,
            'type': 'float',
        },
        refraction: {
            'default': 0,
            'min': 0,
            'max': 1,
            'type': 'float'
        },
        refractionIndex: {
            'default': 1.0 / 1.5,
            'min': 0,
            'max': 1,
            'type': 'float'
        },
        sphereMap: {
            'default': 0,
            'type': 'texture',
        },
        cubeMap: {
            'default': 0,
            'type': 'cubemap',
        },
        cubeMapProjection: {
            'default': 0,
            'type': 'boolean'
        },
        lightMap: {
            'default': 0,
            'type': 'texture',
        },
        lightMapVertexColor: {
            'default': false,
            'type': 'boolean',
        },
        lightMapChannel: {
            'default': 'rgb',
            'type': 'string'
        },
        lightMapUv: {
            'default': 1,
            'type': 'int',
            'enum': [
                { v: '', t: '...' },
                { v: 0, t: 'UV0' },
                { v: 1, t: 'UV1' }
            ]
        },
        lightMapTiling: {
            'default': [ 1, 1 ],
            'type': 'vec2',
        },
        lightMapOffset: {
            'default': [ 0, 0 ],
            'type': 'vec2',
        },
        depthTest: {
            'default': true,
            'type': 'boolean',
        },
        depthWrite: {
            'default': true,
            'type': 'boolean',
        },
        cull: {
            'default': 1,
            'enum': [
                { v: '', t: '...' },
                { v: 0, t: 'None' },
                { v: 1, t: 'Back Faces' },
                { v: 2, t: 'Front Faces' }
            ],
            'type': 'int',
        },
        blendType: {
            'default': 3,
            'enum': [
                { v: '', t: '...' },
                { v: 3, t: 'None' },
                { v: 2, t: 'Alpha' },
                { v: 1, t: 'Additive' },
                { v: 6, t: 'Additive Alpha' },
                { v: 4, t: 'Premultiplied Alpha' },
                { v: 5, t: 'Multiply' }
            ],
            'type': 'int'
        },
        shadowSampleType: {
            'default': 1,
            'enum': [
                { v: '', t: '...' },
                { v: 0, t: 'Hard' },
                { v: 1, t: 'PCF 3x3' }
            ],
            'type': 'int'
        }
    };

    var mappingMaps = [
        'diffuse',
        'specular',
        'emissive',
        'normal',
        'metalness',
        'gloss',
        'opacity',
        'height',
        'ao',
        'light'
    ];

    var panelsStates = { };
    var panelsStatesDependencies = {
        'offset': [ 'diffuseMapOffset', 'diffuseMapTiling' ],
        'ao': [ 'aoMap' ],
        'diffuse': [ 'diffuseMap' ],
        'specular': [ 'specularMap', 'metalnessMap', 'glossMap' ],
        'emissive': [ 'emissiveMap' ],
        'opacity': [ 'opacityMap' ],
        'normals': [ 'normalMap' ],
        'height': [ 'heightMap' ],
        'environment': [ 'sphereMap', 'cubeMap' ],
        'light': [ 'lightMap' ],
        'states': [ ]
    };


    editor.method('material:default', function (existingData) {
        existingData = existingData || {};

        var obj = {
            shader: existingData.shader || 'blinn'
        };

        for(var key in mapping) {
            obj[key] = existingData[key] !== undefined ? existingData[key] : mapping[key].default;
        }

        return obj;
    });

    editor.method('material:rememberMissingFields', function (asset) {
        // check missing tilings / offsets
        mappingMaps.forEach(function (map) {
            var path = 'data.' + map + 'MapTiling';
            if (asset.get(path) === null)
                missingPaths[asset.get('id') + '.' + path] = true;

            path = 'data.' + map + 'MapOffset';
            if (asset.get(path) === null)
                missingPaths[asset.get('id') + '.' + path] = true;
        });
    });

    // Contains paths in this form: id.data.property
    // Holds material properties that are not in the db.
    // Used to set initial values for offsets and tilings
    // to avoid sharejs errors.
    var missingPaths = { };

    editor.on('attributes:inspect[asset]', function(assets) {
        for(var i = 0; i < assets.length; i++) {
            if (assets[i].get('type') !== 'material')
                return;
        }

        var app = editor.call('viewport:framework');

        if (assets.length > 1)
            editor.call('attributes:header', assets.length + ' Materials');

        var root = editor.call('attributes.rootPanel');

        var ids = [ ];
        for(var i = 0; i < assets.length; i++)
            ids.push(assets[i].get('id'));
        ids = ids.sort(function(a, b) {
            return a - b;
        }).join(',');

        var panelState = panelsStates[ids] = panelsStates[ids];
        var panelStateNew = false;

        if (! panelState) {
            panelStateNew = true;
            panelState = panelsStates[ids] = { };

            for(var key in panelsStatesDependencies) {
                var fields = panelsStatesDependencies[key];
                panelState[key] = true;

                for(var n = 0; n < fields.length; n++) {
                    switch(mapping[fields[n]].type) {
                        case 'vec2':
                            for(var i = 0; i < assets.length; i++) {
                                var value = assets[i].get('data.' + fields[n]);
                                if (value && value[0] !== mapping[fields[n]].default[0] || value && value[1] !== mapping[fields[n]].default[1]) {
                                    panelState[key] = false;
                                    break;
                                }
                            }
                            break;
                        case 'texture':
                            for(var i = 0; i < assets.length; i++) {
                                if (assets[i].get('data.' + fields[n])) {
                                    panelState[key] = false;
                                    break;
                                }
                            }
                            break;
                    }
                }
            }
        }


        // preview
        if (assets.length === 1) {
            var canvas = document.createElement('canvas');
            var ctx = canvas.getContext('2d');
            canvas.classList.add('asset-preview');

            canvas.addEventListener('click', function() {
                if (root.element.classList.contains('large')) {
                    root.element.classList.remove('large');
                } else {
                    root.element.classList.add('large');
                }
            }, false);

            root.class.add('asset-preview');
            root.element.insertBefore(canvas, root.innerElement);

            var renderPreview = function () {
                // resize canvas
                canvas.width = root.element.clientWidth;
                canvas.height = canvas.width;
                editor.call('preview:render:material', assets[0], canvas.width, function (sourceCanvas) {
                    ctx.drawImage(sourceCanvas, 0, 0);
                });
            };
            renderPreview();

            var renderTimeout;

            var evtPanelResize = root.on('resize', function () {
                if (renderTimeout)
                    clearTimeout(renderTimeout);

                renderTimeout = setTimeout(renderPreview, 100);
            });
            var evtMaterialChanged = editor.on('preview:material:changed', function (id) {
                if (id === assets[0].get('id'))
                    renderPreview();
            });
        }

        var handleTextureHover = function(path) {
            var valueOld = null;
            var events = [ ];

            return {
                over: function(type, data) {
                    var texture = app.assets.get(parseInt(data.id, 10));
                    app.assets.load(texture);

                    var attachTexture = function(ind) {
                        var engineAsset = app.assets.get(parseInt(assets[ind].get('id'), 10));
                        app.assets.load(engineAsset);

                        if (engineAsset && engineAsset.resource) {
                            valueOld[ind] = engineAsset.resource[path];

                            if (texture.resource) {
                                engineAsset.resource[path] = texture.resource;
                                engineAsset.resource.update();
                            } else {
                                var evt = {
                                    asset: texture,
                                    fn: function() {
                                        engineAsset.resource[path] = texture.resource;
                                        engineAsset.resource.update();
                                    }
                                };
                                events.push(evt);
                                texture.once('load', evt.fn);
                            }
                        }
                    };

                    valueOld = [ ];
                    for(var i = 0; i < assets.length; i++)
                        attachTexture(i);
                    editor.call('viewport:render');
                },
                leave: function() {
                    if (valueOld === null) return;

                    for(var i = 0; i < events.length; i++)
                        events[i].asset.off('load', events[i].fn);
                    events = [ ];

                    for(var i = 0; i < assets.length; i++) {
                        var engineAsset = app.assets.get(parseInt(assets[i].get('id'), 10));
                        app.assets.load(engineAsset);

                        if (engineAsset && engineAsset.resource) {
                            engineAsset.resource[path] = valueOld[i];
                            engineAsset.resource.update();
                        }
                    }
                    editor.call('viewport:render');
                    valueOld = null;
                }
            };
        };


        // properties panel
        var panelParams = editor.call('attributes:addPanel', {
            name: 'Material'
        });
        panelParams.class.add('component');
        // reference
        editor.call('attributes:reference:asset:material:asset:attach', panelParams, panelParams.headerElement);
        // clean preview
        if (assets.length === 1) {
            panelParams.on('destroy', function() {
                evtPanelResize.unbind();
                evtMaterialChanged.unbind();
                canvas.parentNode.removeChild(canvas);
                root.class.remove('asset-preview', 'animate');
            });
            root.class.add('animate');
        }


        // model
        var fieldShader = editor.call('attributes:addField', {
            parent: panelParams,
            type: 'string',
            enum: {
                '': '...',
                'phong': 'Phong',
                'blinn': 'Physical'
            },
            name: 'Shading',
            link: assets,
            path: 'data.shader'
        });
        // reference
        editor.call('attributes:reference:asset:material:shadingModel:attach', fieldShader.parent.innerElement.firstChild.ui);
        // fresnelMode
        var evtFresnelModel = [ ];
        for(var i = 0; i < assets.length; i++) {
            evtFresnelModel.push(assets[i].on('data.shader:set', function(value) {
                var state = this.history.enabled;
                this.history.enabled = false;
                this.set('data.fresnelModel', value === 'blinn' ? 2 : 0);
                this.history.enabled = state;
            }));
        }
        fieldShader.once('destroy', function() {
            for(var i = 0; i < evtFresnelModel.length; i++)
                evtFresnelModel[i].unbind();
        });



        // TODO
        // make sure changes by history or to individual
        // offset/tiling fields affects state of global fields

        // tiling & offsets
        var tilingOffsetsChanging = false;
        var offset = assets[0].get('data.' + mappingMaps[0] + 'MapOffset');
        var tiling = assets[0].get('data.' + mappingMaps[0] + 'MapTiling');
        var checkTilingOffsetDifferent = function() {
            var offset = assets[0].get('data.' + mappingMaps[0] + 'MapOffset');
            var tiling = assets[0].get('data.' + mappingMaps[0] + 'MapTiling');

            for(var i = 0; i < assets.length; i++) {
                for(var m = 0; m < mappingMaps.length; m++) {
                    if (i === 0 && m === 0)
                        continue;

                    if (! offset.equals(assets[i].get('data.' + mappingMaps[m] + 'MapOffset')) || ! tiling.equals(assets[i].get('data.' + mappingMaps[m] + 'MapTiling'))) {
                        return true;
                    }
                }
            }

            return false;
        }
        var different = checkTilingOffsetDifferent();

        if (different && panelStateNew)
            panelState['offset'] = true;

        var panelTiling = editor.call('attributes:addPanel', {
            foldable: true,
            folded: panelState['offset'],
            name: 'Offset & Tiling'
        });
        panelTiling.class.add('component');
        panelTiling.on('fold', function() { panelState['offset'] = true; });
        panelTiling.on('unfold', function() { panelState['offset'] = false; });
        // reference
        editor.call('attributes:reference:asset:material:offsetTiling:attach', panelTiling, panelTiling.headerElement);

        var tilingOffsetFields = [ ];

        // all maps
        var fieldTilingOffset = editor.call('attributes:addField', {
            parent: panelTiling,
            type: 'checkbox',
            name: 'Apply to all Maps',
            value: ! different
        });
        fieldTilingOffset.element.previousSibling.style.width = 'auto';
        fieldTilingOffset.on('change', function(value) {
            if (tilingOffsetsChanging)
                return;

            fieldOffset[0].parent.hidden = ! value;
            fieldTiling[0].parent.hidden = ! value;

            for(var i = 0; i < tilingOffsetFields.length; i++)
                tilingOffsetFields[i].element.hidden = tilingOffsetFields[i].filter();

            if (value) {
                var valueOffset = [ fieldOffset[0].value, fieldOffset[1].value ];
                var valueTiling = [ fieldTiling[0].value, fieldTiling[1].value ];
                var items = [ ];
                tilingOffsetsChanging = true;
                for(var i = 0; i < assets.length; i++) {
                    for(var m = 0; m < mappingMaps.length; m++) {
                        items.push({
                            get: assets[i].history._getItemFn,
                            path: 'data.' + mappingMaps[m] + 'Map',
                            valueOffset: assets[i].get('data.' + mappingMaps[m] + 'MapOffset'),
                            valueTiling: assets[i].get('data.' + mappingMaps[m] + 'MapTiling')
                        });
                        assets[i].history.enabled = false;
                        assets[i].set('data.' + mappingMaps[m] + 'MapOffset', valueOffset);
                        assets[i].set('data.' + mappingMaps[m] + 'MapTiling', valueTiling);
                        assets[i].history.enabled = true;
                    }
                }
                tilingOffsetsChanging = false;
                // history
                editor.call('history:add', {
                    name: 'assets.materials.tiling-offset',
                    undo: function() {
                        for(var i = 0; i < items.length; i++) {
                            var item = items[i].get();
                            if (! item)
                                continue;

                            item.history.enabled = false;
                            item.set(items[i].path + 'Offset', items[i].valueOffset);
                            item.set(items[i].path + 'Tiling', items[i].valueTiling);
                            item.history.enabled = true;
                        }
                    },
                    redo: function() {
                        for(var i = 0; i < items.length; i++) {
                            var item = items[i].get();
                            if (! item)
                                continue;

                            item.history.enabled = false;
                            item.set(items[i].path + 'Offset', valueOffset);
                            item.set(items[i].path + 'Tiling', valueTiling);
                            item.history.enabled = true;
                        }
                    }
                });
            }
        });

        // offset
        var fieldOffset = editor.call('attributes:addField', {
            parent: panelTiling,
            type: 'vec2',
            name: 'Offset',
            placeholder: [ 'U', 'V' ]
        });
        fieldOffset[0].parent.hidden = ! fieldTilingOffset.value;
        // reference
        editor.call('attributes:reference:asset:material:offset:attach', fieldOffset[0].parent.innerElement.firstChild.ui);

        // tiling
        var fieldTiling = editor.call('attributes:addField', {
            parent: panelTiling,
            type: 'vec2',
            name: 'Tiling',
            placeholder: [ 'U', 'V' ]
        });
        fieldTiling[0].parent.hidden = ! fieldTilingOffset.value;
        // reference
        editor.call('attributes:reference:asset:material:tiling:attach', fieldTiling[0].parent.innerElement.firstChild.ui);

        if (different) {
            fieldTilingOffset.value = false;

            if (panelStateNew && ! panelState['offset'])
                panelState['offset'] = true;
        }

        fieldOffset[0].value = offset[0];
        fieldOffset[1].value = offset[1];
        fieldTiling[0].value = tiling[0];
        fieldTiling[1].value = tiling[1];

        var updateAllTilingOffsetFields = function(input, type, field, value, valueOld) {
            if (! fieldTilingOffset.value || tilingOffsetsChanging)
                return;

            var items = [ ];

            tilingOffsetsChanging = true;
            for(var i = 0; i < assets.length; i++) {
                assets[i].history.enabled = false;
                for(var m = 0; m < mappingMaps.length; m++) {
                    var path = 'data.' + mappingMaps[m] + 'Map' + type;
                    // set initial value for tiling / offset if it was missing
                    if (missingPaths[assets[i].get('id') + '.' + path]) {
                        assets[i].set(path, [input[0].value, input[1].value]);
                        delete missingPaths[assets[i].get('id') + '.' + path];
                    }

                    var fullpath = path + '.' + field;
                    items.push({
                        get: assets[i].history._getItemFn,
                        path: fullpath,
                        value: assets[i].get(fullpath)
                    });
                    assets[i].set(fullpath, value);
                }
                assets[i].history.enabled = true;
            }
            tilingOffsetsChanging = false;

            // history
            editor.call('history:add', {
                name: 'assets.materials.' + type + '.' + field,
                undo: function() {
                    for(var i = 0; i < items.length; i++) {
                        var item = items[i].get();
                        if (! item)
                            continue;

                        item.history.enabled = false;
                        item.set(items[i].path, items[i].value);
                        item.history.enabled = true;
                    }
                },
                redo: function() {
                    for(var i = 0; i < items.length; i++) {
                        var item = items[i].get();
                        if (! item)
                            continue;

                        item.history.enabled = false;
                        item.set(items[i].path, value);
                        item.history.enabled = true;
                    }
                }
            });
        };

        fieldOffset[0].on('change', function(value, valueOld) {
            updateAllTilingOffsetFields(fieldOffset, 'Offset', 0, value);
        });
        fieldOffset[1].on('change', function(value, valueOld) {
            updateAllTilingOffsetFields(fieldOffset, 'Offset', 1, value);
        });
        fieldTiling[0].on('change', function(value, valueOld) {
            updateAllTilingOffsetFields(fieldTiling, 'Tiling', 0, value);
        });
        fieldTiling[1].on('change', function(value, valueOld) {
            updateAllTilingOffsetFields(fieldTiling, 'Tiling', 1, value);
        });



        // ambient
        var panelAmbient = editor.call('attributes:addPanel', {
            foldable: true,
            folded: panelState['ao'],
            name: 'Ambient'
        });
        panelAmbient.class.add('component');
        panelAmbient.on('fold', function() { panelState['ao'] = true; });
        panelAmbient.on('unfold', function() { panelState['ao'] = false; });
        // reference
        editor.call('attributes:reference:asset:material:ambientOverview:attach', panelAmbient, panelAmbient.headerElement);


        // color
        var fieldAmbientColor = editor.call('attributes:addField', {
            parent: panelAmbient,
            name: 'Color',
            type: 'rgb',
            link: assets,
            path: 'data.ambient'
        });
        // reference
        editor.call('attributes:reference:asset:material:ambient:attach', fieldAmbientColor.parent.innerElement.firstChild.ui);


        // tint
        var fieldAmbientTint = editor.call('attributes:addField', {
            panel: fieldAmbientColor.parent,
            type: 'checkbox',
            link: assets,
            path: 'data.ambientTint'
        });
        // label
        var labelAmbientTint = new ui.Label({ text: 'Tint' });
        labelAmbientTint.style.verticalAlign = 'top';
        labelAmbientTint.style.paddingRight = '12px';
        labelAmbientTint.style.fontSize = '12px';
        labelAmbientTint.style.lineHeight = '24px';
        fieldAmbientColor.parent.append(labelAmbientTint);
        // reference
        editor.call('attributes:reference:asset:material:ambientTint:attach', labelAmbientTint);


        // map
        var fieldAmbientMapHover = handleTextureHover('aoMap');
        var fieldAmbientMap = editor.call('attributes:addField', {
            parent: panelAmbient,
            type: 'asset',
            kind: 'texture',
            name: 'Ambient Occlusion',
            link: assets,
            path: 'data.aoMap',
            over: fieldAmbientMapHover.over,
            leave: fieldAmbientMapHover.leave
        });
        fieldAmbientMap.parent.class.add('channel');
        fieldAmbientMap.on('change', function(value) {
            fieldAmbientOffset[0].parent.hidden = filterAmbientOffset();
            fieldAmbientTiling[0].parent.hidden = filterAmbientTiling();
            fieldOccludeSpecular.parent.hidden = ! fieldAmbientMap.value && ! fieldAmbientMap.class.contains('null');
        });
        // reference
        editor.call('attributes:reference:asset:material:aoMap:attach', fieldAmbientMap._label);

        // map uv
        var fieldAmbientMapUV = editor.call('attributes:addField', {
            panel: fieldAmbientMap.parent,
            type: 'number',
            enum: mapping.aoMapUv.enum,
            link: assets,
            path: 'data.aoMapUv'
        });
        fieldAmbientMapUV.flexGrow = 0;
        fieldAmbientMapUV.element.parentNode.removeChild(fieldAmbientMapUV.element);
        fieldAmbientMap.parent.innerElement.querySelector('.top > .controls').appendChild(fieldAmbientMapUV.element);
        // reference
        editor.call('attributes:reference:asset:material:aoMapUv:attach', fieldAmbientMapUV);

        // map channel
        var fieldAmbientMapChannel = editor.call('attributes:addField', {
            panel: fieldAmbientMap.parent,
            type: 'string',
            enum: {
                '': '...',
                'r': 'R',
                'g': 'G',
                'b': 'B',
                'a': 'A'
            },
            link: assets,
            path: 'data.aoMapChannel'
        });
        fieldAmbientMapChannel.element.parentNode.removeChild(fieldAmbientMapChannel.element);
        fieldAmbientMap.parent.innerElement.querySelector('.top > .ui-label').parentNode.appendChild(fieldAmbientMapChannel.element);
        // reference
        editor.call('attributes:reference:asset:material:aoMapChannel:attach', fieldAmbientMapChannel);

        // offset
        var fieldAmbientOffset = editor.call('attributes:addField', {
            parent: panelAmbient,
            type: 'vec2',
            name: 'Offset',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.aoMapOffset'
        });
        var filterAmbientOffset = function() {
            return (! fieldAmbientMap.value && ! fieldAmbientMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldAmbientOffset[0].parent,
            offset: fieldAmbientOffset,
            filter: filterAmbientOffset,
            path: 'data.aoMapOffset'
        });
        fieldAmbientOffset[0].parent.hidden = filterAmbientOffset();
        // reference
        editor.call('attributes:reference:asset:material:aoMapOffset:attach', fieldAmbientOffset[0].parent.innerElement.firstChild.ui);

        // tiling
        var fieldAmbientTiling = editor.call('attributes:addField', {
            parent: panelAmbient,
            type: 'vec2',
            name: 'Tiling',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.aoMapTiling'
        });
        var filterAmbientTiling = function() {
            return (! fieldAmbientMap.value && ! fieldAmbientMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldAmbientTiling[0].parent,
            tiling: fieldAmbientTiling,
            filter: filterAmbientTiling,
            path: 'data.aoMapTiling'
        });
        fieldAmbientTiling[0].parent.hidden = filterAmbientTiling();
        // reference
        editor.call('attributes:reference:asset:material:aoMapTiling:attach', fieldAmbientTiling[0].parent.innerElement.firstChild.ui);

        // vertex color
        var fieldAmbientVertexColor = editor.call('attributes:addField', {
            parent: panelAmbient,
            name: 'Vertex Color',
            type: 'checkbox',
            link: assets,
            path: 'data.aoMapVertexColor'
        });
        // reference
        editor.call('attributes:reference:asset:material:aoMapVertexColor:attach', fieldAmbientVertexColor.parent.innerElement.firstChild.ui);

        // occludeSpecular
        var fieldOccludeSpecular = editor.call('attributes:addField', {
            parent: panelAmbient,
            type: 'checkbox',
            name: 'Occlude Specular',
            link: assets,
            path: 'data.occludeSpecular'
        });
        fieldOccludeSpecular.parent.hidden = ! fieldAmbientMap.value && ! fieldAmbientMap.class.contains('null');
        // reference
        editor.call('attributes:reference:asset:material:occludeSpecular:attach', fieldOccludeSpecular.parent.innerElement.firstChild.ui);


        // diffuse
        var panelDiffuse = editor.call('attributes:addPanel', {
            foldable: true,
            folded: panelState['diffuse'],
            name: 'Diffuse'
        });
        panelDiffuse.class.add('component');
        panelDiffuse.on('fold', function() { panelState['diffuse'] = true; });
        panelDiffuse.on('unfold', function() { panelState['diffuse'] = false; });
        // reference
        editor.call('attributes:reference:asset:material:diffuseOverview:attach', panelDiffuse, panelDiffuse.headerElement);

        // diffuse map
        var fieldDiffuseMapHover = handleTextureHover('diffuseMap');
        var fieldDiffuseMap = editor.call('attributes:addField', {
            parent: panelDiffuse,
            type: 'asset',
            kind: 'texture',
            name: 'Diffuse',
            link: assets,
            path: 'data.diffuseMap',
            over: fieldDiffuseMapHover.over,
            leave: fieldDiffuseMapHover.leave
        });
        fieldDiffuseMap.parent.class.add('channel');
        fieldDiffuseMap.on('change', function(value) {
            fieldDiffuseOffset[0].parent.hidden = filterDiffuseOffset();
            fieldDiffuseTiling[0].parent.hidden = filterDiffuseTiling();
        });
        // reference
        editor.call('attributes:reference:asset:material:diffuseMap:attach', fieldDiffuseMap._label);

        // map uv
        var fieldDiffuseMapUV = editor.call('attributes:addField', {
            panel: fieldDiffuseMap.parent,
            type: 'number',
            enum: mapping.diffuseMapUv.enum,
            link: assets,
            path: 'data.diffuseMapUv'
        });
        fieldDiffuseMapUV.flexGrow = 0;
        fieldDiffuseMapUV.element.parentNode.removeChild(fieldDiffuseMapUV.element);
        fieldDiffuseMap.parent.innerElement.querySelector('.top > .controls').appendChild(fieldDiffuseMapUV.element);
        // reference
        editor.call('attributes:reference:asset:material:diffuseMapUv:attach', fieldDiffuseMapUV);

        // map channel
        var fieldDiffuseMapChannel = editor.call('attributes:addField', {
            panel: fieldDiffuseMap.parent,
            type: 'string',
            enum: {
                '': '...',
                'r': 'R',
                'g': 'G',
                'b': 'B',
                'a': 'A',
                'rgb': 'RGB'
            },
            link: assets,
            path: 'data.diffuseMapChannel'
        });
        fieldDiffuseMapChannel.element.parentNode.removeChild(fieldDiffuseMapChannel.element);
        fieldDiffuseMap.parent.innerElement.querySelector('.top > .ui-label').parentNode.appendChild(fieldDiffuseMapChannel.element);
        // reference
        editor.call('attributes:reference:asset:material:diffuseMapChannel:attach', fieldDiffuseMapChannel);

        // offset
        var fieldDiffuseOffset = editor.call('attributes:addField', {
            parent: panelDiffuse,
            type: 'vec2',
            name: 'Offset',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.diffuseMapOffset'
        });
        var filterDiffuseOffset = function() {
            return (! fieldDiffuseMap.value && ! fieldDiffuseMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldDiffuseOffset[0].parent,
            offset: fieldDiffuseOffset,
            filter: filterDiffuseOffset,
            path: 'data.diffuseMapOffset'
        });
        fieldDiffuseOffset[0].parent.hidden = filterDiffuseOffset();
        // reference
        editor.call('attributes:reference:asset:material:diffuseMapOffset:attach', fieldDiffuseOffset[0].parent.innerElement.firstChild.ui);

        // tiling
        var fieldDiffuseTiling = editor.call('attributes:addField', {
            parent: panelDiffuse,
            type: 'vec2',
            name: 'Tiling',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.diffuseMapTiling'
        });
        var filterDiffuseTiling = function() {
            return (! fieldDiffuseMap.value && ! fieldDiffuseMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldDiffuseTiling[0].parent,
            tiling: fieldDiffuseTiling,
            filter: filterDiffuseTiling,
            path: 'data.diffuseMapTiling'
        });
        fieldDiffuseTiling[0].parent.hidden = filterDiffuseTiling();
        // reference
        editor.call('attributes:reference:asset:material:diffuseMapTiling:attach', fieldDiffuseTiling[0].parent.innerElement.firstChild.ui);

        // vertex color
        var fieldDiffuseVertexColor = editor.call('attributes:addField', {
            parent: panelDiffuse,
            name: 'Vertex Color',
            type: 'checkbox',
            link: assets,
            path: 'data.diffuseMapVertexColor'
        });
        // reference
        editor.call('attributes:reference:asset:material:diffuseMapVertexColor:attach', fieldDiffuseVertexColor.parent.innerElement.firstChild.ui);

        // color
        var fieldDiffuseColor = editor.call('attributes:addField', {
            parent: panelDiffuse,
            name: 'Color',
            type: 'rgb',
            link: assets,
            path: 'data.diffuse'
        });
        // reference
        editor.call('attributes:reference:asset:material:diffuse:attach', fieldDiffuseColor.parent.innerElement.firstChild.ui);

        // tint
        var fieldDiffuseTint = editor.call('attributes:addField', {
            panel: fieldDiffuseColor.parent,
            type: 'checkbox',
            link: assets,
            path: 'data.diffuseMapTint'
        });
        // label
        var labelDiffuseTint = new ui.Label({ text: 'Tint' });
        labelDiffuseTint.style.verticalAlign = 'top';
        labelDiffuseTint.style.paddingRight = '12px';
        labelDiffuseTint.style.fontSize = '12px';
        labelDiffuseTint.style.lineHeight = '24px';
        fieldDiffuseColor.parent.append(labelDiffuseTint);
        // reference
        editor.call('attributes:reference:asset:material:diffuseMapTint:attach', labelDiffuseTint);



        // specular
        var panelSpecular = editor.call('attributes:addPanel', {
            foldable: true,
            folded: panelState['specular'],
            name: 'Specular'
        });
        panelSpecular.class.add('component');
        panelSpecular.on('fold', function() { panelState['specular'] = true; });
        panelSpecular.on('unfold', function() { panelState['specular'] = false; });
        // reference
        editor.call('attributes:reference:asset:material:specularOverview:attach', panelSpecular, panelSpecular.headerElement);

        // use metalness
        var fieldUseMetalness = editor.call('attributes:addField', {
            parent: panelSpecular,
            type: 'checkbox',
            name: 'Use Metalness',
            link: assets,
            path: 'data.useMetalness'
        });
        fieldUseMetalness.on('change', function(value) {
            panelSpecularWorkflow.hidden = value || fieldUseMetalness.class.contains('null');
            panelMetalness.hidden = ! value || fieldUseMetalness.class.contains('null');
        });
        // reference
        editor.call('attributes:reference:asset:material:useMetalness:attach', fieldUseMetalness.parent.innerElement.firstChild.ui);

        var panelMetalness = editor.call('attributes:addPanel');
        panelMetalness.hidden = ! fieldUseMetalness.value || fieldUseMetalness.class.contains('null');
        panelSpecular.append(panelMetalness);

        // metalness map
        var fieldMetalnessMapHover = handleTextureHover('metalnessMap');
        var fieldMetalnessMap = editor.call('attributes:addField', {
            parent: panelMetalness,
            type: 'asset',
            kind: 'texture',
            name: 'Metalness',
            link: assets,
            path: 'data.metalnessMap',
            over: fieldMetalnessMapHover.over,
            leave: fieldMetalnessMapHover.leave
        });
        fieldMetalnessMap.parent.class.add('channel');
        fieldMetalnessMap.on('change', function(value) {
            fieldMetalnessOffset[0].parent.hidden = filterMetalnessOffset();
            fieldMetalnessTiling[0].parent.hidden = filterMetalnessTiling();
        });
        // reference
        editor.call('attributes:reference:asset:material:metalnessMap:attach', fieldMetalnessMap._label);

        // map uv
        var fieldMetalnessMapUV = editor.call('attributes:addField', {
            panel: fieldMetalnessMap.parent,
            type: 'number',
            enum: mapping.metalnessMapUv.enum,
            link: assets,
            path: 'data.metalnessMapUv'
        });
        fieldMetalnessMapUV.flexGrow = 0;
        fieldMetalnessMapUV.element.parentNode.removeChild(fieldMetalnessMapUV.element);
        fieldMetalnessMap.parent.innerElement.querySelector('.top > .controls').appendChild(fieldMetalnessMapUV.element);
        // reference
        editor.call('attributes:reference:asset:material:metalnessMapUv:attach', fieldMetalnessMapUV);

        // map channel
        var fieldMetalnessMapChannel = editor.call('attributes:addField', {
            panel: fieldMetalnessMap.parent,
            type: 'string',
            enum: {
                '': '...',
                'r': 'R',
                'g': 'G',
                'b': 'B',
                'a': 'A',
            },
            link: assets,
            path: 'data.metalnessMapChannel'
        });
        fieldMetalnessMapChannel.element.parentNode.removeChild(fieldMetalnessMapChannel.element);
        fieldMetalnessMap.parent.innerElement.querySelector('.top > .ui-label').parentNode.appendChild(fieldMetalnessMapChannel.element);
        // reference
        editor.call('attributes:reference:asset:material:metalnessMapChannel:attach', fieldMetalnessMapChannel);

        // offset
        var fieldMetalnessOffset = editor.call('attributes:addField', {
            parent: panelMetalness,
            type: 'vec2',
            name: 'Offset',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.metalnessMapOffset'
        });
        var filterMetalnessOffset = function() {
            return (! fieldMetalnessMap.value && ! fieldMetalnessMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldMetalnessOffset[0].parent,
            offset: fieldMetalnessOffset,
            filter: filterMetalnessOffset,
            path: 'data.metalnessMapOffset'
        });
        fieldMetalnessOffset[0].parent.hidden = filterMetalnessOffset();
        // reference
        editor.call('attributes:reference:asset:material:metalnessMapOffset:attach', fieldMetalnessOffset[0].parent.innerElement.firstChild.ui);

        // tiling
        var fieldMetalnessTiling = editor.call('attributes:addField', {
            parent: panelMetalness,
            type: 'vec2',
            name: 'Tiling',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.metalnessMapTiling'
        });
        var filterMetalnessTiling = function() {
            return (! fieldMetalnessMap.value && ! fieldMetalnessMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldMetalnessTiling[0].parent,
            tiling: fieldMetalnessTiling,
            filter: filterMetalnessTiling,
            path: 'data.metalnessMapTiling'
        });
        fieldMetalnessTiling[0].parent.hidden = filterMetalnessTiling();
        // reference
        editor.call('attributes:reference:asset:material:metalnessMapTiling:attach', fieldMetalnessTiling[0].parent.innerElement.firstChild.ui);

        // vertex color
        var fieldMetalnessVertexColor = editor.call('attributes:addField', {
            parent: panelMetalness,
            name: 'Vertex Color',
            type: 'checkbox',
            link: assets,
            path: 'data.metalnessMapVertexColor'
        });
        // reference
        editor.call('attributes:reference:asset:material:metalnessMapVertexColor:attach', fieldMetalnessVertexColor.parent.innerElement.firstChild.ui);


        // metalness
        var fieldMetalness = editor.call('attributes:addField', {
            parent: panelMetalness,
            precision: 3,
            step: 0.05,
            min: 0,
            max: 1,
            type: 'number',
            name: 'Metalness',
            link: assets,
            path: 'data.metalness'
        });
        fieldMetalness.style.width = '32px';
        // reference
        editor.call('attributes:reference:asset:material:metalness:attach', fieldMetalness.parent.innerElement.firstChild.ui);

        // metalness slider
        var fieldMetalnessSlider = editor.call('attributes:addField', {
            panel: fieldMetalness.parent,
            precision: 3,
            step: 0.05,
            min: 0,
            max: 1,
            type: 'number',
            slider: true,
            link: assets,
            path: 'data.metalness'
        });
        fieldMetalnessSlider.flexGrow = 4;


        // specular
        var panelSpecularWorkflow = editor.call('attributes:addPanel');
        panelSpecularWorkflow.hidden = fieldUseMetalness.value || fieldUseMetalness.class.contains('null');
        panelSpecular.append(panelSpecularWorkflow);

        // specular map
        var fieldSpecularMapHover = handleTextureHover('specularMap');
        var fieldSpecularMap = editor.call('attributes:addField', {
            parent: panelSpecularWorkflow,
            type: 'asset',
            kind: 'texture',
            name: 'Specular',
            link: assets,
            path: 'data.specularMap',
            over: fieldSpecularMapHover.over,
            leave: fieldSpecularMapHover.leave
        });
        fieldSpecularMap.parent.class.add('channel');
        fieldSpecularMap.on('change', function(value) {
            fieldSpecularOffset[0].parent.hidden = filterSpecularOffset();
            fieldSpecularTiling[0].parent.hidden = filterSpecularTiling();
        });
        // reference
        editor.call('attributes:reference:asset:material:specularMap:attach', fieldSpecularMap._label);

        // map uv
        var fieldSpecularMapUV = editor.call('attributes:addField', {
            panel: fieldSpecularMap.parent,
            type: 'number',
            enum: mapping.specularMapUv.enum,
            link: assets,
            path: 'data.specularMapUv'
        });
        fieldSpecularMapUV.flexGrow = 0;
        fieldSpecularMapUV.element.parentNode.removeChild(fieldSpecularMapUV.element);
        fieldSpecularMap.parent.innerElement.querySelector('.top > .controls').appendChild(fieldSpecularMapUV.element);
        // reference
        editor.call('attributes:reference:asset:material:specularMapUv:attach', fieldSpecularMapUV);

        // map channel
        var fieldSpecularMapChannel = editor.call('attributes:addField', {
            panel: fieldSpecularMap.parent,
            type: 'string',
            enum: {
                '': '...',
                'r': 'R',
                'g': 'G',
                'b': 'B',
                'a': 'A',
                'rgb': 'RGB'
            },
            link: assets,
            path: 'data.specularMapChannel'
        });
        fieldSpecularMapChannel.element.parentNode.removeChild(fieldSpecularMapChannel.element);
        fieldSpecularMap.parent.innerElement.querySelector('.top > .ui-label').parentNode.appendChild(fieldSpecularMapChannel.element);
        // reference
        editor.call('attributes:reference:asset:material:specularMapChannel:attach', fieldSpecularMapChannel);


        // offset
        var fieldSpecularOffset = editor.call('attributes:addField', {
            parent: panelSpecularWorkflow,
            type: 'vec2',
            name: 'Offset',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.specularMapOffset'
        });
        var filterSpecularOffset = function() {
            return (! fieldSpecularMap.value && ! fieldSpecularMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldSpecularOffset[0].parent,
            offset: fieldSpecularOffset,
            filter: filterSpecularOffset,
            path: 'data.specularMapOffset'
        });
        fieldSpecularOffset[0].parent.hidden = filterSpecularOffset();
        // reference
        editor.call('attributes:reference:asset:material:specularMapOffset:attach', fieldSpecularOffset[0].parent.innerElement.firstChild.ui);

        // tiling
        var fieldSpecularTiling = editor.call('attributes:addField', {
            parent: panelSpecularWorkflow,
            type: 'vec2',
            name: 'Tiling',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.specularMapTiling'
        });
        var filterSpecularTiling = function() {
            return (! fieldSpecularMap.value && ! fieldSpecularMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldSpecularTiling[0].parent,
            tiling: fieldSpecularTiling,
            filter: filterSpecularTiling,
            path: 'data.specularMapTiling'
        });
        fieldSpecularTiling[0].parent.hidden = filterSpecularTiling();
        // reference
        editor.call('attributes:reference:asset:material:specularMapTiling:attach', fieldSpecularTiling[0].parent.innerElement.firstChild.ui);

        // vertex color
        var fieldSpecularVertexColor = editor.call('attributes:addField', {
            parent: panelSpecularWorkflow,
            name: 'Vertex Color',
            type: 'checkbox',
            link: assets,
            path: 'data.specularMapVertexColor'
        });
        // reference
        editor.call('attributes:reference:asset:material:specularMapVertexColor:attach', fieldSpecularVertexColor.parent.innerElement.firstChild.ui);

        // color
        var fieldSpecularColor = editor.call('attributes:addField', {
            parent: panelSpecularWorkflow,
            name: 'Color',
            type: 'rgb',
            link: assets,
            path: 'data.specular'
        });
        // reference
        editor.call('attributes:reference:asset:material:specular:attach', fieldSpecularColor.parent.innerElement.firstChild.ui);

        // tint
        var fieldSpecularTint = editor.call('attributes:addField', {
            panel: fieldSpecularColor.parent,
            type: 'checkbox',
            link: assets,
            path: 'data.specularMapTint'
        });
        // label
        var labelSpecularTint = new ui.Label({ text: 'Tint' });
        labelSpecularTint.style.verticalAlign = 'top';
        labelSpecularTint.style.paddingRight = '12px';
        labelSpecularTint.style.fontSize = '12px';
        labelSpecularTint.style.lineHeight = '24px';
        fieldSpecularColor.parent.append(labelSpecularTint);
        // reference
        editor.call('attributes:reference:asset:material:specularMapTint:attach', labelSpecularTint);


        // map (gloss)
        var fieldGlossMapHover = handleTextureHover('glossMap');
        var fieldGlossMap = editor.call('attributes:addField', {
            parent: panelSpecular,
            type: 'asset',
            kind: 'texture',
            name: 'Glossiness',
            link: assets,
            path: 'data.glossMap',
            over: fieldGlossMapHover.over,
            leave: fieldGlossMapHover.leave
        });
        fieldGlossMap.parent.class.add('channel');
        fieldGlossMap.on('change', function(value) {
            fieldGlossOffset[0].parent.hidden = filterGlossOffset();
            fieldGlossTiling[0].parent.hidden = filterGlossTiling();
        });
        // reference
        editor.call('attributes:reference:asset:material:glossMap:attach', fieldGlossMap._label);

        // map uv
        var fieldGlossMapUV = editor.call('attributes:addField', {
            panel: fieldGlossMap.parent,
            type: 'number',
            enum: mapping.glossMapUv.enum,
            link: assets,
            path: 'data.glossMapUv'
        });
        fieldGlossMapUV.flexGrow = 0;
        fieldGlossMapUV.element.parentNode.removeChild(fieldGlossMapUV.element);
        fieldGlossMap.parent.innerElement.querySelector('.top > .controls').appendChild(fieldGlossMapUV.element);
        // reference
        editor.call('attributes:reference:asset:material:glossMapUv:attach', fieldGlossMapUV);

        // map channel
        var fieldGlossMapChannel = editor.call('attributes:addField', {
            panel: fieldGlossMap.parent,
            type: 'string',
            enum: {
                '': '...',
                'r': 'R',
                'g': 'G',
                'b': 'B',
                'a': 'A'
            },
            link: assets,
            path: 'data.glossMapChannel'
        });
        fieldGlossMapChannel.element.parentNode.removeChild(fieldGlossMapChannel.element);
        fieldGlossMap.parent.innerElement.querySelector('.top > .ui-label').parentNode.appendChild(fieldGlossMapChannel.element);
        // reference
        editor.call('attributes:reference:asset:material:glossMapChannel:attach', fieldGlossMapChannel);


        // offset
        var fieldGlossOffset = editor.call('attributes:addField', {
            parent: panelSpecular,
            type: 'vec2',
            name: 'Offset',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.glossMapOffset'
        });
        var filterGlossOffset = function() {
            return (! fieldGlossMap.value && ! fieldGlossMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldGlossOffset[0].parent,
            offset: fieldGlossOffset,
            filter: filterGlossOffset,
            path: 'data.glossMapOffset'
        });
        fieldGlossOffset[0].parent.hidden = filterGlossOffset();
        // reference
        editor.call('attributes:reference:asset:material:glossMapOffset:attach', fieldGlossOffset[0].parent.innerElement.firstChild.ui);

        // tiling
        var fieldGlossTiling = editor.call('attributes:addField', {
            parent: panelSpecular,
            type: 'vec2',
            name: 'Tiling',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.glossMapTiling'
        });
        var filterGlossTiling = function() {
            return (! fieldGlossMap.value && ! fieldGlossMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldGlossTiling[0].parent,
            tiling: fieldGlossTiling,
            filter: filterGlossTiling,
            path: 'data.glossMapTiling'
        });
        fieldGlossTiling[0].parent.hidden = filterGlossTiling();
        // reference
        editor.call('attributes:reference:asset:material:glossMapTiling:attach', fieldGlossTiling[0].parent.innerElement.firstChild.ui);

        // vertex color
        var fieldGlossVertexColor = editor.call('attributes:addField', {
            parent: panelSpecular,
            name: 'Vertex Color',
            type: 'checkbox',
            link: assets,
            path: 'data.glossMapVertexColor'
        });
        // reference
        editor.call('attributes:reference:asset:material:glossMapVertexColor:attach', fieldGlossVertexColor.parent.innerElement.firstChild.ui);

        // shininess
        var fieldShininess = editor.call('attributes:addField', {
            parent: panelSpecular,
            type: 'number',
            precision: 2,
            step: 0.5,
            min: 0,
            max: 100,
            name: 'Glossiness',
            link: assets,
            path: 'data.shininess'
        });
        fieldShininess.style.width = '32px';
        // reference
        editor.call('attributes:reference:asset:material:shininess:attach', fieldShininess.parent.innerElement.firstChild.ui);

        // shininess slider
        var fieldShininessSlider = editor.call('attributes:addField', {
            panel: fieldShininess.parent,
            precision: 2,
            step: 0.5,
            min: 0,
            max: 100,
            type: 'number',
            slider: true,
            link: assets,
            path: 'data.shininess'
        });
        fieldShininessSlider.flexGrow = 4;


        // emissive
        var panelEmissive = editor.call('attributes:addPanel', {
            foldable: true,
            folded: panelState['emissive'],
            name: 'Emissive'
        });
        panelEmissive.class.add('component');
        panelEmissive.on('fold', function() { panelState['emissive'] = true; });
        panelEmissive.on('unfold', function() { panelState['emissive'] = false; });
        // reference
        editor.call('attributes:reference:asset:material:emissiveOverview:attach', panelEmissive, panelEmissive.headerElement);

        // map
        var fieldEmissiveMapHover = handleTextureHover('emissiveMap');
        var fieldEmissiveMap = editor.call('attributes:addField', {
            parent: panelEmissive,
            type: 'asset',
            kind: 'texture',
            name: 'Emissive',
            link: assets,
            path: 'data.emissiveMap',
            over: fieldEmissiveMapHover.over,
            leave: fieldEmissiveMapHover.leave
        });
        fieldEmissiveMap.parent.class.add('channel');
        fieldEmissiveMap.on('change', function(value) {
            fieldEmissiveOffset[0].parent.hidden = filterEmissiveOffset();
            fieldEmissiveTiling[0].parent.hidden = filterEmissiveTiling();
        });
        // reference
        editor.call('attributes:reference:asset:material:emissiveMap:attach', fieldEmissiveMap._label);

        // map uv
        var fieldEmissiveMapUV = editor.call('attributes:addField', {
            panel: fieldEmissiveMap.parent,
            type: 'number',
            enum: mapping.emissiveMapUv.enum,
            link: assets,
            path: 'data.emissiveMapUv'
        });
        fieldEmissiveMapUV.flexGrow = 0;
        fieldEmissiveMapUV.element.parentNode.removeChild(fieldEmissiveMapUV.element);
        fieldEmissiveMap.parent.innerElement.querySelector('.top > .controls').appendChild(fieldEmissiveMapUV.element);
        // reference
        editor.call('attributes:reference:asset:material:emissiveMapUv:attach', fieldEmissiveMapUV);

        // map channel
        var fieldEmissiveMapChannel = editor.call('attributes:addField', {
            panel: fieldEmissiveMap.parent,
            type: 'string',
            enum: {
                '': '...',
                'r': 'R',
                'g': 'G',
                'b': 'B',
                'a': 'A',
                'rgb': 'RGB'
            },
            link: assets,
            path: 'data.emissiveMapChannel'
        });
        fieldEmissiveMapChannel.element.parentNode.removeChild(fieldEmissiveMapChannel.element);
        fieldEmissiveMap.parent.innerElement.querySelector('.top > .ui-label').parentNode.appendChild(fieldEmissiveMapChannel.element);
        // reference
        editor.call('attributes:reference:asset:material:emissiveMapChannel:attach', fieldEmissiveMapChannel);


        // offset
        var fieldEmissiveOffset = editor.call('attributes:addField', {
            parent: panelEmissive,
            type: 'vec2',
            name: 'Offset',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.emissiveMapOffset'
        });
        var filterEmissiveOffset = function() {
            return (! fieldEmissiveMap.value && ! fieldEmissiveMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldEmissiveOffset[0].parent,
            offset: fieldEmissiveOffset,
            filter: filterEmissiveOffset,
            path: 'data.emissiveMapOffset'
        });
        fieldEmissiveOffset[0].parent.hidden = filterEmissiveOffset();
        // reference
        editor.call('attributes:reference:asset:material:emissiveMapOffset:attach', fieldEmissiveOffset[0].parent.innerElement.firstChild.ui);

        // tiling
        var fieldEmissiveTiling = editor.call('attributes:addField', {
            parent: panelEmissive,
            type: 'vec2',
            name: 'Tiling',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.emissiveMapTiling'
        });
        var filterEmissiveTiling = function() {
            return (! fieldEmissiveMap.value && ! fieldEmissiveMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldEmissiveTiling[0].parent,
            tiling: fieldEmissiveTiling,
            filter: filterEmissiveTiling,
            path: 'data.emissiveMapTiling'
        });
        fieldEmissiveTiling[0].parent.hidden = filterEmissiveTiling();
        // reference
        editor.call('attributes:reference:asset:material:emissiveMapTiling:attach', fieldEmissiveTiling[0].parent.innerElement.firstChild.ui);

        // vertex color
        var fieldEmissiveVertexColor = editor.call('attributes:addField', {
            parent: panelEmissive,
            name: 'Vertex Color',
            type: 'checkbox',
            link: assets,
            path: 'data.emissiveMapVertexColor'
        });
        // reference
        editor.call('attributes:reference:asset:material:emissiveMapVertexColor:attach', fieldEmissiveVertexColor.parent.innerElement.firstChild.ui);

        // color
        var fieldEmissiveColor = editor.call('attributes:addField', {
            parent: panelEmissive,
            name: 'Color',
            type: 'rgb',
            link: assets,
            path: 'data.emissive'
        });
        // reference
        editor.call('attributes:reference:asset:material:emissive:attach', fieldEmissiveColor.parent.innerElement.firstChild.ui);

        // tint
        var fieldEmissiveTint = editor.call('attributes:addField', {
            panel: fieldEmissiveColor.parent,
            type: 'checkbox',
            link: assets,
            path: 'data.emissiveMapTint'
        });
        // label
        var labelEmissiveTint = new ui.Label({ text: 'Tint' });
        labelEmissiveTint.style.verticalAlign = 'top';
        labelEmissiveTint.style.paddingRight = '12px';
        labelEmissiveTint.style.fontSize = '12px';
        labelEmissiveTint.style.lineHeight = '24px';
        fieldEmissiveColor.parent.append(labelEmissiveTint);
        // reference
        editor.call('attributes:reference:asset:material:emissiveMapTint:attach', labelEmissiveTint);



        // emissiveIntensity
        var fieldEmissiveIntensity = editor.call('attributes:addField', {
            parent: panelEmissive,
            name: 'Intensity',
            type: 'number',
            precision: 2,
            step: .1,
            min: 0,
            link: assets,
            path: 'data.emissiveIntensity'
        });
        fieldEmissiveIntensity.style.width = '32px';
        // reference
        editor.call('attributes:reference:asset:material:emissiveIntensity:attach', fieldEmissiveIntensity.parent.innerElement.firstChild.ui);

        // emissiveIntensity slider
        var fieldEmissiveIntensitySlider = editor.call('attributes:addField', {
            panel: fieldEmissiveIntensity.parent,
            precision: 2,
            step: .1,
            min: 0,
            max: 10,
            type: 'number',
            slider: true,
            link: assets,
            path: 'data.emissiveIntensity'
        });
        fieldEmissiveIntensitySlider.flexGrow = 4;


        // opacity
        var panelOpacity = editor.call('attributes:addPanel', {
            foldable: true,
            folded: panelState['opacity'],
            name: 'Opacity'
        });
        panelOpacity.class.add('component');
        panelOpacity.on('fold', function() { panelState['opacity'] = true; });
        panelOpacity.on('unfold', function() { panelState['opacity'] = false; });
        // reference
        editor.call('attributes:reference:asset:material:opacityOverview:attach', panelOpacity, panelOpacity.headerElement);

        var filterBlendFields = function (value) {
            fieldOpacityIntensity.parent.hidden = ! (fieldBlendType.value === '' || [ 2, 4, 6 ].indexOf(fieldBlendType.value) !== -1);
            fieldOpacityOffset[0].parent.hidden = filterOpacityOffset();
            fieldOpacityTiling[0].parent.hidden = filterOpacityTiling();
            fieldAlphaTest.parent.hidden = ! (fieldOpacityMap.class.contains('null') || fieldOpacityMap.value) && ! (fieldOpacityVertexColor.value || fieldOpacityVertexColor.class.contains('null'));
        };

        // blend type
        var fieldBlendType = editor.call('attributes:addField', {
            parent: panelOpacity,
            type: 'number',
            enum: mapping.blendType.enum,
            name: 'Blend Type',
            link: assets,
            path: 'data.blendType'
        });
        fieldBlendType.on('change', filterBlendFields);
        // reference
        editor.call('attributes:reference:asset:material:blendType:attach', fieldBlendType.parent.innerElement.firstChild.ui);

        // map
        var fieldOpacityMapHover = handleTextureHover('opacityMap');
        var fieldOpacityMap = editor.call('attributes:addField', {
            parent: panelOpacity,
            type: 'asset',
            kind: 'texture',
            name: 'Opacity',
            link: assets,
            path: 'data.opacityMap',
            over: fieldOpacityMapHover.over,
            leave: fieldOpacityMapHover.leave
        });
        fieldOpacityMap.parent.class.add('channel');
        fieldOpacityMap.on('change', filterBlendFields);
        // reference
        editor.call('attributes:reference:asset:material:opacityMap:attach', fieldOpacityMap._label);

        // map uv
        var fieldOpacityMapUV = editor.call('attributes:addField', {
            panel: fieldOpacityMap.parent,
            type: 'number',
            enum: mapping.opacityMapUv.enum,
            link: assets,
            path: 'data.opacityMapUv'
        });
        fieldOpacityMapUV.flexGrow = 0;
        fieldOpacityMapUV.element.parentNode.removeChild(fieldOpacityMapUV.element);
        fieldOpacityMap.parent.innerElement.querySelector('.top > .controls').appendChild(fieldOpacityMapUV.element);
        // reference
        editor.call('attributes:reference:asset:material:opacityMapUv:attach', fieldOpacityMapUV);

        // map channel
        var fieldOpacityMapChannel = editor.call('attributes:addField', {
            panel: fieldOpacityMap.parent,
            type: 'string',
            enum: {
                '': '...',
                'r': 'R',
                'g': 'G',
                'b': 'B',
                'a': 'A'
            },
            link: assets,
            path: 'data.opacityMapChannel'
        });
        fieldOpacityMapChannel.element.parentNode.removeChild(fieldOpacityMapChannel.element);
        fieldOpacityMap.parent.innerElement.querySelector('.top > .ui-label').parentNode.appendChild(fieldOpacityMapChannel.element);
        // reference
        editor.call('attributes:reference:asset:material:opacityMapChannel:attach', fieldOpacityMapChannel);

        // offset
        var fieldOpacityOffset = editor.call('attributes:addField', {
            parent: panelOpacity,
            type: 'vec2',
            name: 'Offset',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.opacityMapOffset'
        });
        var filterOpacityOffset = function() {
            return fieldOpacityMap.parent.hidden || (! fieldOpacityMap.value && ! fieldOpacityMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldOpacityOffset[0].parent,
            offset: fieldOpacityOffset,
            filter: filterOpacityOffset,
            path: 'data.opacityMapOffset'
        });
        fieldOpacityOffset[0].parent.hidden = filterOpacityOffset();
        // reference
        editor.call('attributes:reference:asset:material:opacityMapOffset:attach', fieldOpacityOffset[0].parent.innerElement.firstChild.ui);

        // tiling
        var fieldOpacityTiling = editor.call('attributes:addField', {
            parent: panelOpacity,
            type: 'vec2',
            name: 'Tiling',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.opacityMapTiling'
        });
        var filterOpacityTiling = function() {
            return fieldOpacityMap.parent.hidden || (! fieldOpacityMap.value && ! fieldOpacityMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldOpacityTiling[0].parent,
            tiling: fieldOpacityTiling,
            filter: filterOpacityTiling,
            path: 'data.opacityMapTiling'
        });
        fieldOpacityTiling[0].parent.hidden = filterOpacityTiling();
        // reference
        editor.call('attributes:reference:asset:material:opacityMapTiling:attach', fieldOpacityTiling[0].parent.innerElement.firstChild.ui);

        // vertex color
        var fieldOpacityVertexColor = editor.call('attributes:addField', {
            parent: panelOpacity,
            name: 'Vertex Color',
            type: 'checkbox',
            link: assets,
            path: 'data.opacityMapVertexColor'
        });
        fieldOpacityVertexColor.on('change', filterBlendFields);
        // reference
        editor.call('attributes:reference:asset:material:opacityMapVertexColor:attach', fieldOpacityVertexColor.parent.innerElement.firstChild.ui);

        // intensity
        var fieldOpacityIntensity = editor.call('attributes:addField', {
            parent: panelOpacity,
            name: 'Intensity',
            type: 'number',
            precision: 3,
            step: .05,
            min: 0,
            max: 1,
            link: assets,
            path: 'data.opacity'
        });
        fieldOpacityIntensity.style.width = '32px';
        fieldOpacityIntensity.flexGrow = 1;
        // reference
        editor.call('attributes:reference:asset:material:opacity:attach', fieldOpacityIntensity.parent.innerElement.firstChild.ui);

        // intensity slider
        var fieldOpacityIntensitySlider = editor.call('attributes:addField', {
            panel: fieldOpacityIntensity.parent,
            precision: 3,
            step: .05,
            min: 0,
            max: 1,
            type: 'number',
            slider: true,
            link: assets,
            path: 'data.opacity'
        });
        fieldOpacityIntensitySlider.flexGrow = 4;

        // alphaTest
        var fieldAlphaTest = editor.call('attributes:addField', {
            parent: panelOpacity,
            name: 'Alpha Test',
            type: 'number',
            precision: 3,
            step: .05,
            min: 0,
            max: 1,
            link: assets,
            path: 'data.alphaTest'
        });
        fieldAlphaTest.style.width = '32px';
        fieldAlphaTest.flexGrow = 1;
        // reference
        editor.call('attributes:reference:asset:material:alphaTest:attach', fieldAlphaTest.parent.innerElement.firstChild.ui);

        // alphaTest slider
        var fieldAlphaTestSlider = editor.call('attributes:addField', {
            panel: fieldAlphaTest.parent,
            precision: 3,
            step: .05,
            min: 0,
            max: 1,
            type: 'number',
            slider: true,
            link: assets,
            path: 'data.alphaTest'
        });
        fieldAlphaTestSlider.flexGrow = 4;

        filterBlendFields();


        // normals
        var panelNormal = editor.call('attributes:addPanel', {
            foldable: true,
            folded: panelState['normals'],
            name: 'Normals'
        });
        panelNormal.class.add('component');
        panelNormal.on('fold', function() { panelState['normals'] = true; });
        panelNormal.on('unfold', function() { panelState['normals'] = false; });
        // reference
        editor.call('attributes:reference:asset:material:normalOverview:attach', panelNormal, panelNormal.headerElement);

        // map (normals)
        var fieldNormalMapHover = handleTextureHover('normalMap');
        var fieldNormalMap = editor.call('attributes:addField', {
            parent: panelNormal,
            type: 'asset',
            kind: 'texture',
            name: 'Normals',
            link: assets,
            path: 'data.normalMap',
            over: fieldNormalMapHover.over,
            leave: fieldNormalMapHover.leave
        });
        fieldNormalMap.on('change', function(value) {
            fieldNormalsOffset[0].parent.hidden = filterNormalOffset();
            fieldNormalsTiling[0].parent.hidden = filterNormalTiling();
            fieldBumpiness.parent.hidden = ! value && ! this.class.contains('null');
        });
        // reference
        editor.call('attributes:reference:asset:material:normalMap:attach', fieldNormalMap._label);

        // map uv
        var fieldNormalMapUV = editor.call('attributes:addField', {
            panel: fieldNormalMap.parent,
            type: 'number',
            enum: mapping.normalMapUv.enum,
            link: assets,
            path: 'data.normalMapUv'
        });
        fieldNormalMapUV.flexGrow = 0;
        fieldNormalMapUV.element.parentNode.removeChild(fieldNormalMapUV.element);
        fieldNormalMap.parent.innerElement.querySelector('.top > .controls').appendChild(fieldNormalMapUV.element);
        // reference
        editor.call('attributes:reference:asset:material:normalMapUv:attach', fieldNormalMapUV);


        // offset
        var fieldNormalsOffset = editor.call('attributes:addField', {
            parent: panelNormal,
            type: 'vec2',
            name: 'Offset',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.normalMapOffset'
        });
        var filterNormalOffset = function() {
            return (! fieldNormalMap.value && ! fieldNormalMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldNormalsOffset[0].parent,
            offset: fieldNormalsOffset,
            filter: filterNormalOffset,
            path: 'data.normalMapOffset'
        });
        fieldNormalsOffset[0].parent.hidden = filterNormalOffset();
        // reference
        editor.call('attributes:reference:asset:material:normalMapOffset:attach', fieldNormalsOffset[0].parent.innerElement.firstChild.ui);

        // tiling
        var fieldNormalsTiling = editor.call('attributes:addField', {
            parent: panelNormal,
            type: 'vec2',
            name: 'Tiling',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.normalMapTiling'
        });
        var filterNormalTiling = function() {
            return (! fieldNormalMap.value && ! fieldNormalMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldNormalsTiling[0].parent,
            tiling: fieldNormalsTiling,
            filter: filterNormalTiling,
            path: 'data.normalMapTiling'
        });
        fieldNormalsTiling[0].parent.hidden = filterNormalTiling();
        // reference
        editor.call('attributes:reference:asset:material:normalMapTiling:attach', fieldNormalsTiling[0].parent.innerElement.firstChild.ui);


        // bumpiness
        var fieldBumpiness = editor.call('attributes:addField', {
            parent: panelNormal,
            name: 'Bumpiness',
            type: 'number',
            precision: 3,
            step: .05,
            min: 0,
            max: 2,
            link: assets,
            path: 'data.bumpMapFactor'
        });
        fieldBumpiness.parent.hidden = ! fieldNormalMap.value && ! fieldNormalMap.class.contains('null');
        fieldBumpiness.style.width = '32px';
        fieldBumpiness.flexGrow = 1;
        // reference
        editor.call('attributes:reference:asset:material:bumpiness:attach', fieldBumpiness.parent.innerElement.firstChild.ui);

        // bumpiness slider
        var fieldBumpinessSlider = editor.call('attributes:addField', {
            panel: fieldBumpiness.parent,
            precision: 3,
            step: .05,
            min: 0,
            max: 2,
            type: 'number',
            slider: true,
            link: assets,
            path: 'data.bumpMapFactor'
        });
        fieldBumpinessSlider.flexGrow = 4;


        // parallax
        var panelParallax = editor.call('attributes:addPanel', {
            foldable: true,
            folded: panelState['height'],
            name: 'Parallax'
        });
        panelParallax.class.add('component');
        panelParallax.on('fold', function() { panelState['height'] = true; });
        panelParallax.on('unfold', function() { panelState['height'] = false; });
        // reference
        editor.call('attributes:reference:asset:material:parallaxOverview:attach', panelParallax, panelParallax.headerElement);

        // height map
        var fieldHeightMapHover = handleTextureHover('heightMap');
        var fieldHeightMap = editor.call('attributes:addField', {
            parent: panelParallax,
            type: 'asset',
            kind: 'texture',
            name: 'Heightmap',
            link: assets,
            path: 'data.heightMap',
            over: fieldHeightMapHover.over,
            leave: fieldHeightMapHover.leave
        });
        fieldHeightMap.parent.class.add('channel');
        fieldHeightMap.on('change', function(value) {
            fieldHeightMapOffset[0].parent.hidden = filterHeightMapOffset();
            fieldHeightMapTiling[0].parent.hidden = filterHeightMapTiling();
            fieldHeightMapFactor.parent.hidden = ! value;
        });
        // reference
        editor.call('attributes:reference:asset:material:heightMap:attach', fieldHeightMap._label);

        // map uv
        var fieldHeightMapUV = editor.call('attributes:addField', {
            panel: fieldHeightMap.parent,
            type: 'number',
            enum: mapping.heightMapUv.enum,
            link: assets,
            path: 'data.heightMapUv'
        });
        fieldHeightMapUV.flexGrow = 0;
        fieldHeightMapUV.element.parentNode.removeChild(fieldHeightMapUV.element);
        fieldHeightMap.parent.innerElement.querySelector('.top > .controls').appendChild(fieldHeightMapUV.element);
        // reference
        editor.call('attributes:reference:asset:material:heightMapUv:attach', fieldHeightMapUV);

        // map channel
        var fieldHeightMapChannel = editor.call('attributes:addField', {
            panel: fieldHeightMap.parent,
            type: 'string',
            enum: {
                '': '...',
                'r': 'R',
                'g': 'G',
                'b': 'B',
                'a': 'A'
            },
            link: assets,
            path: 'data.heightMapChannel'
        });
        fieldHeightMapChannel.element.parentNode.removeChild(fieldHeightMapChannel.element);
        fieldHeightMap.parent.innerElement.querySelector('.top > .ui-label').parentNode.appendChild(fieldHeightMapChannel.element);
        // reference
        editor.call('attributes:reference:asset:material:heightMapChannel:attach', fieldHeightMapChannel);


        // offset
        var fieldHeightMapOffset = editor.call('attributes:addField', {
            parent: panelParallax,
            type: 'vec2',
            name: 'Offset',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.heightMapOffset'
        });
        var filterHeightMapOffset = function() {
            return fieldHeightMap.parent.hidden || (! fieldHeightMap.value && ! fieldHeightMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldHeightMapOffset[0].parent,
            offset: fieldHeightMapOffset,
            filter: filterHeightMapOffset,
            path: 'data.heightMapOffset'
        });
        fieldHeightMapOffset[0].parent.hidden = filterHeightMapOffset();
        // reference
        editor.call('attributes:reference:asset:material:heightMapOffset:attach', fieldHeightMapOffset[0].parent.innerElement.firstChild.ui);

        // tiling
        var fieldHeightMapTiling = editor.call('attributes:addField', {
            parent: panelParallax,
            type: 'vec2',
            name: 'Tiling',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.heightMapTiling'
        });
        var filterHeightMapTiling = function() {
            return fieldHeightMap.parent.hidden || (! fieldHeightMap.value && ! fieldHeightMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldHeightMapTiling[0].parent,
            tiling: fieldHeightMapTiling,
            filter: filterHeightMapTiling,
            path: 'data.heightMapTiling'
        });
        fieldHeightMapTiling[0].parent.hidden = filterHeightMapTiling();
        // reference
        editor.call('attributes:reference:asset:material:heightMapTiling:attach', fieldHeightMapTiling[0].parent.innerElement.firstChild.ui);


        // heightMapFactor
        var fieldHeightMapFactor = editor.call('attributes:addField', {
            parent: panelParallax,
            name: 'Strength',
            type: 'number',
            precision: 3,
            step: .05,
            min: 0,
            max: 2,
            link: assets,
            path: 'data.heightMapFactor'
        });
        fieldHeightMapFactor.parent.hidden = fieldHeightMap.parent.hidden;
        fieldHeightMapFactor.style.width = '32px';
        fieldHeightMapFactor.flexGrow = 1;
        // reference
        editor.call('attributes:reference:asset:material:bumpiness:attach', fieldHeightMapFactor.parent.innerElement.firstChild.ui);

        // heightMapFactor slider
        var fieldHeightMapFactorSlider = editor.call('attributes:addField', {
            panel: fieldHeightMapFactor.parent,
            precision: 3,
            step: .05,
            min: 0,
            max: 2,
            type: 'number',
            slider: true,
            link: assets,
            path: 'data.heightMapFactor'
        });
        fieldHeightMapFactorSlider.flexGrow = 4;


        // reflection
        var panelReflection = editor.call('attributes:addPanel', {
            foldable: true,
            folded: panelState['environment'],
            name: 'Environment'
        });
        panelReflection.class.add('component');
        panelReflection.on('fold', function() { panelState['environment'] = true; });
        panelReflection.on('unfold', function() { panelState['environment'] = false; });
        // reference
        editor.call('attributes:reference:asset:material:environmentOverview:attach', panelReflection, panelReflection.headerElement);
        // filter
        var filterReflectionMaps = function() {
            fieldReflectionCubeMap.parent.hidden = ! fieldReflectionCubeMap.value && ! fieldReflectionCubeMap.class.contains('null') && (fieldReflectionSphere.value || fieldReflectionSphere.class.contains('null'));
            fieldReflectionSphere.parent.hidden = ! fieldReflectionSphere.value && ! fieldReflectionSphere.class.contains('null') && (fieldReflectionCubeMap.value || fieldReflectionCubeMap.class.contains('null'));
        };
        // spheremap
        var fieldReflectionSphereHover = handleTextureHover('sphereMap');
        var fieldReflectionSphere = editor.call('attributes:addField', {
            parent: panelReflection,
            type: 'asset',
            kind: 'texture',
            name: 'Sphere Map',
            link: assets,
            path: 'data.sphereMap',
            over: fieldReflectionSphereHover.over,
            leave: fieldReflectionSphereHover.leave
        });
        fieldReflectionSphere.on('change', filterReflectionMaps);
        // reference
        editor.call('attributes:reference:asset:material:sphereMap:attach', fieldReflectionSphere._label);

        // cubemap
        var fieldReflectionCubeMap = editor.call('attributes:addField', {
            parent: panelReflection,
            type: 'asset',
            kind: 'cubemap',
            name: 'Cube Map',
            link: assets,
            path: 'data.cubeMap'
        });
        fieldReflectionCubeMap.on('change', filterReflectionMaps);
        // reference
        editor.call('attributes:reference:asset:material:cubeMap:attach', fieldReflectionCubeMap._label);

        // reflectivity
        var fieldReflectionStrength = editor.call('attributes:addField', {
            parent: panelReflection,
            type: 'number',
            precision: 3,
            step: 0.01,
            min: 0,
            max: 1,
            name: 'Reflectivity',
            link: assets,
            path: 'data.reflectivity'
        });
        fieldReflectionStrength.style.width = '32px';
        // reference
        editor.call('attributes:reference:asset:material:reflectivity:attach', fieldReflectionStrength.parent.innerElement.firstChild.ui);

        // reflectivity slider
        var fieldReflectionStrengthSlider = editor.call('attributes:addField', {
            panel: fieldReflectionStrength.parent,
            precision: 3,
            step: .01,
            min: 0,
            max: 1,
            type: 'number',
            slider: true,
            link: assets,
            path: 'data.reflectivity'
        });
        fieldReflectionStrengthSlider.flexGrow = 4;


        // refraction
        var fieldRefraction = editor.call('attributes:addField', {
            parent: panelReflection,
            type: 'number',
            precision: 3,
            step: 0.01,
            min: 0,
            max: 1,
            name: 'Refraction',
            link: assets,
            path: 'data.refraction'
        });
        fieldRefraction.style.width = '32px';
        // reference
        editor.call('attributes:reference:asset:material:refraction:attach', fieldRefraction.parent.innerElement.firstChild.ui);

        // reflectivity slider
        var fieldRefractionSlider = editor.call('attributes:addField', {
            panel: fieldRefraction.parent,
            precision: 3,
            step: .01,
            min: 0,
            max: 1,
            type: 'number',
            slider: true,
            link: assets,
            path: 'data.refraction'
        });
        fieldRefractionSlider.flexGrow = 4;


        // refractionIndex
        var fieldRefractionIndex = editor.call('attributes:addField', {
            parent: panelReflection,
            type: 'number',
            precision: 3,
            step: 0.01,
            min: 0,
            max: 1,
            name: 'Index of Refraction',
            link: assets,
            path: 'data.refractionIndex'
        });
        fieldRefractionIndex.style.width = '32px';
        // reference
        editor.call('attributes:reference:asset:material:refractionIndex:attach', fieldRefractionIndex.parent.innerElement.firstChild.ui);

        // reflectivity slider
        var fieldRefractionIndexSlider = editor.call('attributes:addField', {
            panel: fieldRefractionIndex.parent,
            precision: 3,
            step: .01,
            min: 0,
            max: 1,
            type: 'number',
            slider: true,
            link: assets,
            path: 'data.refractionIndex'
        });
        fieldRefractionIndexSlider.flexGrow = 4;

        filterReflectionMaps();


        // lightmap
        var panelLightMap = editor.call('attributes:addPanel', {
            foldable: true,
            folded: panelState['light'],
            name: 'LightMap'
        });
        panelLightMap.class.add('component');
        panelLightMap.on('fold', function() { panelState['light'] = true; });
        panelLightMap.on('unfold', function() { panelState['light'] = false; });
        // reference
        editor.call('attributes:reference:asset:material:lightMapOverview:attach', panelLightMap, panelLightMap.headerElement);

        // map
        var fieldLightMapHover = handleTextureHover('lightMap');
        var fieldLightMap = editor.call('attributes:addField', {
            parent: panelLightMap,
            type: 'asset',
            kind: 'texture',
            name: 'Lightmap',
            link: assets,
            path: 'data.lightMap',
            over: fieldLightMapHover.over,
            leave: fieldLightMapHover.leave
        });
        fieldLightMap.parent.class.add('channel');
        fieldLightMap.on('change', function (value) {
            fieldLightMapOffset[0].parent.hidden = filterLightMapOffset();
            fieldLightMapTiling[0].parent.hidden = filterLightMapTiling();
        });
        // reference
        editor.call('attributes:reference:asset:material:lightMap:attach', fieldLightMap._label);

        // map uv
        var fieldLightMapUV = editor.call('attributes:addField', {
            panel: fieldLightMap.parent,
            type: 'number',
            enum: mapping.lightMapUv.enum,
            link: assets,
            path: 'data.lightMapUv'
        });
        fieldLightMapUV.flexGrow = 0;
        fieldLightMapUV.element.parentNode.removeChild(fieldLightMapUV.element);
        fieldLightMap.parent.innerElement.querySelector('.top > .controls').appendChild(fieldLightMapUV.element);
        // reference
        editor.call('attributes:reference:asset:material:lightMapUv:attach', fieldLightMapUV);

        // map channel
        var fieldLightMapChannel = editor.call('attributes:addField', {
            panel: fieldLightMap.parent,
            type: 'string',
            enum: {
                '': '...',
                'r': 'R',
                'g': 'G',
                'b': 'B',
                'a': 'A',
                'rgb': 'RGB'
            },
            link: assets,
            path: 'data.lightMapChannel'
        });
        fieldLightMapChannel.element.parentNode.removeChild(fieldLightMapChannel.element);
        fieldLightMap.parent.innerElement.querySelector('.top > .ui-label').parentNode.appendChild(fieldLightMapChannel.element);
        // reference
        editor.call('attributes:reference:asset:material:lightMapChannel:attach', fieldLightMapChannel);


        // offset
        var fieldLightMapOffset = editor.call('attributes:addField', {
            parent: panelLightMap,
            type: 'vec2',
            name: 'Offset',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.lightMapOffset'
        });
        var filterLightMapOffset = function() {
            return fieldLightMap.parent.hidden || (! fieldLightMap.value && ! fieldLightMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldLightMapOffset[0].parent,
            offset: fieldLightMapOffset,
            filter: filterLightMapOffset,
            path: 'data.lightMapOffset'
        });
        fieldLightMapOffset[0].parent.hidden = filterLightMapOffset();
        // reference
        editor.call('attributes:reference:asset:material:lightMapOffset:attach', fieldLightMapOffset[0].parent.innerElement.firstChild.ui);

        // tiling
        var fieldLightMapTiling = editor.call('attributes:addField', {
            parent: panelLightMap,
            type: 'vec2',
            name: 'Tiling',
            placeholder: [ 'U', 'V' ],
            link: assets,
            path: 'data.lightMapTiling'
        });
        var filterLightMapTiling = function() {
            return fieldLightMap.parent.hidden || (! fieldLightMap.value && ! fieldLightMap.class.contains('null')) || fieldTilingOffset.value;
        };
        tilingOffsetFields.push({
            element: fieldLightMapTiling[0].parent,
            tiling: fieldLightMapTiling,
            filter: filterLightMapTiling,
            path: 'data.lightMapTiling'
        });
        fieldLightMapTiling[0].parent.hidden = filterLightMapTiling();
        // reference
        editor.call('attributes:reference:asset:material:lightMapTiling:attach', fieldLightMapTiling[0].parent.innerElement.firstChild.ui);

        // vertex color
        var fieldLightVertexColor = editor.call('attributes:addField', {
            parent: panelLightMap,
            name: 'Vertex Color',
            type: 'checkbox',
            link: assets,
            path: 'data.lightMapVertexColor'
        });
        // reference
        editor.call('attributes:reference:asset:material:lightMapVertexColor:attach', fieldLightVertexColor.parent.innerElement.firstChild.ui);

        // render states
        var panelRenderStates = editor.call('attributes:addPanel', {
            foldable: true,
            folded: panelState['states'],
            name: 'Other'
        });
        panelRenderStates.class.add('component');
        panelRenderStates.on('fold', function() { panelState['states'] = true; });
        panelRenderStates.on('unfold', function() { panelState['states'] = false; });
        // reference
        editor.call('attributes:reference:asset:material:other:attach', panelRenderStates, panelRenderStates.headerElement);


        // depth
        var fieldDepthTest = editor.call('attributes:addField', {
            parent: panelRenderStates,
            type: 'checkbox',
            name: 'Depth',
            link: assets,
            path: 'data.depthTest'
        });
        // label
        var label = new ui.Label({ text: 'Test' });
        label.style.verticalAlign = 'top';
        label.style.paddingRight = '12px';
        label.style.fontSize = '12px';
        label.style.lineHeight = '24px';
        fieldDepthTest.parent.append(label);
        // reference
        editor.call('attributes:reference:asset:material:depthTest:attach', label);


        // depthWrite
        var fieldDepthWrite = editor.call('attributes:addField', {
            panel: fieldDepthTest.parent,
            type: 'checkbox',
            link: assets,
            path: 'data.depthWrite'
        })
        // label
        var label = new ui.Label({ text: 'Write' });
        label.style.verticalAlign = 'top';
        label.style.fontSize = '12px';
        label.style.lineHeight = '24px';
        fieldDepthTest.parent.append(label);
        // reference
        editor.call('attributes:reference:asset:material:depthWrite:attach', label);


        // culling
        var fieldCull = editor.call('attributes:addField', {
            parent: panelRenderStates,
            type: 'number',
            enum: mapping.cull.enum,
            name: 'Cull Mode',
            link: assets,
            path: 'data.cull'
        });
        // reference
        editor.call('attributes:reference:asset:material:cull:attach', fieldCull.parent.innerElement.firstChild.ui);

        // shadowSampleType
        var fieldShadowSampleType = editor.call('attributes:addField', {
            parent: panelRenderStates,
            type: 'number',
            enum: mapping.shadowSampleType.enum,
            name: 'Shadow Sample Type',
            link: assets,
            path: 'data.shadowSampleType'
        });
        // reference
        editor.call('attributes:reference:asset:material:shadowSampleType:attach', fieldShadowSampleType.parent.innerElement.firstChild.ui);

        // attach change event on tiling / offset fields
        // to set initial value if it doesn't exist
        tilingOffsetFields.forEach(function (item) {
            var field = item.tiling || item.offset;
            var onChange = function () {
                var path = item.path;
                for (var i = 0, len = assets.length; i < len; i++) {
                    if (missingPaths[assets[i].get('id') + '.' + path]) {
                        assets[i].set(path, [field[0].value, field[1].value]);
                        delete missingPaths[assets[i].get('id') + '.' + path];
                    }
                }
            }

            // make sure our change event is first otherwise
            // sharejs will complain that we can't insert a value on
            // a list that does not exist
            field[0]._events.change.splice(0, 0, onChange);
            field[1]._events.change.splice(0, 0, onChange);
        });
    });
});


/* editor/attributes/assets/attributes-asset-model.js */
editor.once('load', function() {
    'use strict';

    var pickMaterial = function(assetId, fn) {
        var asset = editor.call('assets:get', assetId);
        editor.call('picker:asset', 'material', asset);

        var evtPick = editor.once('picker:asset', function(asset) {
            fn(asset.get('id'));
            evtPick = null;
        });

        editor.once('picker:asset:close', function() {
            if (evtPick) {
                evtPick.unbind();
                evtPick = null;
            }
        });
    };

    var panelNodes = null;

    editor.method('attributes:asset:model:nodesPanel', function () {
        return panelNodes;
    });

    editor.on('attributes:inspect[asset]', function(assets) {
        if (assets.length !== 1 || assets[0].get('type') !== 'model' || assets[0].get('source'))
            return;

        var asset = assets[0];

        if (asset.has('data.mapping') && asset.get('data.mapping').length) {
            var root = editor.call('attributes.rootPanel');

            // preview
            var canvas = document.createElement('canvas');
            var ctx = canvas.getContext('2d');
            canvas.classList.add('asset-preview');

            root.element.insertBefore(canvas, root.innerElement);
            root.class.add('asset-preview');

            requestAnimationFrame(function() {
                root.class.add('animate');
            });

            canvas.addEventListener('click', function() {
                if (root.element.classList.contains('large')) {
                    root.element.classList.remove('large');
                } else {
                    root.element.classList.add('large');
                }
            }, false);

            var renderPreview = function () {
                // resize canvas
                canvas.width = root.element.clientWidth;
                canvas.height = canvas.width;
                editor.call('preview:render:model', asset, canvas.width, function (sourceCanvas) {
                    ctx.drawImage(sourceCanvas, 0, 0);
                });
            };
            renderPreview();

            var renderTimeout;

            var evtPanelResize = root.on('resize', function () {
                if (renderTimeout)
                    clearTimeout(renderTimeout);

                renderTimeout = setTimeout(renderPreview, 100);
            });

            // nodes panel
            panelNodes = editor.call('attributes:addPanel', {
                name: 'Mesh Instances'
            });
            panelNodes.class.add('component');

            // reference
            editor.call('attributes:reference:asset:model:meshInstances:attach', panelNodes, panelNodes.headerElement);

            var nodeItems = [ ];

            var addField = function(ind) {
                var engineAsset = editor.call('viewport:framework').assets.get(asset.get('id'));
                var valueBefore = null;

                nodeItems[ind] = editor.call('attributes:addField', {
                    parent: panelNodes,
                    type: 'asset',
                    kind: 'material',
                    name: 'node ' + ind,
                    link: asset,
                    path: 'data.mapping.' + ind + '.material',
                    over: function(type, data) {
                        valueBefore = asset.get('data.mapping.' + ind + '.material') || null;
                        if (engineAsset) {
                            engineAsset.data.mapping[ind].material = parseInt(data.id, 10);
                            engineAsset.fire('change', engineAsset, 'data', engineAsset.data, engineAsset.data);
                            editor.call('viewport:render');
                        }
                    },
                    leave: function() {
                        if (valueBefore) {
                            engineAsset.data.mapping[ind].material = valueBefore;
                            engineAsset.fire('change', engineAsset, 'data', engineAsset.data, engineAsset.data);
                            editor.call('viewport:render');
                        }
                    }
                });

                nodeItems[ind].parent.class.add('node-' + ind);

                nodeItems[ind].parent.on('click', function() {
                    this.class.remove('active');
                });
            };

            // create node fields
            var mapping = asset.get('data.mapping');
            for(var i = 0; i < mapping.length; i++)
                addField(i);

            panelNodes.on('destroy', function () {
                root.class.remove('asset-preview', 'animate');
                if (canvas.parentNode)
                    canvas.parentNode.removeChild(canvas);
                evtPanelResize.unbind();
                if (evtHide)
                    evtHide.unbind();
                panelNodes = null;
            });

            // hide preview when asset info is hidden
            var evtHide = editor.once('attributes:assets:toggleInfo', function (toggle) {
                evtHide = null;
                root.class.remove('asset-preview', 'animate');
                canvas.parentNode.removeChild(canvas);
                evtPanelResize.unbind();
            });

            // template nodes
            var nodesTemplate = function() {
                for(var i = 0; i < asset._nodes.length; i++) {
                    if (! nodeItems[i])
                        continue;

                    nodeItems[i]._label.text = asset._nodes[i];
                }
            };

            if (asset._nodes) {
                // already loaded
                nodesTemplate();
            } else {
                // loading
                var loading = editor.call('attributes:addField', {
                    type: 'progress'
                });
                loading.on('progress:100', function() {
                    this.destroy();
                });

                // load data
                var loadData = function() {
                    Ajax
                    .get('{{url.home}}/' + asset.get('file.url'))
                    .on('load', function(status, data) {
                        asset._nodes = [ ];
                        for(var i = 0; i < data.model.meshInstances.length; i++) {
                            asset._nodes[data.model.meshInstances[i].mesh] = data.model.nodes[data.model.meshInstances[i].node].name;
                        }
                        nodesTemplate();

                        loading.progress = 1;
                    })
                    .on('progress', function(progress) {
                        loading.progress = 0.1 + progress * 0.8;
                    })
                    .on('error', function() {
                        loading.failed = true;

                        var error = new ui.Label({ text: 'failed loading detailed data' });
                        error.textContent = 'failed loading data';
                        error.style.display = 'block';
                        error.style.textAlign = 'center';
                        error.style.fontWeight = '100';
                        error.style.fontSize = '12px';
                        error.style.color = '#f66';
                        editor.call('attributes.rootPanel').append(error);

                        loading.progress = 1;
                    });

                    loading.progress = 0.1;
                }

                if (asset.has('file.url'))
                    loadData();

                var evtReload = asset.on('file.hash:set', function() {
                    loadData();
                });

                panelNodes.once('destroy', function() {
                    evtReload.unbind();
                });
            }

            return panelNodes;
        }
    });
});


/* editor/attributes/assets/attributes-asset-scene.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[asset]', function(assets) {
        if (assets.length !== 1 || assets[0].get('type') !== 'scene' || ! assets[0].get('source'))
            return;

        var asset = assets[0];
        var events = [ ];

        // panel
        var panel = editor.call('attributes:addPanel');
        panel.class.add('component');

        // download
        var btnDownload = new ui.Button();
        btnDownload.text = 'Download';
        btnDownload.class.add('download-asset');
        btnDownload.element.addEventListener('click', function(evt) {
            window.open(asset.get('file.url'));
        }, false);
        panel.append(btnDownload);


        // contents
        var panelContents = editor.call('attributes:addPanel', {
            name: 'Contents'
        });
        panelContents.class.add('component');
        // reference
        editor.call('attributes:reference:asset:scene:contents:attach', panelContents, panelContents.headerElement);


        var labelEmptyMeta = new ui.Label({
            text: 'no contents information available'
        });
        labelEmptyMeta.hidden = !! asset.get('meta');
        panelContents.append(labelEmptyMeta);


        // meta
        var panelMeta = editor.call('attributes:addPanel');
        panelMeta.hidden = ! asset.get('meta');
        events.push(asset.on('meta:set', function() {
            panelMeta.hidden = false;
            labelEmptyMeta.hidden = true;
        }));
        events.push(asset.on('meta:unset', function() {
            panelMeta.hidden = true;
            labelEmptyMeta.hidden = false;
        }));
        panelContents.append(panelMeta);


        // animation
        var fieldAnimation = editor.call('attributes:addField', {
            parent: panelMeta,
            name: 'Animation',
            link: asset,
            path: 'meta.animation.available'
        });


        // textures
        var fieldTextures = editor.call('attributes:addField', {
            parent: panelMeta,
            name: 'Textures',
            type: 'element',
            element: new ui.List()
        })
        fieldTextures.flexGrow = 1;
        // add all textures
        var addTextures = function(list) {
            fieldTextures.clear();
            for(var i = 0; i < list.length; i++) {
                var item = new ui.ListItem({
                    text: list[i].name
                });
                fieldTextures.append(item);
            }
        };
        // already available
        var textures = asset.get('meta.textures');
        if (textures && textures.length)
            addTextures(textures);
        // might be set later
        events.push(asset.on('meta.textures:set', function() {
            addTextures(asset.get('meta.textures'));
        }));
        events.push(asset.on('meta.textures:unset', function() {
            fieldTextures.clear();
        }));


        // materials
        var fieldMaterials = editor.call('attributes:addField', {
            parent: panelMeta,
            name: 'Materials',
            type: 'element',
            element: new ui.List()
        })
        fieldMaterials.flexGrow = 1;
        // add all materials
        var addMaterials = function(list) {
            fieldMaterials.clear();
            for(var i = 0; i < list.length; i++) {
                var item = new ui.ListItem({
                    text: list[i].name
                });
                fieldMaterials.append(item);
            }
        };
        // already available
        var materials = asset.get('meta.materials');
        if (materials && materials.length)
            addMaterials(materials);
        // might be set/unset later
        events.push(asset.on('meta.materials:set', function(materials) {
            for(var i = 0; i < materials.length; i++)
                materials[i] = materials[i].json();

            addMaterials(materials);
        }));
        events.push(asset.on('meta.materials:unset', function() {
            fieldMaterials.clear();
        }));


        // clear up events
        panel.once('destroy', function() {
            for(var i = 0; i < events.length; i++)
                events[i].unbind();
        });
    });
});


/* editor/attributes/assets/attributes-asset-script.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[asset]', function(assets) {
        if (assets.length !== 1 || assets[0].get('type') !== 'script' || assets[0].get('source'))
            return;

        var asset = assets[0];

        // panel
        var panel = editor.call('attributes:addPanel');
        panel.class.add('component');

        // edit
        var btnEdit = new ui.Button();
        btnEdit.text = editor.call('permissions:write') ? 'Edit' : 'View';
        btnEdit.class.add('edit-script');
        btnEdit.element.addEventListener('click', function(evt) {
            window.open('/editor/code/' + config.project.id + '/' + asset.get('filename'));
        }, false);
        panel.append(btnEdit);
    });
});


/* editor/attributes/assets/attributes-asset-shader.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[asset]', function(assets) {
        if (assets.length !== 1 || assets[0].get('type') !== 'shader' || assets[0].get('source'))
            return;

        var asset = assets[0];

        // panel
        var panel = editor.call('attributes:addPanel');
        panel.class.add('component');

        // edit
        var btnEdit = new ui.Button();
        btnEdit.text = editor.call('permissions:write') ? 'Edit' : 'View';
        btnEdit.class.add('edit-script');
        btnEdit.hidden = ! asset.has('file.url');
        btnEdit.element.addEventListener('click', function(evt) {
            window.open('/editor/asset/' + asset.get('id'));
        }, false);
        panel.append(btnEdit);
        var evtFileUrl = asset.on('file.url:set', function() {
            btnEdit.hidden = false;
        });
        var evtFileUrlUnset = asset.on('file.url:unset', function() {
            btnEdit.hidden = true;
        });

        var panelRaw = editor.call('attributes:addPanel', {
            name: 'Shader'
        });
        panelRaw.class.add('component');
        // reference
        editor.call('attributes:reference:asset:shader:asset:attach', panelRaw, panelRaw.headerElement);

        // loading
        var loading = editor.call('attributes:addField', {
            type: 'progress'
        });
        loading.progress = 1;

        // code
        var fieldCode = editor.call('attributes:addField', {
            parent: panelRaw,
            type: 'code'
        });
        fieldCode.style.margin = '-8px -6px';

        var fieldError = new ui.Label({
            text: 'failed loading data'
        });
        fieldError.class.add('asset-loading-error');
        fieldError.hidden = true;
        editor.call('attributes.rootPanel').append(fieldError);

        var loadContent = function() {
            if (asset.get('file.size') > 128 * 1024) {
                panelRaw.hidden = true;
                loading.hidden = true;
                return;
            } else {
                panelRaw.hidden = false;
                loading.hidden = false;
            }
            // load data
            new AjaxRequest({
                url: '{{url.home}}/' + asset.get('file.url') + '?t=' + asset.get('file.hash'),
                notJson: true
            })
            .on('load', function(status, data) {
                fieldCode.text = data;
                fieldCode.hidden = false;
                fieldError.hidden = true;
                loading.hidden = true;
            })
            .on('error', function() {
                loading.hidden = false;
                loading.failed = true;
                fieldCode.hidden = true;
                fieldError.hidden = false;
            });
        };
        if (asset.has('file.url'))
            loadContent();

        var evtReload = asset.on('file.hash:set', function() {
            loadContent();
        });
        panel.once('destroy', function() {
            evtReload.unbind();
            evtFileUrl.unbind();
            evtFileUrlUnset.unbind();
        });
    });
});


/* editor/attributes/assets/attributes-asset-source.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[asset]', function(assets) {
        if (assets.length !== 1 || ! assets[0].get('source'))
            return;

        var asset = assets[0];
        var events = [ ];

        if ((! config.project.privateAssets || (config.project.privateAssets && editor.call('permissions:read'))) && asset.get('type') !== 'scene' && asset.get('type') !== 'folder') {
            // panel
            var panel = editor.call('attributes:addPanel');
            panel.class.add('component');

            // download
            var btnDownload = new ui.Button();
            btnDownload.text = 'Download';
            btnDownload.class.add('download-asset');
            btnDownload.element.addEventListener('click', function(evt) {
                window.open(asset.get('file.url'));
            }, false);
            panel.append(btnDownload);
        }

        // related assets
        var panelRelated = editor.call('attributes:addPanel', {
            name: 'Related Assets'
        });
        panelRelated.class.add('component');
        // reference
        editor.call('attributes:reference:asset:source:related:attach', panelRelated, panelRelated.headerElement);

        var list = new ui.List();
        list.class.add('related-assets');
        panelRelated.append(list);

        var assetId = asset.get('id');
        var assets = editor.call('assets:find', function(asset) {
            return asset.get('source_asset_id') === assetId;
        });

        var addAsset = function(asset) {
            panelRelated.hidden = false;

            var item = new ui.ListItem({
                text: asset.get('name')
            });
            item.class.add('type-' + asset.get('type'));
            list.append(item);

            item.element.addEventListener('click', function() {
                editor.call('selector:set', 'asset', [ asset ]);
            }, false);

            var assetEvents = [ ];

            assetEvents.push(asset.on('name:set', function(name) {
                item.text = name;
            }));

            asset.once('destroy', function() {
                item.destroy();
                for(var i = 0; i < assetEvents.length; i++)
                    assetEvents[i].unbind();
            });

            events = events.concat(assetEvents);
        };

        for(var i = 0; i < assets.length; i++)
            addAsset(assets[i][1]);

        if (! assets.length)
            panelRelated.hidden = true;


        events.push(editor.on('assets:add', function(asset) {
            if (asset.get('source_asset_id') !== assetId)
                return;

            addAsset(asset);
        }));


        list.once('destroy', function() {
            for(var i = 0; i < events.length; i++)
                events[i].unbind();
        });
    });
});


/* editor/attributes/assets/attributes-asset-text.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[asset]', function(assets) {
        if (assets.length !== 1 || assets[0].get('type') !== 'text' || assets[0].get('source'))
            return;

        var asset = assets[0];

         // panel
        var panel = editor.call('attributes:addPanel');
        panel.class.add('component');

        // edit
        var btnEdit = new ui.Button();
        btnEdit.text = editor.call('permissions:write') ? 'Edit' : 'View';
        btnEdit.class.add('edit-script');
        btnEdit.hidden = ! asset.has('file.url');
        btnEdit.element.addEventListener('click', function(evt) {
            window.open('/editor/asset/' + asset.get('id'));
        }, false);
        panel.append(btnEdit);
        var evtFileUrl = asset.on('file.url:set', function() {
            btnEdit.hidden = false;
        });
        var evtFileUrlUnset = asset.on('file.url:unset', function() {
            btnEdit.hidden = true;
        });

        var panelRaw = editor.call('attributes:addPanel', {
            name: 'TEXT'
        });
        panelRaw.class.add('component');
        // reference
        editor.call('attributes:reference:asset:text:asset:attach', panelRaw, panelRaw.headerElement);

        // loading
        var loading = editor.call('attributes:addField', {
            type: 'progress',
        });
        loading.progress = 1;

        // code
        var fieldText = editor.call('attributes:addField', {
            parent: panelRaw,
            type: 'code'
        });
        fieldText.style.margin = '-8px -6px';

        var fieldError = new ui.Label({
            text: 'failed loading data'
        });
        fieldError.class.add('asset-loading-error');
        fieldError.hidden = true;
        editor.call('attributes.rootPanel').append(fieldError);

        var loadContent = function() {
            if (asset.get('file.size') > 128 * 1024) {
                panelRaw.hidden = true;
                loading.hidden = true;
                return;
            } else {
                panelRaw.hidden = false;
                loading.hidden = false;
            }
            // load data
            new AjaxRequest({
                url: '{{url.home}}/' + asset.get('file.url') + '?t=' + asset.get('file.hash'),
                notJson: true
            })
            .on('load', function(status, data) {
                fieldText.text = data;
                fieldText.hidden = false;
                fieldError.hidden = true;
                loading.hidden = true;
            })
            .on('error', function(status, err) {
                loading.hidden = false;
                loading.failed = true;
                fieldText.hidden = true;
                fieldError.hidden = false;
            });
        };
        if (asset.has('file.url'))
            loadContent();

        var evtReload = asset.on('file.hash:set', function() {
            loadContent();
        });
        panel.once('destroy', function() {
            evtReload.unbind();
            evtFileUrl.unbind();
            evtFileUrlUnset.unbind();
        });
    });
});


/* editor/attributes/assets/attributes-asset-texture.js */
editor.once('load', function() {
    'use strict';

    editor.on('attributes:inspect[asset]', function(assets) {
        for(var i = 0; i < assets.length; i++) {
            if (assets[i].get('type') !== 'texture' || assets[i].get('source'))
                return;
        }

        var events = [ ];

        if (assets.length > 1)
            editor.call('attributes:header', assets.length + ' Textures');

        // properties panel
        var paramsPanel = editor.call('attributes:addPanel', {
            name: 'Texture'
        });
        paramsPanel.class.add('component');
        // reference
        editor.call('attributes:reference:asset:texture:asset:attach', paramsPanel, paramsPanel.headerElement);

        // width
        var fieldWidth = editor.call('attributes:addField', {
            parent: paramsPanel,
            name: 'Width',
            link: assets,
            path: 'meta.width',
            placeholder: 'pixels'
        });
        // reference
        editor.call('attributes:reference:asset:texture:width:attach', fieldWidth.parent.innerElement.firstChild.ui);

        // height
        var fieldHeight = editor.call('attributes:addField', {
            parent: paramsPanel,
            name: 'Height',
            link: assets,
            path: 'meta.height',
            placeholder: 'pixels'
        });
        // reference
        editor.call('attributes:reference:asset:texture:height:attach', fieldHeight.parent.innerElement.firstChild.ui);

        // depth
        var fieldDepth = editor.call('attributes:addField', {
            parent: paramsPanel,
            name: 'Depth',
            link: assets,
            path: 'meta.depth',
            placeholder: 'bit'
        });
        var checkDepthField = function() {
            if (! fieldDepth.value)
                fieldDepth.element.innerHTML = 'unknown';
        };
        checkDepthField();
        fieldDepth.on('change', checkDepthField);
        // reference
        editor.call('attributes:reference:asset:texture:depth:attach', fieldDepth.parent.innerElement.firstChild.ui);

        // rgbm
        var fieldRgbm = editor.call('attributes:addField', {
            parent: paramsPanel,
            name: 'Rgbm',
            link: assets,
            path: 'data.rgbm'
        });
        var checkRgbmField = function() {
            if (! fieldRgbm.value)
                fieldRgbm.element.innerHTML = 'false';
        };
        checkRgbmField();
        fieldRgbm.on('change', checkRgbmField);
        // reference
        editor.call('attributes:reference:asset:texture:rgbm:attach', fieldRgbm.parent.innerElement.firstChild.ui);

        // alpha
        var fieldAlpha = editor.call('attributes:addField', {
            parent: paramsPanel,
            name: 'Alpha',
            link: assets,
            path: 'meta.alpha'
        });
        var checkAlphaField = function() {
            if (! fieldAlpha.value)
                fieldAlpha.element.innerHTML = 'false';
        };
        checkAlphaField();
        fieldAlpha.on('change', checkAlphaField);
        // reference
        editor.call('attributes:reference:asset:texture:alpha:attach', fieldAlpha.parent.innerElement.firstChild.ui);


        // filtering
        var fieldFiltering = editor.call('attributes:addField', {
            parent: paramsPanel,
            name: 'Filtering',
            type: 'string',
            enum: {
                '': '...',
                'nearest': 'Point',
                'linear': 'Linear'
            }
        });
        // reference
        editor.call('attributes:reference:asset:texture:filtering:attach', fieldFiltering.parent.innerElement.firstChild.ui);

        var changingFiltering = false;

        var updateFiltering = function() {
            var value = '';
            var valueDifferent = false;
            var filter = assets[0].get('data.minfilter') + assets[0].get('data.magfilter');

            for(var i = 1; i < assets.length; i++) {
                if (filter !== (assets[i].get('data.minfilter') + assets[i].get('data.magfilter'))) {
                    valueDifferent = true;
                    break;
                }
            }

            if (! valueDifferent) {
                if (assets[0].get('data.minfilter') === 'linear_mip_linear' && assets[0].get('data.magfilter') === 'linear') {
                    value = 'linear';
                } else if (assets[0].get('data.minfilter') === 'nearest_mip_nearest' && assets[0].get('data.magfilter') === 'nearest') {
                    value = 'nearest';
                }
            }

            if (! valueDifferent && value) {
                fieldFiltering.optionElements[''].style.display = 'none';
            } else {
                fieldFiltering.optionElements[''].style.display = '';
            }

            changingFiltering = true;
            fieldFiltering.value = value;
            changingFiltering = false;
        };
        updateFiltering();

        fieldFiltering.on('change', function(value) {
            if (changingFiltering)
                return;

            var values = [ ];
            var valueMin = value + '_mip_' + value;
            var valueMag = value;

            changingFiltering = true;
            for(var i = 0; i < assets.length; i++) {
                values.push({
                    id: assets[i].get('id'),
                    valueMin: assets[i].get('data.minfilter'),
                    valueMag: assets[i].get('data.magfilter')
                });
                assets[i].history.enabled = false;
                assets[i].set('data.minfilter', valueMin);
                assets[i].set('data.magfilter', valueMag);
                assets[i].history.enabled = true;
            }
            changingFiltering = false;

            fieldFiltering.optionElements[''].style.display = 'none';

            // history
            editor.call('history:add', {
                name: 'assets.filtering',
                undo: function() {
                    for(var i = 0; i < values.length; i++) {
                        var asset = editor.call('assets:get', values[i].id);
                        if (! asset)
                            continue;

                        asset.history.enabled = false;
                        asset.set('data.minfilter', values[i].valueMin);
                        asset.set('data.magfilter', values[i].valueMag);
                        asset.history.enabled = true;
                    }
                },
                redo: function() {
                    for(var i = 0; i < values.length; i++) {
                        var asset = editor.call('assets:get', values[i].id);
                        if (! asset)
                            continue;

                        asset.history.enabled = false;
                        asset.set('data.minfilter', valueMin);
                        asset.set('data.magfilter', valueMag);
                        asset.history.enabled = true;
                    }
                }
            });
        });

        var eventsFiltering = [ ];
        var changingQueued = false;
        var changedFiltering = function() {
            if (changingQueued || changingFiltering)
                return;

            changingQueued = true;
            setTimeout(function() {
                changingQueued = false;
                updateFiltering();
            }, 0);
        };
        for(var i = 0; i < assets.length; i++) {
            eventsFiltering.push(assets[i].on('data.minfilter:set', changedFiltering));
            eventsFiltering.push(assets[i].on('data.magfilter:set', changedFiltering));
        }
        fieldFiltering.once('destroy', function() {
            for(var i = 0; i < eventsFiltering.length; i++) {
                eventsFiltering[i].unbind();
            }
        });



        // anisotropy
        var fieldAnisotropy = editor.call('attributes:addField', {
            parent: paramsPanel,
            name: 'Anisotropy',
            type: 'number',
            link: assets,
            path: 'data.anisotropy'
        });
        // reference
        editor.call('attributes:reference:asset:texture:anisotropy:attach', fieldAnisotropy.parent.innerElement.firstChild.ui);



        // addressu
        var fieldAddressU = editor.call('attributes:addField', {
            parent: paramsPanel,
            name: 'Address U',
            type: 'string',
            enum: {
                '': '...',
                'repeat': 'Repeat',
                'clamp': 'Clamp',
                'mirror': 'Mirror Repeat'
            },
            link: assets,
            path: 'data.addressu'
        });
        // reference
        editor.call('attributes:reference:asset:texture:addressU:attach', fieldAddressU.parent.innerElement.firstChild.ui);


        // addressv
        var fieldAddressV = editor.call('attributes:addField', {
            parent: paramsPanel,
            name: 'Address V',
            type: 'string',
            enum: {
                '': '...',
                'repeat': 'Repeat',
                'clamp': 'Clamp',
                'mirror': 'Mirror Repeat'
            },
            link: assets,
            path: 'data.addressv'
        });
        // reference
        editor.call('attributes:reference:asset:texture:addressV:attach', fieldAddressV.parent.innerElement.firstChild.ui);



        // preview
        if (assets.length === 1) {
            var root = editor.call('attributes.rootPanel');

            var reloadImage = function() {
                if (assets[0].get('has_thumbnail') && assets[0].get('thumbnails.xl') && assets[0].get('file.hash')) {
                    image.src = config.url.home + assets[0].get('file.url') + '?t=' + assets[0].get('file.hash');
                    image.style.display = '';
                } else {
                    image.style.display = 'none';
                }
            };

            var image = new Image();
            image.onload = function() {
                root.class.add('animate');
            };
            reloadImage();

            image.addEventListener('click', function() {
                if (root.element.classList.contains('large')) {
                    root.element.classList.remove('large');
                } else {
                    root.element.classList.add('large');
                }
            }, false);

            image.classList.add('asset-preview');
            root.class.add('asset-preview');
            root.element.insertBefore(image, root.innerElement);

            var events = [ ];
            events.push(assets[0].on('file.hash:set', reloadImage));
            events.push(assets[0].on('has_thumbnail:set', reloadImage));
            events.push(assets[0].on('thumbnails.xl:set', reloadImage));

            paramsPanel.on('destroy', function() {
                for(var i = 0; i < events.length; i++)
                    events[i].unbind();
                image.parentNode.removeChild(image);
                root.class.remove('asset-preview', 'animate');
            });
        }

        paramsPanel.once('destroy', function() {
            for(var i = 0; i < events.length; i++)
                events[i].unbind();
        });
    });
});


/* editor/toolbar/toolbar.js */
editor.once('load', function() {
    'use strict';

    var toolbar = editor.call('layout.toolbar');
});


/* editor/toolbar/toolbar-logo.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');
    var toolbar = editor.call('layout.toolbar');


    var logo = new ui.Button();
    logo.class.add('logo');
    logo.on('click', function() {
        menu.open = true;
    });
    toolbar.append(logo);

    var componentsLogos = {
        'animation': '&#57875;',
        'audiolistener': '&#57750;',
        'audiosource': '&#57751;',
        'camera': '&#57874;',
        'collision': '&#57735;',
        'light': '&#57748;',
        'model': '&#57736;',
        'particlesystem': '&#57753;',
        'rigidbody': '&#57737;',
        'script': '&#57910;'
    };

    var addComponent = function (entity, component) {
        var componentData = editor.call('components:getDefault', component);
        entity.set('components.' + component, componentData);

        // if it's a collision or rigidbody component then enable physics
        if (component === 'collision' || component === 'rigidbody')
            editor.call('project:enablePhysics');
    };

    var hasScript = function (entity, url) {
        var scriptComponent = entity.get('components.script');
        if (scriptComponent) {
            for (var i = 0; i < scriptComponent.scripts.length; i++) {
                if (scriptComponent.scripts[i].url === url) {
                    return true;
                }
            }
        }

        return false;
    };

    var setField = function(items, field, value) {
        var records = [ ];

        for(var i = 0; i < items.length; i++) {
            records.push({
                get: items[i].history._getItemFn,
                value: value,
                valueOld: items[i].get(field)
            });

            items[i].history.enabled = false;
            items[i].set(field, value);
            items[i].history.enabled = true;
        }

        editor.call('history:add', {
            name: 'entities.set[' + field + ']',
            undo: function() {
                for(var i = 0; i < records.length; i++) {
                    var item = records[i].get();
                    if (! item)
                        continue;

                    item.history.enabled = false;
                    item.set(field, records[i].valueOld);
                    item.history.enabled = true;
                }
            },
            redo: function() {
                for(var i = 0; i < records.length; i++) {
                    var item = records[i].get();
                    if (! item)
                        continue;

                    item.history.enabled = false;
                    item.set(field, records[i].value);
                    item.history.enabled = true;
                }
            }
        });
    };

    var addBultinScript = function (entity, url) {
        var resourceId = entity.get('resource_id');

        var addedComponent = false;

        var action = {
            name: 'entity.' + resourceId + '.builtinscript',
            combine: false,
            undo: function () {
                var e = editor.call('entities:get', resourceId);
                if (! e) return;

                var history = e.history.enabled;
                e.history.enabled = false;

                if (addedComponent) {
                    e.unset('components.script');
                } else {
                    var scripts = e.get('components.script.scripts');
                    if (scripts) {
                        for (var i = 0; i < scripts.length; i++) {
                            if (scripts[i].url === url) {
                                e.remove('components.script.scripts', i);
                                break;
                            }
                        }
                    }
                }

                e.history.enabled = history;
            },
            redo: function () {
                var e = editor.call('entities:get', resourceId);
                if (! e) return;

                var history = e.history.enabled;
                e.history.enabled = false;

                if (!e.get('components.script')) {
                    addComponent(e, 'script');
                    addedComponent = true;
                }

                // add script
                var script = new Observer({
                    url: url
                });
                e.insert('components.script.scripts', script);

                e.history.enabled = history;

                // scan script
                editor.call('sourcefiles:scan', url, function (data) {
                    e.history.enabled = false;

                    data.url = url;
                    script.patch(data);

                    e.history.enabled = history;
                });
            }
        };

        // perform action
        action.redo();

        // raise history event
        entity.history.emit('record', 'add', action);
    };

    var menuData = {
        'entity': {
            title: 'Entity',
            filter: function() {
                if (editor.call('selector:type') === 'entity' && editor.call('selector:items').length !== 1)
                    return false;

                return editor.call('permissions:write');
            },
            items: {
                'new-entity': {
                    title: 'New Entity',
                    select: function () {
                        editor.call('entities:new', {parent: editor.call('entities:selectedFirst')});
                    },
                    items: editor.call('menu:entities:new')
                },
                'add-component': {
                    title: 'Add Component',
                    filter: function() {
                        return editor.call('selector:type') === 'entity';
                    },
                    items: { }
                },
                'add-builtin-script': {
                    title: 'Add Built-In Script',
                    filter: function () {
                        return editor.call('selector:type') === 'entity';
                    },
                    items: {
                        'post-effects': {
                            title: 'Post-Effects',
                            filter: function () {
                                return editor.call('selector:type') === 'entity';
                            },
                            items: {}
                        },
                        'camera-scripts': {
                            title: 'Camera',
                            filter: function () {
                                return editor.call('selector:type') === 'entity';
                            },
                            items: {}
                        }
                    }
                }
            }
        },
        'edit': {
            title: 'Edit',
            items: {
                'undo': {
                    title: 'Undo',
                    icon: '&#57620;',
                    filter: function() {
                        return editor.call('history:canUndo');
                    },
                    select: function() {
                        editor.call('history:undo');
                    }
                },
                'redo': {
                    title: 'Redo',
                    icon: '&#57621;',
                    filter: function() {
                        return editor.call('history:canRedo');
                    },
                    select: function() {
                        editor.call('history:redo');
                    }
                },
                'enable': {
                    title: 'Enable',
                    icon: '&#57651;',
                    filter: function() {
                        if (! editor.call('permissions:write'))
                            return false;

                        return editor.call('selector:type') === 'entity';
                    },
                    hide: function () {
                        var type = editor.call('selector:type');
                        if (type !== 'entity')
                            return true;

                        var items = editor.call('selector:items');

                        if (items.length === 1) {
                            return items[0].get('enabled');
                        } else {
                            var enabled = items[0].get('enabled');
                            for(var i = 1; i < items.length; i++) {
                                if (enabled !== items[i].get('enabled'))
                                    return false;
                            }
                            return enabled;
                        }
                    },
                    select: function() {
                        setField(editor.call('selector:items'), 'enabled', true);
                    }
                },
                'disable': {
                    title: 'Disable',
                    icon: '&#57650;',
                    filter: function() {
                        if (! editor.call('permissions:write'))
                            return false;

                        return editor.call('selector:type') === 'entity';
                    },
                    hide: function () {
                        var type = editor.call('selector:type');
                        if (type !== 'entity')
                            return true;

                        var items = editor.call('selector:items');

                        if (items.length === 1) {
                            return ! items[0].get('enabled');
                        } else {
                            var disabled = items[0].get('enabled');
                            for(var i = 1; i < items.length; i++) {
                                if (disabled !== items[i].get('enabled'))
                                    return false;
                            }
                            return ! disabled;
                        }
                    },
                    select: function() {
                        setField(editor.call('selector:items'), 'enabled', false);
                    }
                },
                'copy': {
                    title: 'Copy',
                    icon: '&#58193;',
                    filter: function () {
                        if (! editor.call('permissions:write'))
                            return false;

                        return editor.call('selector:type') === 'entity' && editor.call('selector:items').length === 1;
                    },
                    select: function () {
                        var items = editor.call('selector:items');
                        editor.call('entities:copy', items[0]);
                    }
                },
                'paste': {
                    title: 'Paste',
                    icon: '&#58184;',
                    filter: function () {
                        if (! editor.call('permissions:write'))
                            return false;

                        return editor.call('selector:type') === 'entity' &&
                               editor.call('selector:items').length === 1 &&
                             ! editor.call('entities:clipboard:empty') &&
                               editor.call('entities:clipboard:get').project === config.project.id;
                    },
                    select: function () {
                        var items = editor.call('selector:items');
                        editor.call('entities:paste', items[0]);
                    }
                },
                'edit': {
                    title: 'Edit',
                    icon: '&#57648;',
                    filter: function() {
                        var type = editor.call('selector:type');
                        if (! type || type !== 'asset')
                            return false;

                        var items = editor.call('selector:items');
                        return items.length === 1 &&
                               ['html', 'css', 'json', 'text', 'script', 'shader'].indexOf(items[0].get('type')) !== -1;
                    },
                    select: function() {
                        var type = editor.call('selector:type');
                        if (! type || type !== 'asset') return;
                        var items = editor.call('selector:items');

                        editor.call('assets:edit', items[0]);
                    }
                },
                'duplicate': {
                    title: 'Duplicate',
                    icon: '&#57638;',
                    filter: function() {
                        if (! editor.call('permissions:write'))
                            return false;

                        var type = editor.call('selector:type');
                        if (! type)
                            return false;

                        var items = editor.call('selector:items');

                        if (type === 'entity') {
                            return items.length === 1;
                        } else if (type === 'asset') {
                            return items.length === 1 && items[0].get('type') === 'material';
                        } else {
                            return false;
                        }
                    },
                    select: function() {
                        var type = editor.call('selector:type');
                        if (! type) return;
                        var items = editor.call('selector:items');

                        if (type === 'entity') {
                            editor.call('entities:duplicate', items[0]);
                        } else if (type === 'asset') {
                            editor.call('assets:duplicate', items[0]);
                        }
                    }
                },
                'delete': {
                    title: 'Delete',
                    icon: '&#57636;',
                    filter: function() {
                        if (! editor.call('permissions:write'))
                            return false;

                        var type = editor.call('selector:type');
                        if (!type) return false;

                        if (type === 'entity') {
                            var root = editor.call('entities:root');
                            var items = editor.call('selector:items');
                            for (var i = 0; i < items.length; i++) {
                                if (items[i] === root) {
                                    return false;
                                }
                            }
                        }

                        return true;
                    },
                    select: function() {
                        var type = editor.call('selector:type');
                        if (! type) return;
                        var items = editor.call('selector:items');

                        if (type === 'entity') {
                            var root = editor.call('entities:root');
                            if (items.indexOf(root) !== -1)
                                return;
                            editor.call('entities:delete', items);
                        } else if (type === 'asset') {
                            editor.call('assets:delete:picker', items);
                        }
                    }
                }
            }
        },
        'launch': {
            title: 'Launch',
            select: function() {
                var url = window.location.href.replace(/^https/, 'http') + '/launch';
                window.open(url, 'pc.launch.' + config.scene.id);
            },
            items: {
                'launch-remote': {
                    title: 'Launch',
                    icon: '&#57649;',
                    select: function() {
                        var url = window.location.href.replace(/^https/, 'http') + '/launch';
                        window.open(url, 'pc.launch.' + config.scene.id);
                    }
                },
                'launch-local': {
                    title: 'Launch (Local)',
                    icon: '&#57649;',
                    filter: function() {
                        return editor.call('permissions:write');
                    },
                    select: function() {
                        var settings = editor.call('designerSettings');
                        var url = window.location.href.replace(/^https/, 'http') + '/launch?local=' + settings.get('local_server');
                        window.open(url, 'pc.launch.' + config.scene.id);
                    }
                }
            }
        },
        'help': {
            title: 'Help',
            items: {
                'controls': {
                    title: 'Controls',
                    icon: '&#57654;',
                    select: function() {
                        editor.call('help:controls');
                    }
                },
                'reference': {
                    title: 'Reference',
                    icon: '&#57906;',
                    select: function() {
                        window.open('http://developer.playcanvas.com/en/engine/api/stable/');
                    }
                },
                'learn': {
                    title: 'Learn',
                    icon: '&#57906;',
                    select: function() {
                        window.open('http://developer.playcanvas.com/en/');
                    }
                },
                'forum': {
                    title: 'Forum',
                    icon: '&#57907;',
                    select: function() {
                        window.open('http://forum.playcanvas.com/');
                    }
                },
                'answers': {
                    title: 'Answers',
                    icon: '&#57656;',
                    select: function() {
                        window.open('http://answers.playcanvas.com/');
                    }
                },
                'howdoi': {
                    title: 'How do I...',
                    icon: '&#57656;',
                    select: function () {
                        editor.call('help:howdoi');
                    }
                },
                'resetTips': {
                    title: 'Reset Tips',
                    icon: '&#57656;',
                    select: function () {
                        editor.call('editor:tips:reset');
                    }
                }
            }
        },
        'scenes': {
            title: 'Scenes',
            icon: '&#57671;',
            select: function() {
                editor.call('picker:scene');
            }
        },
        'settings': {
            title: 'Settings',
            icon: '&#57652;',
            filter: function() {
                return editor.call('permissions:write') && editor.call('selector:type') !== 'designerSettings' && ! editor.call('viewport:expand:state');
            },
            select: function() {
                editor.call('selector:set', 'designerSettings', [ editor.call('designerSettings') ]);
            }
        },
        'priorityScripts': {
            title: 'Script Priority',
            icon: '&#57652;',
            filter: function() {
                return editor.call('permissions:write');
            },
            select: function() {
                editor.call('sceneSettings:priorityScripts');
            }
        },
        'feedback': {
            title: 'Feedback',
            icon: '&#57625;',
            select: function() {
                window.open('http://forum.playcanvas.com/t/playcanvas-editor-feedback/616');
            }
        }
    };

    var makeMenuComponentItem = function(key) {
        return {
            title: components[key].title,
            icon: componentsLogos[key],
            filter: function() {
                if (editor.call('selector:type') !== 'entity')
                    return false;

                var entity = editor.call('selector:items')[0];
                return ! entity.has('components.' + key);
            },
            select: function() {
                if (editor.call('selector:type') !== 'entity')
                    return;

                var entity = editor.call('selector:items')[0];
                var component = this._value;

                addComponent(entity, component);
            }
        }
    };

    var components = editor.call('components:schema');
    var list = editor.call('components:list');
    for(var i = 0; i < list.length; i++) {
        var key = list[i];
        menuData['entity'].items['add-component'].items[key] = makeMenuComponentItem(key);
    }

    var builtInScripts = [{
        group: 'post-effects',
        title: 'Bloom',
        name: 'posteffect-bloom',
        url: 'https://code.playcanvas.com/posteffects/posteffect_bloom.js',
        requires: 'camera'
    }, {
        group: 'post-effects',
        title: 'Bloom',
        name: 'posteffect-bloom',
        url: 'https://code.playcanvas.com/posteffects/posteffect_bloom.js',
        requires: 'camera'
    }, {
        group: 'post-effects',
        title: 'Bloom',
        name: 'posteffect-bloom',
        url: 'https://code.playcanvas.com/posteffects/posteffect_bloom.js',
        requires: 'camera'
    }, {
        group: 'post-effects',
        title: 'Brightness-Contrast',
        name: 'posteffect-brightnesscontrast',
        url: 'https://code.playcanvas.com/posteffects/posteffect_brightnesscontrast.js',
        requires: 'camera'
    }, {
        group: 'post-effects',
        title: 'Hue-Saturation',
        name: 'posteffect-huesaturation',
        url: 'https://code.playcanvas.com/posteffects/posteffect_huesaturation.js',
        requires: 'camera'
    }, {
        group: 'post-effects',
        title: 'FXAA',
        name: 'posteffect-fxaa',
        url: 'https://code.playcanvas.com/posteffects/posteffect_fxaa.js',
        requires: 'camera'
    }, {
        group: 'post-effects',
        title: 'Sepia',
        name: 'posteffect-sepia',
        url: 'https://code.playcanvas.com/posteffects/posteffect_sepia.js',
        requires: 'camera'
    }, {
        group: 'post-effects',
        title: 'Vignette',
        name: 'posteffect-vignette',
        url: 'https://code.playcanvas.com/posteffects/posteffect_vignette.js',
        requires: 'camera'
    }, {
        group: 'camera-scripts',
        title: 'Fly Camera',
        name: 'camera-fly',
        url: 'https://code.playcanvas.com/camera/camera_fly.js',
        requires: 'camera'
    }];

    builtInScripts.forEach(function (data) {
        menuData['entity'].items['add-builtin-script'].items[data.group].items[data.name] = {
            title: data.title,
            filter: function () {
                var entity = editor.call('selector:items')[0];

                return editor.call('selector:type') === 'entity' &&
                       editor.call('permissions:write') &&
                       !hasScript(entity, data.url) &&
                       (!data.requires || entity.get('components.' + data.requires));
            },
            select: function () {
                var entity = editor.call('selector:items')[0];
                addBultinScript(entity, data.url);
            }
        };
    });

    var root = editor.call('layout.root');

    var menu = ui.Menu.fromData(menuData);
    menu.position(45, 0);
    root.append(menu);

    var tooltip = Tooltip.attach({
        target: logo.element,
        text: 'Menu',
        align: 'left',
        root: root
    });
    menu.on('open', function(state) {
        tooltip.disabled = state;
    });

    // get part of menu data
    editor.method('menu:get', function (name) {
        return menuData[name];
    });
});


/* editor/toolbar/toolbar-designer-settings.js */
editor.once('load', function() {
    'use strict';

    var toolbar = editor.call('layout.toolbar');

    // settings button
    var button = new ui.Button({
        text: '&#57652;'
    });
    button.class.add('pc-icon', 'designer-settings');
    toolbar.append(button);

    button.on('click', function() {
        editor.call('selector:set', 'designerSettings', [ editor.call('designerSettings') ]);
    });

    editor.on('attributes:clear', function() {
        button.class.remove('active');
    });

    editor.on('attributes:inspect[designerSettings]', function() {
        editor.call('attributes.rootPanel').folded = false;

        button.class.add('active');
    });

    editor.on('viewport:expand', function(state) {
        button.disabled = state;
    });

    Tooltip.attach({
        target: button.element,
        text: 'Settings',
        align: 'left',
        root: editor.call('layout.root')
    });
});


/* editor/toolbar/toolbar-controls.js */
editor.once('load', function() {
    'use strict';

    var toolbar = editor.call('layout.toolbar');

    var button = new ui.Button({
        text: '&#57654;'
    });
    button.class.add('pc-icon', 'help-controls');
    toolbar.append(button);

    button.on('click', function() {
        editor.call('help:controls');
    });

    editor.on('help:controls:open', function () {
        button.class.add('active');
    });

    editor.on('help:controls:close', function () {
        button.class.remove('active');
    });

    Tooltip.attach({
        target: button.element,
        text: 'Controls',
        align: 'left',
        root: editor.call('layout.root')
    });
});


/* editor/toolbar/toolbar-help.js */
editor.once('load', function() {
    'use strict';

    var toolbar = editor.call('layout.toolbar');

    var button = new ui.Button({
        text: '&#57656;'
    });
    button.class.add('pc-icon', 'help-howdoi');
    toolbar.append(button);

    button.on('click', function() {
        editor.call('help:howdoi:toggle');
    });

    editor.on('help:howdoi:open', function () {
        button.class.add('active');
    });

    editor.on('help:howdoi:close', function () {
        button.class.remove('active');
    });

    Tooltip.attach({
        target: button.element,
        text: 'How do I...?',
        align: 'left',
        root: editor.call('layout.root')
    });
});


/* editor/toolbar/toolbar-gizmos.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');
    var toolbar = editor.call('layout.toolbar');

    var activeGizmo = null;
    var gizmoButtons = { };

    // create gizmo type buttons
    [{
        icon: '&#57617;',
        tooltip: 'Translate',
        op: 'translate'
    }, {
        icon: '&#57619;',
        tooltip: 'Rotate',
        op: 'rotate'
    }, {
        icon: '&#57618;',
        tooltip: 'Scale',
        op: 'scale'
    }].forEach(function (item) {
        var button = new ui.Button({
            text: item.icon
        });
        button.op = item.op;
        button.class.add('pc-icon');

        gizmoButtons[item.op] = button;

        button.on('click', function () {
            if (activeGizmo.op === this.op)
                return;

            activeGizmo.class.remove('active');
            activeGizmo.tooltip.class.add('innactive');
            activeGizmo = this;
            activeGizmo.class.add('active');
            activeGizmo.tooltip.class.remove('innactive');

            editor.call('gizmo:type', this.op);
            // var framework = editor.call('viewport:framework');
            // if (framework)
            //     framework.setActiveGizmoType(this.op);
        });

        toolbar.append(button);

        button.tooltip = Tooltip.attach({
            target: button.element,
            text: item.tooltip,
            align: 'left',
            root: root
        });

        if (item.op === 'translate') {
            activeGizmo = button;
            button.class.add('active');
        } else {
            button.tooltip.class.add('innactive');
        }
    });


    // coordinate system
    var buttonWorld = new ui.Button({
        text: '&#57624;'
    });
    buttonWorld.class.add('pc-icon', 'active');
    toolbar.append(buttonWorld);

    buttonWorld.on('click', function () {
        if (this.class.contains('active')) {
            this.class.remove('active');
            tooltipWorld.html = 'World / <span style="color:#fff">Local</span>';
        } else {
            this.class.add('active');
            tooltipWorld.html = '<span style="color:#fff">World</span> / Local';
        }
        editor.call('gizmo:coordSystem', this.class.contains('active') ? 'world' : 'local');
        // var framework = editor.call('viewport:framework');
        // if (framework)
        //     framework.setGizmoCoordinateSystem(this.class.contains('active') ? 'world' : 'local');
    });

    var tooltipWorld = Tooltip.attach({
        target: buttonWorld.element,
        align: 'left',
        root: root
    });
    tooltipWorld.html = '<span style="color:#fff">World</span> / Local';
    tooltipWorld.class.add('innactive');


    // toggle grid snap
    var buttonSnap = new ui.Button({
        text: '&#57622;'
    });
    buttonSnap.class.add('pc-icon');
    buttonSnap.on('click', function () {
        if (this.class.contains('active')) {
            this.class.remove('active');
            tooltipSnap.class.add('innactive');
        } else {
            this.class.add('active');
            tooltipSnap.class.remove('innactive');
        }
        editor.call('gizmo:snap', this.class.contains('active'));
        // var framework = editor.call('viewport:framework');
        // if (framework)
        //     framework.setSnapToClosestIncrement(this.class.contains('active'));
    });
    toolbar.append(buttonSnap);

    var tooltipSnap = Tooltip.attach({
        target: buttonSnap.element,
        text: 'Snap',
        align: 'left',
        root: root
    });
    tooltipSnap.class.add('innactive');


    // focus on entity
    var buttonFocus = new ui.Button({
        text: '&#57623;'
    });
    buttonFocus.disabled = true;
    buttonFocus.class.add('pc-icon');
    buttonFocus.on('click', function() {
        editor.call('viewport:focus');
    });
    toolbar.append(buttonFocus);

    editor.on('attributes:clear', function() {
        buttonFocus.disabled = true;
        tooltipFocus.class.add('innactive');
    });
    editor.on('attributes:inspect[*]', function(type) {
        buttonFocus.disabled = type !== 'entity';
        if (type === 'entity') {
            tooltipFocus.class.remove('innactive');
        } else {
            tooltipFocus.class.add('innactive');
        }
    });

    var tooltipFocus = Tooltip.attach({
        target: buttonFocus.element,
        text: 'Focus',
        align: 'left',
        root: root
    });
    tooltipFocus.class.add('innactive');


    // translate hotkey
    editor.call('hotkey:register', 'gizmo:translate', {
        key: '1',
        callback: function() {
            gizmoButtons['translate'].emit('click');
        }
    });

    // rotate hotkey
    editor.call('hotkey:register', 'gizmo:rotate', {
        key: '2',
        callback: function() {
            gizmoButtons['rotate'].emit('click');
        }
    });

    // scale hotkey
    editor.call('hotkey:register', 'gizmo:scale', {
        key: '3',
        callback: function() {
            gizmoButtons['scale'].emit('click');
        }
    });

    // focus
    editor.call('hotkey:register', 'viewport:focus', {
        key: 'f',
        callback: function() {
            editor.call('viewport:focus');
        }
    });
});


/* editor/toolbar/toolbar-history.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');
    var toolbar = editor.call('layout.toolbar');


    // undo
    var buttonUndo = new ui.Button({
        text: '&#57620;'
    });
    buttonUndo.class.add('pc-icon');
    buttonUndo.enabled = editor.call('history:canUndo');
    toolbar.append(buttonUndo);

    editor.on('history:canUndo', function(state) {
        buttonUndo.enabled = state;
        if (state) {
            tooltipUndo.class.remove('innactive');
        } else {
            tooltipUndo.class.add('innactive');
        }
    });
    buttonUndo.on('click', function() {
        editor.call('history:undo');
    });

    var tooltipUndo = Tooltip.attach({
        target: buttonUndo.element,
        text: 'Undo',
        align: 'left',
        root: root
    });
    if (! editor.call('history:canUndo'))
        tooltipUndo.class.add('innactive');


    // redo
    var buttonRedo = new ui.Button({
        text: '&#57621;'
    });
    buttonRedo.class.add('pc-icon');
    buttonRedo.enabled = editor.call('history:canRedo');
    toolbar.append(buttonRedo);

    editor.on('history:canRedo', function(state) {
        buttonRedo.enabled = state;
        if (state) {
            tooltipRedo.class.remove('innactive');
        } else {
            tooltipRedo.class.add('innactive');
        }
    });
    buttonRedo.on('click', function() {
        editor.call('history:redo');
    });

    var tooltipRedo = Tooltip.attach({
        target: buttonRedo.element,
        text: 'Redo',
        align: 'left',
        root: root
    });
    if (! editor.call('history:canUndo'))
        tooltipRedo.class.add('innactive');
});


/* editor/toolbar/toolbar-contact.js */
editor.once('load', function() {
    'use strict';

    var toolbar = editor.call('layout.toolbar');

    var contact = new ui.Button({
        text: '&#57625;'
    });
    contact.class.add('pc-icon');
    toolbar.append(contact);

    Tooltip.attach({
        target: contact.element,
        text: 'Feedback',
        align: 'left',
        root: editor.call('layout.root')
    });

    contact.on('click', function() {
        window.open('http://forum.playcanvas.com/t/playcanvas-editor-feedback/616');
    });
});


/* editor/toolbar/toolbar-scene.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');
    var viewport = editor.call('layout.viewport');

    var panel = new ui.Panel();
    panel.class.add('widget-title');
    viewport.append(panel);

    editor.method('layout.toolbar.scene', function () {
        return panel;
    });

    var projectName = new ui.Label();
    projectName.text = config.project.name;
    projectName.class.add('project-name');
    projectName.renderChanges = false;
    panel.append(projectName);

    projectName.on('click', function (argument) {
        window.open('/project/' + config.project.id, '_blank');
    });

    Tooltip.attach({
        target: projectName.element,
        text: 'Project',
        align: 'top',
        root: root
    });

    var sceneName = new ui.Label();
    sceneName.class.add('scene-name');
    sceneName.renderChanges = false;
    panel.append(sceneName);

    Tooltip.attach({
        target: sceneName.element,
        text: 'Scene Settings',
        align: 'top',
        root: root
    });

    editor.on('scene:name', function(name) {
        sceneName.text = name;
    });

    sceneName.on('click', function() {
        editor.call('selector:set', 'designerSettings', [ editor.call('designerSettings') ]);
    });

    editor.on('attributes:clear', function() {
        sceneName.class.remove('active');
    });

    editor.on('attributes:inspect[designerSettings]', function() {
        sceneName.class.add('active');
    });

    editor.on('scene:unload', function () {
        sceneName.text = '';
    });

    var sceneList = new ui.Label();
    sceneList.class.add('scene-list');
    panel.append(sceneList);

    Tooltip.attach({
        target: sceneList.element,
        text: 'Manage Scenes',
        align: 'top',
        root: root
    });

    sceneList.on('click', function () {
        editor.call('picker:scene');
    });

    editor.on('picker:scene:open', function () {
        sceneList.class.add('active');
    });

    editor.on('picker:scene:close', function () {
        sceneList.class.remove('active');
    });
});


/* editor/toolbar/toolbar-launch.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');
    var viewport = editor.call('layout.viewport');


    // panel
    var panel = new ui.Panel();
    panel.class.add('top-controls');
    viewport.append(panel);

    editor.method('layout.toolbar.launch', function () {
        return panel;
    });

    // launch
    var launch = new ui.Panel();
    launch.class.add('launch');
    panel.append(launch);

    var buttonLaunch = new ui.Button({
        text: '&#57649;'
    });
    buttonLaunch.class.add('icon');
    launch.append(buttonLaunch);

    var dropdownMenu = document.createElement('ul');
    dropdownMenu.classList.add('dropdown-menu')
    dropdownMenu.style.visibility = 'hidden';
    launch.append(dropdownMenu);

    var launchRemote = document.createElement('li');
    launchRemote.classList.add('ticked');
    launchRemote.innerHTML = 'Launch'
    dropdownMenu.appendChild(launchRemote);

    var launchLocal = document.createElement('li');
    launchLocal.innerHTML = 'Launch (Local)';
    dropdownMenu.appendChild(launchLocal);

    var launchLocally = false;
    var timeout;

    // show dropdown menu
    launch.element.addEventListener('mouseenter', function () {
        if (! editor.call('permissions:write'))
            return;

        dropdownMenu.style.visibility = 'visible';
        if (timeout)
            clearTimeout(timeout);
    });

    // hide dropdown menu after a delay
    launch.element.addEventListener('mouseleave', function () {
        if (! editor.call('permissions:write'))
            return;

        if (timeout) clearTimeout(timeout);
        timeout = setTimeout(function () {
            dropdownMenu.style.visibility = 'hidden';
            timeout = null;
        }, 50);
    });

    // cancel hide
    dropdownMenu.addEventListener('mouseenter', function () {
        if (dropdownMenu.style.visibility === 'visible' && timeout)
            clearTimeout(timeout);
    });

    // hide dropdown menu after a delay
    dropdownMenu.addEventListener('mouseleave', function () {
        if (timeout) clearTimeout(timeout);
        timeout = setTimeout(function () {
            dropdownMenu.style.visibility = 'hidden';
            timeout = null;
        }, 50);
    });

    // launch remote
    launchRemote.addEventListener('click', function () {
        launchLocally = false;
        launchRemote.classList.add('ticked');
        launchLocal.classList.remove('ticked');
        dropdownMenu.style.visibility = 'hidden';
        launchApp();
    });

    launchLocal.addEventListener('click', function () {
        launchLocally = true;
        launchLocal.classList.add('ticked');
        launchRemote.classList.remove('ticked');
        dropdownMenu.style.visibility = 'hidden';
        launchApp();
    });

    buttonLaunch.on('click', function () {
        launchApp();
    });

    var launchApp = function () {
        var url = window.location.href.replace(/^https/, 'http') + '/launch';
        var settings = editor.call('designerSettings');

        if (launchLocally)
            url += '?local=' + settings.get('local_server');

        window.open(url, 'pc.launch.' + config.scene.id);
    };

    editor.call('hotkey:register', 'launch', {
        key: 'enter',
        ctrl: true,
        callback: function() {
            var url = window.location.href.replace(/^https/, 'http') + '/launch';
            var settings = editor.call('designerSettings');

            if (launchLocally)
                url += '?local=' + settings.get('local_server');

            window.open(url, 'pc.launch.' + config.scene.id);
        }
    });


    // fullscreen
    var buttonExpand = new ui.Button({
        text: '&#57639;'
    });
    buttonExpand.class.add('icon', 'expand');
    panel.append(buttonExpand);

    buttonExpand.on('click', function() {
        editor.call('viewport:expand');
    });
    editor.on('viewport:expand', function(state) {
        if (state) {
            tooltipExpand.text = 'Show Panels';
            buttonExpand.class.add('active');
        } else {
            tooltipExpand.text = 'Hide Panels';
            buttonExpand.class.remove('active');
        }

        tooltipExpand.hidden = true;
    });

    var tooltipExpand = Tooltip.attach({
        target: buttonExpand.element,
        text: 'Hide Panels',
        align: 'top',
        root: root
    });
});


/* editor/toolbar/toolbar-cameras.js */
editor.once('viewport:load', function(framework) {
    'use strict';

    var viewport = editor.call('layout.viewport');

    var options = {};

    framework.cameras.forEach(function (camera) {
        options[camera.getGuid()] = camera.name;
    });

    var combo = new ui.SelectField({
        options: options
    });
    combo.enabled = false;
    combo.class.add('viewport-camera');
    combo.value = framework.cameras[0].getGuid();

    editor.on('permissions:writeState', function(state) {
        combo.enabled = state;
    });
    combo.on('open', function() {
        tooltip.disabled = true;
    });
    combo.on('close', function() {
        tooltip.disabled = false;
    });


    viewport.append(combo);

    combo.on('change', function (value) {
        var framework = editor.call('viewport:framework') ;
        if (framework) {
            framework.setActiveCamera(value);
        }
    });

    var tooltip = Tooltip.attach({
        target: combo.element,
        text: 'Camera',
        align: 'top',
        root: editor.call('layout.root')
    });

    function refreshOptions () {
        combo._updateOptions(options);
    }

    // look for entities with camera components and
    // add those to the list as well
    editor.on('entities:add', function (entity) {
        if (entity.get('components.camera')) {
            options[entity.get('resource_id')] = entity.get('name');
            refreshOptions();
        }

        entity.on('components.camera:set', function (value) {
            if (value) {
                options[entity.get('resource_id')] = entity.get('name');
                refreshOptions();
            }
        });

        entity.on('name:set', function (value) {
            var resourceId = entity.get('resource_id');
            if (options[resourceId]) {
                options[resourceId] = value;
                refreshOptions();
            }
        });

        entity.on('components.camera:unset', function () {
            // reset active camera if the current one is deleted
            if (framework.activeCamera.getGuid() === entity.get('resource_id')) {
                combo.value = framework.cameras[0].getGuid();
            }

            delete options[entity.get('resource_id')];
            refreshOptions();
        });
    });

    editor.on('entities:remove', function (entity) {
        // reset active camera if the current one is deleted
        if (framework.activeCamera.getGuid() === entity.get('resource_id')) {
            combo.value = framework.cameras[0].getGuid();
        }

        delete options[entity.get('resource_id')];
        refreshOptions();
    });
});


/* editor/toolbar/toolbar-whois.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');
    var viewport = editor.call('layout.viewport');

    var panel = new ui.Panel();
    panel.class.add('whoisonline');
    viewport.append(panel);


    editor.on('whoisonline:add', function (id) {
        for(var i = 0; i < panel.innerElement.childNodes.length; i++) {
            var child = panel.innerElement.childNodes[i];
            if (child.userId === id)
                return;
        }

        var link = document.createElement('a');
        link.userId = id;
        link.href = '/' + id;
        link.target = "_blank";
        panel.prepend(link);

        var img = document.createElement('img');
        img.src = '/api/' + id + '/thumbnail?size=32';
        link.appendChild(img);

        link.tooltip = Tooltip.attach({
            target: link,
            text: '',
            align: 'bottom',
            root: root
        });

        editor.call('users:loadOne', id, function (user) {
            link.href = '/' + user.username;
            link.tooltip.text = user.username;
        });

        reflow();
    });


    editor.on('whoisonline:remove', function (id, index) {
        for(var i = 0; i < panel.innerElement.childNodes.length; i++) {
            var child = panel.innerElement.childNodes[i];
            if (child.userId === id) {
                if (child.tooltip)
                    child.tooltip.destroy();
                panel.innerElement.removeChild(child);
                reflow()
                return;
            }
        }
    });


    editor.method('whoisonline:panel', function() {
        return panel;
    });

    // offset whoisonline if assets panel header overlaps
    var canvas = null;
    var panelAssets =  editor.call('layout.assets');

    var reflow = function() {
        if (! canvas)
            return;

        if ((8 + panelAssets.headerElement.clientWidth + panel.element.clientWidth) > canvas.width) {
            panel.class.add('offset');
        } else {
            panel.class.remove('offset');
        }
    };

    setTimeout(function() {
        canvas = editor.call('viewport:canvas');
        if (canvas)
            canvas.on('resize', reflow);
    });
});


/* editor/toolbar/toolbar-connection.js */
editor.once('load', function() {
    'use strict';

    var timeout;

    // overlay
    var overlay = new ui.Overlay();
    overlay.class.add('connection-overlay');
    overlay.center = false;
    overlay.transparent = false;
    overlay.clickable = false;
    overlay.hidden = true;

    var root = editor.call('layout.root');
    root.append(overlay);

    // icon
    var icon = document.createElement('div');
    icon.classList.add('connection-icon');
    overlay.innerElement.appendChild(icon);

    // content
    var content = document.createElement('div');
    content.classList.add('connection-content');
    overlay.innerElement.appendChild(content);

    editor.on('realtime:connected', function () {
        overlay.hidden = true;
        clearIconClass();
    });

    editor.on('realtime:disconnected', function () {
        setIconClass('error');
        content.innerHTML = 'You have been disconnected from the server.';
        overlay.hidden = false;
    });

    editor.on('realtime:nextAttempt', function (time) {

        setIconClass('error');

        function setText (remaining) {
            content.innerHTML = 'Disconnected. Reconnecting in ' + remaining + ' seconds...';
        }

        var before = new Date();

        function renderTime () {
            var now = new Date();
            var elapsed = now.getTime() - before.getTime();
            before = now;
            time -= Math.round(elapsed / 1000);
            if (time < 0) {
                time = 0;
            } else {
                timeout = setTimeout(renderTime, 1000);
            }

            setText(time);
        }

        setText(time);

        timeout = setTimeout(renderTime, 1000);
    });

    editor.on('realtime:connecting', function (attempt) {
        overlay.hidden = true;
        clearTimeout(timeout);
    });

    editor.on('realtime:cannotConnect', function () {
        overlay.hidden = false;
        clearTimeout(timeout);
        setIconClass('error');
        content.innerHTML = 'Cannot connect to the server. Please try again later.';
    });

    var onError = function (error) {
        console.log('Realtime error: ' + error);
        setIconClass('error');
        content.innerHTML = 'Error while saving changes. Please refresh the editor.';
        overlay.hidden = false;
    };


    editor.on('realtime:error', onError);
    editor.on('realtime:scene:error', onError);
    editor.on('realtime:userdata:error', onError);
    editor.on('realtime:assets:error', onError);

    editor.on('messenger:pack.delete', function (data) {
        if (config.scene.id && data.pack.id === parseInt(config.scene.id, 10)) {
            setIconClass('error');
            content.innerHTML = 'This scene has been deleted.';
            overlay.hidden = false;
        }
    });

    editor.on('scene:unload', function () {
        overlay.hidden = true;
    });

    var clearIconClass = function () {
        icon.classList.remove('error');
    };

    var setIconClass = function (cls) {
        clearIconClass();
        icon.classList.add(cls);
    };
});


/* editor/toolbar/toolbar-usage.js */
editor.once('load', function () {
    'use strict';

    if (config.owner.plan.type !== 'free')
        return;

    var root = editor.call('layout.root');
    var panel = new ui.Panel();
    panel.class.add('usage');

    var label = new ui.Label();
    panel.append(label);

    var btnClose = new ui.Button({
        text: '&#57650;'
    });
    panel.append(btnClose);
    btnClose.class.add('close');
    btnClose.on('click', function () {
        panel.hidden = true;
    });

    var refreshUsage = function () {
        var diff = config.owner.diskAllowance - config.owner.size;
        var upgrade = '<a href="/upgrade" target="_blank">UPGRADE</a> to get more disk space.';
        if (diff > 0 && diff < 30000000) {
            label.text = 'You are close to your disk allowance limit. ' + upgrade;
            panel.hidden = false;
        } else if (diff < 0) {
            label.text = 'You are over your disk allowance limit. ' + upgrade;
            panel.hidden = false;
        } else {
            panel.hidden = true;
        }
    };

    root.append(panel);

    refreshUsage();

    editor.on('user:' + config.owner.id + ':usage', refreshUsage);
});

/* editor/toolbar/toolbar-script.js */
editor.once('load', function () {
    'use script';

    var root = editor.call('layout.root');
    var overlay = new ui.Overlay();
    overlay.class.add('new-script');
    overlay.clickable = true;
    overlay.hidden = true;
    root.append(overlay);

    var panel = new ui.Panel();
    overlay.append(panel);

    var label = new ui.Label({
        text: 'Enter script name and press Enter:'
    });
    label.class.add('action');
    panel.append(label);

    var fieldName = new ui.TextField();
    fieldName.renderChanges = false;
    panel.append(fieldName);

    var fieldError = new ui.Label();
    fieldError.renderChanges = false;
    fieldError.class.add('error');
    panel.append(fieldError);
    fieldError.hidden = true;

    var newContent = '';
    var creating = false;

    // close overlay on esc
    var onKey = function (e) {
        if (e.keyCode === 27) {
            overlay.hidden = true;
        }
    };

    overlay.on('show', function () {
        editor.emit('sourcefiles:new:open');
        window.addEventListener('keydown', onKey);
        setTimeout(function () {
            fieldName.elementInput.focus();
        }, 100);
    });

    overlay.on('hide', function () {
        window.removeEventListener('keydown', onKey);
        fieldName.value = '';
        fieldError.hidden = true;
        fieldError.text = '';
        newContent = '';
        creating = false;
        editor.emit('sourcefiles:new:close');

    });

    editor.method('sourcefiles:new', function (content) {
        newContent = content;
        overlay.hidden = false;
    });

    var onError = function (error) {
        fieldError.text = error;
        fieldError.hidden = false;
    };

    var onSubmit = function () {
        if (creating)
            return;

        creating = true;

        fieldError.hidden = true;

        if (! validateFilename(fieldName.value)) {
            onError('Invalid filename');
            return;
        }

        if (!fieldName.value.toLowerCase().endsWith('.js'))
            fieldName.value = fieldName.value + '.js';

        createScript(fieldName.value, function (err, script) {
            creating = false;

            if (err) {
                onError(err);
            } else {
                // select script
                editor.call('assets:panel:currentFolder', 'scripts');
                editor.call('selector:set', 'asset', [script]);

                overlay.hidden = true;
            }
        });
    };

    // submit on enter
    fieldName.elementInput.addEventListener('keydown', function (e) {
        if (e.keyCode === 13) {
            onSubmit();
        }
    });

    // clear error on input
    fieldName.elementInput.addEventListener('input', function () {
        if (!fieldError.hidden) {
            fieldError.hidden = true;
            fieldError.text = '';
        }
    });

    var pattern = new RegExp("^(?:[\\w\\d\\.-]+\\\/)*[\\w\\d\\.-]+(?:\\.js)?$", 'i');
    var validateFilename = function (filename) {
        return pattern.test(filename);
    };

    var createScript = function (filename, callback) {
        // try to get the file first and create it only if it doesn't exist
        // TODO: don't do that when scripts are assets
        editor.call('sourcefiles:content', filename, function (err) {
            if (! err) {
                // already exists
                callback('Script with that name already exists.');
            } else {
                // create script
                var content = newContent || editor.call('sourcefiles:skeleton', filename);
                editor.call('sourcefiles:create', filename, content, function (err, sourcefile) {
                    callback(err, sourcefile);
                });
            }
        });
    };
});


/* editor/pickers/picker-confirm.js */
editor.once('load', function() {
    'use strict';

    var callback = null;
    var className = '';
    var timeoutClass = null;

    // overlay
    var overlay = new ui.Overlay();
    overlay.class.add('picker-confirm');
    overlay.hidden = true;

    // label
    var label = new ui.Label();
    label.text = 'Are you sure?';
    label.class.add('text');
    label.renderChanges = false;
    overlay.append(label);

    // yes
    var btnYes = new ui.Button();
    btnYes.text = 'Yes';
    btnYes.class.add('yes');
    btnYes.on('click', function() {
        editor.emit('picker:confirm:yes');

        if (callback)
            callback();

        overlay.hidden = true;
    });
    overlay.append(btnYes);

    // no
    var btnNo = new ui.Button();
    btnNo.text = 'No';
    btnNo.class.add('no');
    btnNo.on('click', function() {
        editor.emit('picker:confirm:no');
        overlay.hidden = true;
    });
    overlay.append(btnNo);


    var root = editor.call('layout.root');
    root.append(overlay);


    // esc > no
    editor.call('hotkey:register', 'picker:confirm:no', {
        key: 'esc',
        callback: function() {
            if (overlay.hidden)
                return;

            btnNo.emit('click');
        }
    });

    // enter > yes
    editor.call('hotkey:register', 'picker:confirm:yes', {
        key: 'enter',
        callback: function() {
            if (overlay.hidden)
                return;

            btnYes.emit('click');
        }
    });


    // on overlay hide
    overlay.on('hide', function() {
        if (className) {
            timeoutClass = setTimeout(function() {
                overlay.class.remove(className);
                className = '';
            }, 100);
        }

        editor.emit('picker:confirm:close');
    });


    editor.method('picker:confirm:class', function(name) {
        if (timeoutClass) {
            clearTimeout(timeoutClass);
            timeoutClass = null;
        }

        if (className)
            overlay.class.remove(className);

        if (name)
            overlay.class.add(name);

        className = name;
    });


    // call picker
    editor.method('picker:confirm', function(text, fn) {
        label.text = text || 'Are you sure?';
        callback = fn || null;

        // show overlay
        overlay.hidden = false;
    });

    // close picker
    editor.method('picker:confirm:close', function() {
        overlay.hidden = true;
    });
});


/* editor/pickers/picker-color.js */
editor.once('load', function() {
    'use strict';

    var size = 144;
    var directInput = true;
    var colorHSV = [ 0, 0, 0 ];
    var channels = [ ];
    var channelsNumber = 4;
    var changing = false;
    var dragging = false;


    // make hex out of channels
    var getHex = function() {
        var hex = '';
        for(var i = 0; i < channelsNumber; i++) {
            hex += ('00' + channels[i].value.toString(16)).slice(-2).toUpperCase();
        }
        return hex;
    };

    // rect drag
    var pickRectMouseMove = function(evt) {
        changing = true;
        var rect = pickRect.getBoundingClientRect();
        var x = Math.max(0, Math.min(size, Math.floor(evt.clientX - rect.left)));
        var y = Math.max(0, Math.min(size, Math.floor(evt.clientY - rect.top)));

        colorHSV[1] = x / size;
        colorHSV[2] = 1.0 - (y / size);

        directInput = false;
        var rgb = hsv2rgb([ colorHSV[0], colorHSV[1], colorHSV[2] ]);
        for(var i = 0; i < 3; i++) {
            channels[i].value = rgb[i];
        }
        fieldHex.value = getHex();
        directInput = true;

        pickRectHandle.style.left = Math.max(4, Math.min(size - 4, x)) + 'px';
        pickRectHandle.style.top = Math.max(4, Math.min(size - 4, y)) + 'px';
        changing = false;
    };

    // rect drag stop
    var pickRectMouseUp = function() {
        window.removeEventListener('mousemove', pickRectMouseMove, false);
        window.removeEventListener('mouseup', pickRectMouseUp, false);
        dragging = false;
        editor.emit('picker:color:end');
    };

    // hue drag
    var pickHueMouseMove = function(evt) {
        changing = true;
        var rect = pickHue.getBoundingClientRect();
        var y = Math.max(0, Math.min(size, Math.floor(evt.clientY - rect.top)));
        var h = y / size;

        var rgb = hsv2rgb([ h, colorHSV[1], colorHSV[2] ]);
        colorHSV[0] = h;

        directInput = false;
        for(var i = 0; i < 3; i++) {
            channels[i].value = rgb[i];
        }
        fieldHex.value = getHex();
        updateRects();
        directInput = true;
        changing = false;
    };

    // hue drag stop
    var pickHueMouseUp = function() {
        window.removeEventListener('mousemove', pickHueMouseMove, false);
        window.removeEventListener('mouseup', pickHueMouseUp, false);
        dragging = false;
        editor.emit('picker:color:end');
    };

    // opacity drag
    var pickOpacityMouseMove = function(evt) {
        changing = true;
        var rect = pickHue.getBoundingClientRect();
        var y = Math.max(0, Math.min(size, Math.floor(evt.clientY - rect.top)));
        var o = 1.0 - y / size;

        directInput = false;
        fieldA.value = Math.max(0, Math.min(255, Math.round(o * 255)));
        fieldHex.value = getHex();
        directInput = true;
        changing = false;
    };

    // opacity drag stop
    var pickOpacityMouseUp = function() {
        window.removeEventListener('mousemove', pickOpacityMouseMove, false);
        window.removeEventListener('mouseup', pickOpacityMouseUp, false);
        dragging = false;
        editor.emit('picker:color:end');
    };


    var updateHex = function() {
        if (! directInput)
            return;

        changing = true;

        var hex = fieldHex.value.trim().toLowerCase();
        if (/^([0-9a-f]{2}){3,4}$/.test(hex)) {
            for(var i = 0; i < channelsNumber; i++) {
                channels[i].value = parseInt(hex.slice(i * 2, i * 2 + 2), 16);
            }
        }

        changing = false;
    };


    // update rgb
    var updateRects = function() {
        var color = channels.map(function(channel) {
            return channel.value || 0;
        }).slice(0, channelsNumber);

        var hsv = rgb2hsv(color);
        if (directInput) {
            var sum = color[0] + color[1] + color[2];
            if (sum !== 765 && sum !== 0)
                colorHSV[0] = hsv[0];

            colorHSV[1] = hsv[1];
            colorHSV[2] = hsv[2];

            dragging = true;
            editor.emit('picker:color:start');
        }

        // hue position
        pickHueHandle.style.top = Math.floor(size * colorHSV[0]) + 'px'; // h

        // rect position
        pickRectHandle.style.left = Math.max(4, Math.min(size - 4, size * colorHSV[1])) + 'px'; // s
        pickRectHandle.style.top = Math.max(4, Math.min(size - 4, size * (1.0 - colorHSV[2]))) + 'px'; // v

        if (channelsNumber >= 3) {
            var plainColor = hsv2rgb([ colorHSV[0], 1, 1 ]).join(',');

            // rect background color
            pickRect.style.backgroundColor = 'rgb(' + plainColor + ')';

            // rect handle color
            pickRectHandle.style.backgroundColor = 'rgb(' + color.slice(0, 3).join(',') + ')';

            // hue handle color
            pickHueHandle.style.backgroundColor = 'rgb(' + plainColor + ')';
        }

        callCallback();
    };

    // update alpha handle
    var updateRectAlpha = function(value) {
        if (channelsNumber !== 4)
            return;

        // position
        pickOpacityHandle.style.top = Math.floor(size * (1.0 - (Math.max(0, Math.min(255, value)) / 255))) + 'px';

        // color
        pickOpacityHandle.style.backgroundColor = 'rgb(' + [ value, value, value ].join(',') + ')';

        callCallback();
    };


    var callingCallaback = false;
    var callbackHandle = function() {
        callingCallaback = false;

        editor.emit('picker:color', channels.map(function(channel) {
            return channel.value || 0;
        }).slice(0, channelsNumber));
    };
    var callCallback = function() {
        if (callingCallaback)
            return;

        callingCallaback = true;
        setTimeout(callbackHandle, 1000 / 60);
    };


    // overlay
    var overlay = new ui.Overlay();
    overlay.class.add('picker-color');
    overlay.center = false;
    overlay.transparent = true;
    overlay.hidden = true;


    // rectangular picker
    var pickRect = document.createElement('div');
    pickRect.classList.add('pick-rect');
    overlay.append(pickRect);

    // rect drag start
    pickRect.addEventListener('mousedown', function(evt) {
        pickRectMouseMove(evt);

        window.addEventListener('mousemove', pickRectMouseMove, false);
        window.addEventListener('mouseup', pickRectMouseUp, false);

        evt.stopPropagation();
        evt.preventDefault();
        dragging = true;
        editor.emit('picker:color:start');
    });

    // white
    var pickRectWhite = document.createElement('div');
    pickRectWhite.classList.add('white');
    pickRect.appendChild(pickRectWhite);

    // black
    var pickRectBlack = document.createElement('div');
    pickRectBlack.classList.add('black');
    pickRect.appendChild(pickRectBlack);

    // handle
    var pickRectHandle = document.createElement('div');
    pickRectHandle.classList.add('handle');
    pickRect.appendChild(pickRectHandle);


    // hue (rainbow) picker
    var pickHue = document.createElement('div');
    pickHue.classList.add('pick-hue');
    overlay.append(pickHue);

    // hue drag start
    pickHue.addEventListener('mousedown', function(evt) {
        pickHueMouseMove(evt);

        window.addEventListener('mousemove', pickHueMouseMove, false);
        window.addEventListener('mouseup', pickHueMouseUp, false);

        evt.stopPropagation();
        evt.preventDefault();
        dragging = true;
        editor.emit('picker:color:start');
    });

    // handle
    var pickHueHandle = document.createElement('div');
    pickHueHandle.classList.add('handle');
    pickHue.appendChild(pickHueHandle);


    // opacity (gradient) picker
    var pickOpacity = document.createElement('div');
    pickOpacity.classList.add('pick-opacity');
    overlay.append(pickOpacity);

    // opacoty drag start
    pickOpacity.addEventListener('mousedown', function(evt) {
        pickOpacityMouseMove(evt);

        window.addEventListener('mousemove', pickOpacityMouseMove, false);
        window.addEventListener('mouseup', pickOpacityMouseUp, false);

        evt.stopPropagation();
        evt.preventDefault();
        dragging = true;
        editor.emit('picker:color:start');
    });

    // handle
    var pickOpacityHandle = document.createElement('div');
    pickOpacityHandle.classList.add('handle');
    pickOpacity.appendChild(pickOpacityHandle);



    // fields
    var panelFields = document.createElement('div');
    panelFields.classList.add('fields');
    overlay.append(panelFields);


    // R
    var fieldR = new ui.NumberField({
        precision: 1,
        step: 1,
        min: 0,
        max: 255
    });
    channels.push(fieldR);
    fieldR.renderChanges = false;
    fieldR.placeholder = 'r';
    fieldR.flexGrow = 1;
    fieldR.class.add('field', 'field-r');
    fieldR.on('change', updateRects);
    panelFields.appendChild(fieldR.element);

    // G
    var fieldG = new ui.NumberField({
        precision: 1,
        step: 1,
        min: 0,
        max: 255
    });
    channels.push(fieldG);
    fieldG.renderChanges = false;
    fieldG.placeholder = 'g';
    fieldG.class.add('field', 'field-g');
    fieldG.on('change', updateRects);
    panelFields.appendChild(fieldG.element);

    // B
    var fieldB = new ui.NumberField({
        precision: 1,
        step: 1,
        min: 0,
        max: 255
    });
    channels.push(fieldB);
    fieldB.renderChanges = false;
    fieldB.placeholder = 'b';
    fieldB.class.add('field', 'field-b');
    fieldB.on('change', updateRects);
    panelFields.appendChild(fieldB.element);


    // A
    var fieldA = new ui.NumberField({
        precision: 1,
        step: 1,
        min: 0,
        max: 255
    });
    channels.push(fieldA);
    fieldA.renderChanges = false;
    fieldA.placeholder = 'a';
    fieldA.class.add('field', 'field-a');
    fieldA.on('change', updateRectAlpha);
    panelFields.appendChild(fieldA.element);


    // HEX
    var fieldHex = new ui.TextField();
    fieldHex.renderChanges = false;
    fieldHex.placeholder = '#';
    fieldHex.class.add('field', 'field-hex');
    fieldHex.on('change', function() {
        updateHex();
    });
    panelFields.appendChild(fieldHex.element);


    var root = editor.call('layout.root');
    root.append(overlay);


    // esc to close
    editor.call('hotkey:register', 'picker:color:close', {
        key: 'esc',
        callback: function() {
            if (overlay.hidden)
                return;

            overlay.hidden = true;
        }
    });


    overlay.on('hide', function() {
        editor.emit('picker:color:close');
    });


    // call picker
    editor.method('picker:color', function(color) {
        // class for channels
        for(var i = 0; i < 4; i++) {
            if (color.length - 1 < i) {
                overlay.class.remove('c-' + (i + 1));
            } else {
                overlay.class.add('c-' + (i + 1));
            }
        }

        // number of channels
        channelsNumber = color.length;

        if (channelsNumber >= 3) {
            var hsv = rgb2hsv(color);
            colorHSV[0] = hsv[0];
            colorHSV[1] = hsv[1];
            colorHSV[2] = hsv[2];
        }

        // set fields
        directInput = false;
        for(var i = 0; i < color.length; i++) {
            channels[i].value = color[i];
        }
        fieldHex.value = getHex();
        directInput = true;

        // show overlay
        overlay.hidden = false;

        // focus on hex field
        fieldHex.elementInput.focus();

        setTimeout(function() {
            fieldHex.elementInput.focus();
            fieldHex.elementInput.select();
        }, 100);
    });

    editor.method('picker:color:close', function() {
        overlay.hidden = true;
    });

    editor.method('picker:color:rect', function() {
        return overlay.rect;
    });

    // position color picker
    editor.method('picker:color:position', function(x, y) {
        overlay.position(x, y);
    });

    // position color picker
    editor.method('picker:color:set', function(color) {
        if (changing || dragging)
            return;

        if (channelsNumber >= 3) {
            var hsv = rgb2hsv(color);
            colorHSV[0] = hsv[0];
            colorHSV[1] = hsv[1];
            colorHSV[2] = hsv[2];
        }

        // set fields
        directInput = false;
        for(var i = 0; i < color.length; i++) {
            channels[i].value = color[i];
        }
        fieldHex.value = getHex();
        directInput = true;
    });
});


/* editor/pickers/picker-asset.js */
editor.once('load', function() {
    'use strict';

    var overlay = new ui.Overlay();
    overlay.class.add('picker-asset');
    overlay.center = false;
    overlay.hidden = true;

    var root = editor.call('layout.root');
    root.append(overlay);

    // initial select state
    var currentType = '';
    var currentAsset = null;
    var gridSelected = null;
    var assetsPanelFolded = false;
    var assetsPanelFilter = '';
    var assetsPanelSearch = '';
    var assetsPanelFolder = null;
    // elements
    var assetsGrid = editor.call('assets:grid');
    var assetsPanel = editor.call('layout.assets');

    // empty filter messages
    var getNoResultsMessage = function (type, filter) {
        var result;
        if (type === 'script') {
            result = 'There are no scripts. Click on the <span class="font-icon" style="font-size: 18px">&#57632;</span> button to add one';
        } else if (type === 'material' || type === 'cubemap' || type === 'text' || type === 'json' || type === 'html' || type === 'shader' || type === 'css') {
            result = 'There are no ' + type + 's in this folder. Click on the <span class="font-icon" style="font-size: 18px">&#57632;</span> button to add one';
        } else {
            result = 'There are no ' + type + 's in this folder. Add one by uploading a ' + type + ' file';
        }

        if (filter) {
            result += ' or change your search term.';
        } else {
            result += '.';
        }

        return result;
    };

    // esc to close
    editor.call('hotkey:register', 'picker:assets:close', {
        key: 'esc',
        callback: function() {
            if (overlay.hidden)
                return;

            overlay.hidden = true;
        }
    });

    assetsGrid.on('deselect', function(item) {
        if (overlay.hidden || ! item.asset || item.asset !== currentAsset)
            return;

        this.selected = [ item ];
    });

    // picked asset
    assetsGrid.on('select', function(item) {
        if (item.asset) {
            if (overlay.hidden ||
                (currentType !== '*' && item.asset.get('type') !== currentType) ||
                item.asset === currentAsset) {
                return;
            }

            // emit event
            if (item.asset)
                editor.emit('picker:asset', item.asset);
        } else if (item.script) {
            if (overlay.hidden ||
                (currentType !== '*' && currentType !== "script")) {
                return;
            }

            if (item.script)
                editor.emit('picker:asset', item.script);
        }


        // hide picker
        overlay.hidden = true;
    });


    // on close asset picker
    overlay.on('hide', function() {
        // show all assets back
        editor.call('assets:filter:type:disabled', false);
        editor.call('assets:filter:type', assetsPanelFilter);
        editor.call('assets:filter:search', assetsPanelSearch);
        editor.call('assets:panel:currentFolder', assetsPanelFolder);
        // fold back assets panel if needed
        if (assetsPanelFolded)
            assetsPanel.folded = true;
        // enable selector
        editor.call('selector:enabled', true);
        // select what was selected
        assetsGrid.selected = gridSelected;
        // emit event
        editor.emit('picker:asset:close');
        // styling
        assetsPanel.style.zIndex = '';
        assetsPanel.style.overflow = '';
    });


    // open asset picker
    editor.method('picker:asset', function(type, asset) {
        // show only asset assets
        assetsPanelFilter = editor.call('assets:filter:type');
        assetsPanelSearch = editor.call('assets:filter:search');
        assetsPanelFolder = editor.call('assets:panel:currentFolder');
        // navigate to scripts folder
        if (type === 'script')
            editor.call('assets:panel:currentFolder', 'scripts');
        // initial grid selected items
        gridSelected = assetsGrid.selected;
        // filters
        editor.call('assets:filter:type', (type === '*') ? 'all' : type);
        editor.call('assets:filter:type:disabled', (! type || type === '*') ? false : true);
        // disable selector
        editor.call('selector:enabled', false);
        // find current asset
        currentType = type;
        currentAsset = asset;
        if (currentAsset) {
            var gridItem = assetsGrid.assetsIndex[currentAsset.get('id')];
            // select in grid
            if (gridItem) {
                assetsGrid.selected = [ gridItem ];
                // navigate to folder of referenced file
                if (type === 'script') {
                    editor.call('assets:panel:currentFolder', 'scripts');
                } else {
                    var path = currentAsset.get('path');
                    if (path.length) {
                        editor.call('assets:panel:currentFolder', editor.call('assets:get', path[path.length - 1]));
                    } else {
                        editor.call('assets:panel:currentFolder', null);
                    }
                }
            }
        }
        // show asset panel in front
        assetsPanel.style.zIndex = 102;
        assetsPanel.style.overflow = 'visible';
        // if panel folded?
        assetsPanelFolded = assetsPanel.folded;
        if (assetsPanelFolded)
            assetsPanel.folded = false;
        // show overlay
        overlay.hidden = false;
        // flash assets panel
        assetsPanel.flash();
        // focus on panel
        setTimeout(function() {
            if (assetsGrid.selected && assetsGrid.selected.length) {
                assetsGrid.selected[0].element.focus();
            } else {
                assetsGrid.element.focus();
            }
        }, 100);

        // if no assets then show message
        var visible = assetsGrid.element.querySelectorAll('.ui-grid-item:not(.hidden)');
        if (visible.length === 0) {
            var msg = getNoResultsMessage(type, assetsPanelSearch);
            editor.call('assets:panel:message', msg);
        }
    });


    // close asset picker
    editor.method('picker:asset:close', function() {
        // hide overlay
        overlay.hidden = true;
    });
});


/* editor/pickers/picker-curve.js */
editor.once('load', function() {
    'use strict';

    // used to disable event handlers
    var suspendEvents = false;

    // true while changing curves
    var changing = false;

    // overlay
    var overlay = new ui.Overlay();
    overlay.class.add('picker-curve');
    overlay.center = false;
    overlay.transparent = true;
    overlay.hidden = true;

    // color variables
    var colors = {
        bg: '#293538',
        gridLines: '#20292b',
        anchors: ['rgb(255, 0, 0)', 'rgb(0, 255, 0)', 'rgb(133, 133, 252)', 'rgb(255, 255, 255)'],
        curves: ['rgb(255, 0, 0)', 'rgb(0, 255, 0)', 'rgb(133, 133, 252)', 'rgb(255, 255, 255)'],
        curveFilling: ['rgba(255, 0, 0, 0.5)', 'rgba(0, 255, 0, 0.5)', 'rgba(133, 133, 252, 0.5)', 'rgba(255, 255, 255, 0.5)'],
        text: 'white',
        highlightedLine: 'yellow'
    };

    // canvas variables
    var padding = 10;
    var axisSpacing = 20;
    var anchorRadius = 4;
    var curveHoverRadius = 8;
    var anchorHoverRadius = 8;
    var textSize = 10;

    // input related variables
    var curves = []; // holds all the curves
    var enabledCurves = []; // holds the rendered order of the curves
    var numCurves; // number of pairs of curves
    var betweenCurves = false;
    var curveType = 1;
    var curveNames = [];
    var verticalValue = 5;
    var verticalTopValue = 5;
    var verticalBottomValue = -5;
    var maxVertical = null;
    var minVertical = null;
    var hoveredAnchor = null;
    var hoveredCurve = null;
    var selectedAnchor = null;
    var selectedAnchorIndex = -1;
    var selectedCurve = null;
    var selectedCurveIndex = -1;
    var dragging = false;
    var gradient = false;

    var swizzle = [0, 1, 2, 3];

    var root = editor.call('layout.root');
    root.append(overlay);

    overlay.on('hide', function () {
        editor.emit('picker:curve:close');
        cleanup();
    });

    // rectangular picker
    var panel = document.createElement('div');
    panel.classList.add('picker-curve-panel');
    overlay.append(panel);

    // header
    var header = new ui.Panel();
    header.class.add('picker-curve-header');

    panel.appendChild(header.element);

    header.append(new ui.Label({
        text: 'Type'
    }));


    // esc to close
    editor.call('hotkey:register', 'picker:curve:close', {
        key: 'esc',
        callback: function() {
            if (overlay.hidden)
                return;

            overlay.hidden = true;
        }
    });


    // type selector
    var fieldType = new ui.SelectField({
        options: {
            0: 'Linear',
            1: 'Smooth Step',
            2: 'Spline'
        },
        number: true
    });

    fieldType.style['font-size'] = '11px';
    fieldType.value = 1;

    fieldType.on('change', function (value) {
        if (suspendEvents) return;

        changing = true;

        curveType = value;

        editor.emit('picker:curve:change:start');

        // set type for each curve
        curves.forEach(function (curve, i) {
            curve.type = value;
            var path = i.toString() + '.type';
            editor.emit('picker:curve:change', path, value);
        });

        render();

        changing = false;
    });

    header.append(fieldType);

    // randomize
    var labelRandomize = new ui.Label({
        text: 'Randomize'
    });

    labelRandomize.style['margin-left'] = '25px';
    header.append(labelRandomize);

    var fieldRandomize = new ui.Checkbox();
    fieldRandomize.on('change', function (value) {
        if (suspendEvents) return;

        var i;

        changing = true;

        betweenCurves = value;

        editor.emit('picker:curve:change:start');
        editor.emit('picker:curve:change', '0.betweenCurves', betweenCurves);

        if (!betweenCurves) {
            // disable the secondary graph
            for (i = 0; i < numCurves; i++) {
                toggleCurve(curves[i + numCurves], false);
            }
        } else {
            // enable the secondary graphs if their respective primary graphs are enabled
            for (i = 0; i < numCurves; i++) {
                // we might have a different value for the secondary graphs
                // when we re-enable betweenCurves so fire change event
                // to make sure the different values are saved
                onCurveKeysChanged(curves[i + numCurves]);

                var isEnabled = enabledCurves.indexOf(curves[i]) >= 0;
                toggleCurve(curves[i + numCurves], false);
                if (isEnabled) {
                    toggleCurve(curves[i + numCurves], true);
                }
            }
        }

        changing = false;
    });

    header.append(fieldRandomize);

    // curve toggles
    var curveToggles = [];

    var onCurveToggleClick = function () {
        var i = curveToggles.indexOf(this);
        var enabled = !this.class.contains('active');
        if (enabled) {
            this.class.add('active');
        } else {
            this.class.remove('active');
        }

        toggleCurve(curves[i], enabled);
    };

    for (var i = 0; i < colors.curves.length; i++) {
        var btn = new ui.Button();
        btn.class.add('picker-curve-toggle', 'active');
        btn.element.style.color = colors.curves[3 - i];
        curveToggles.splice(0, 0, btn);
        header.append(btn);

        btn.on('click', onCurveToggleClick.bind(btn));
    }

    // canvas
    var canvas = new ui.Canvas();
    canvas.resize(panel.clientWidth, 200);
    panel.appendChild(canvas.element);

    // canvas for checkerboard pattern
    var checkerboardCanvas = new ui.Canvas();
    checkerboardCanvas.width = 16;
    checkerboardCanvas.height = 16;
    var pctx = checkerboardCanvas.element.getContext('2d');
    pctx.fillStyle = "#949a9c";
    pctx.fillRect(0,0,8,8);
    pctx.fillRect(8,8,8,8);
    pctx.fillStyle = "#657375";
    pctx.fillRect(8,0,8,8);
    pctx.fillRect(0,8,8,8);
    var checkerboardPattern = canvas.element.getContext('2d').createPattern(checkerboardCanvas.element, 'repeat');

    // gradient canvas
    var gradientCanvas = new ui.Canvas();
    gradientCanvas.resize(panel.clientWidth, 32);
    gradientCanvas.style.display = 'block';
    panel.appendChild(gradientCanvas.element);

    // footer
    var footer = new ui.Panel();
    footer.class.add('picker-curve-footer');
    panel.appendChild(footer.element);

    // time input field
    var fieldTime = new ui.NumberField({
        min: 0,
        max: 1,
        step: 0.1
    });

    fieldTime.renderChanges = false;
    fieldTime.value = 0;
    fieldTime.on('change', onFieldChanged);
    fieldTime.flexGrow = 1;
    fieldTime.placeholder = 'Time';
    footer.append(fieldTime);

    // value input field
    var fieldValue = new ui.NumberField();
    fieldValue.renderChanges = false    ;
    fieldValue.value = 0;
    fieldValue.on('change', onFieldChanged);
    fieldValue.flexGrow = 1;
    fieldValue.placeholder = 'Value';
    footer.append(fieldValue);

    // called when time or value field change value
    function onFieldChanged () {
        if (suspendEvents || !selectedAnchor) return;

        changing = true;

        var newAnchorTime = fieldTime.value;
        var newAnchorValue = fieldValue.value;

        // start editing
        editor.emit('picker:curve:change:start');

        // set time for the selected anchor
        updateAnchor(selectedCurve, selectedAnchor, newAnchorTime, newAnchorValue);

        collapseAnchors();

        if (newAnchorValue > verticalTopValue || newAnchorValue < verticalBottomValue) {
            resetZoom();
        }

        render();

        changing = false;
    }

    // reset zoom
    var btnResetZoom = new ui.Button({
        text: 'Reset Zoom'
    });

    btnResetZoom.flexGrow = 1;

    btnResetZoom.on('click', function () {
        if (resetZoom()) {
            render();
        }
    });

    footer.append(btnResetZoom);

    // reset curve
    var btnResetCurve = new ui.Button({
        text: 'Reset Curve'
    });

    btnResetCurve.flexGrow = 1;

    btnResetCurve.on('click', function () {
        // reset keys of selected curve
        if (selectedCurve) {
            changing = true;

            // start editing
            editor.emit('picker:curve:change:start');

            resetCurve(selectedCurve);

            render();

            changing = false;
        }
    });

    footer.append(btnResetCurve);

    var context = canvas.element.getContext('2d');

    function cleanup () {
        selectedCurveIndex = -1;
        selectedAnchorIndex = -1;
        changing = false;
        dragging = false;
    }

    function resetCurve (curve) {
        curve.keys.length = 0;
        createAnchor(curve, 0, 0);
        updateFields([0, 0]);
        setSelected(curve, null);

        // reset secondary curve too
        var otherCurve = getOtherCurve(curve);
        if (otherCurve) {
            otherCurve.keys.length = 0;
            createAnchor(otherCurve, 0, 0);
        }
    }

    // Sets value for the picker and render it
    function setValue (value, args) {
        // sanity checks mostly for script 'curve' attributes
        if (!(value instanceof Array) || value.length === 0 || value[0].keys === undefined)
            return;

        suspendEvents = true;
        numCurves = value[0].keys[0].length ? value[0].keys.length : 1;

        betweenCurves = value[0].betweenCurves;
        fieldRandomize.value = betweenCurves;

        curveType = value[0].type;
        fieldType.value = curveType;

        gradient = args.gradient !== undefined ? args.gradient : false;
        gradientCanvas.style.display = gradient ? 'block' : 'none';
        fieldRandomize.hidden = gradient || args.hideRandomize;
        labelRandomize.hidden = gradient || args.hideRandomize;

        maxVertical = args.max;
        fieldValue.max = args.max;

        minVertical = args.min;
        fieldValue.min = args.min;

        verticalValue = args.verticalValue !== undefined ? args.verticalValue : 5;

        verticalTopValue = args.max !== undefined ? Math.min(verticalValue, args.max) : verticalValue;
        verticalBottomValue = args.min !== undefined ? Math.max(-verticalValue, args.min) : -verticalValue;

        curveNames = args.curves || [];
        for (var i = 0; i < colors.curves.length; i++) {
            if (i < numCurves) {
                curveToggles[i].text = curveNames[i];
                curveToggles[i].class.remove('hidden');
            } else {
                curveToggles[i].class.add('hidden');
            }
        }

        curves.length = 0;
        value.forEach(function (data) {
            if (numCurves === 1) {
                var c = new pc.Curve(data.keys);
                c.type = curveType;
                curves.push(c);
            } else {
                data.keys.forEach(function (keys) {
                    var c = new pc.Curve(keys);
                    c.type = curveType;
                    curves.push(c);
                });
            }
        });

        enabledCurves.length = 0;
        for (var i = 0; i < numCurves; i++)  {
            if (curveToggles[i].class.contains('active')) {
                enabledCurves.push(curves[i]);
                if (betweenCurves) {
                    enabledCurves.push(curves[i+numCurves]);
                }
            }
        }

        // try to select the same curve / anchor as the ones selected before setting the value
        var selCurve = selectedCurveIndex >= 0 ? curves[selectedCurveIndex] : enabledCurves[numCurves - 1];
        var selAnchor = selectedAnchorIndex >= 0 ? (selCurve ? selCurve.keys[selectedAnchorIndex] : null) : null;
        setSelected(selCurve, selAnchor);

        setHovered(null,null);

        suspendEvents = false;

        if (shouldResetZoom()) {
            resetZoom();
        }

        // refresh swizzle
        swizzle = getColorSwizzle();

        // refresh toggle colors in case we are rendering single color curves
        for (var i = 0; i < curveToggles.length; i++) {
            curveToggles[i].style.color = colors.curves[swizzle[i]];
        }

        render();
    }

    function render () {
        renderGrid();
        renderCurves();
        renderHighlightedAnchors();

        if (gradient) {
            renderColorGradient();
        }
    }

    function renderGrid() {
        var i;

        // draw background
        context.fillStyle = colors.bg;
        context.fillRect(0, 0, canvas.width, canvas.height);

        // draw grid
        for (i=0; i<5; i++) {
            var y = gridTop() + gridHeight() * i / 4;
            drawLine([gridLeft(), y], [gridRight(), y], colors.gridLines);
        }

        for (i=0; i<11; i++) {
            var x = gridLeft() + gridWidth() * i / 10;
            drawLine([x, gridTop()], [x, gridBottom()], colors.gridLines);
        }

        // draw vertical axis values
        var left = gridLeft() - textSize * 2;
        drawText(verticalTopValue, left, gridTop() + textSize * 0.5);
        drawText(+Number((verticalTopValue + verticalBottomValue) * 0.5).toFixed(1), left, gridTop() + (gridHeight() + textSize) * 0.5);
        drawText(verticalBottomValue, left, gridBottom() + textSize * 0.5);

        // draw horizontal axis values
        drawText('0.0', left + textSize * 2, gridBottom() + 2 * textSize);
        drawText('1.0', gridRight() - textSize * 2, gridBottom() + 2 * textSize);
    }

    function gridWidth () {
        return canvas.width - 2 * padding - axisSpacing;
    }

    function gridHeight () {
        return canvas.height - 2 * padding - axisSpacing;
    }

    function gridLeft () {
        return padding + axisSpacing;
    }

    function gridRight () {
        return gridLeft() + gridWidth();
    }

    function gridTop () {
        return padding;
    }

    function gridBottom () {
        return gridTop() + gridHeight();
    }

    function drawLine (start, end, color) {
        context.beginPath();
        context.moveTo(start[0], start[1]);
        context.lineTo(end[0], end[1]);
        context.strokeStyle = color;
        context.stroke();
    }

    // Draws text at the specified coordinates
    function drawText (text, x, y) {
        context.font = textSize + 'px Verdana';
        context.fillStyle = colors.text;
        context.fillText(text.toString(), x, y);
    }

    function renderCurves() {
        // holds indices of graphs that were rendered to avoid
        // rendering the same graphs twice
        var renderedCurveIndices = {};

        // // draw curves in the order in which they were enabled
        for (var i = 0; i < enabledCurves.length; i++) {
            var curve = enabledCurves[i];
            var index = curves.indexOf(curve);

            if (!renderedCurveIndices[index]) {
                renderedCurveIndices[index] = true;

                var otherCurve = getOtherCurve(curve);
                drawCurvePair(curve, otherCurve);

                drawCurveAnchors(curve);

                if (otherCurve) {
                    var otherIndex = curves.indexOf(otherCurve);
                    if (!renderedCurveIndices[otherIndex]) {
                        drawCurveAnchors(otherCurve);
                        renderedCurveIndices[otherIndex] = true;
                    }
                }
            }
        }
    }

    // If the specified curve is the primary returns the secondary
    // otherwise if the specified curve is the secondary returns the primary
    function getOtherCurve (curve) {
        if (betweenCurves) {
            var ind = curves.indexOf(curve);
            if (ind < numCurves) {
                return curves[numCurves + ind];
            } else {
                return curves[ind - numCurves];
            }
        }
    }

    // Draws a pair of curves with their in-between filling. If the second
    // curve is null then only the first curve will be rendered
    function drawCurvePair (curve1, curve2) {
        var colorIndex = swizzle[curves.indexOf(curve1) % numCurves];

        context.strokeStyle = colors.curves[colorIndex];
        context.fillStyle = colors.curveFilling[colorIndex];
        context.beginPath();

        var time = 0;
        var value = curve1.value(time);
        var x;
        var coords = calculateAnchorCoords([time, value]);
        context.moveTo(coords[0], coords[1]);

        var precision = 1;
        var width = canvas.width;

        for (x = precision; x <= Math.ceil(width / precision); x++) {
            time = x * precision / width;
            value = curve1.value(time);
            coords = calculateAnchorCoords([time, value]);
            context.lineTo(coords[0], coords[1]);
        }

        if (curve2) {
           for (x = Math.ceil(width / precision); x >= 0; x--) {
                time = x * precision / width;
                value = curve2.value(time);
                coords = calculateAnchorCoords([time, value]);
                context.lineTo(coords[0], coords[1]);
            }

            context.closePath();
            context.fill();
        }

        context.stroke();
    }

    // Returns the coordinates of the specified anchor on this grid
    function calculateAnchorCoords (anchor) {
        var time = anchor[0];
        var value = anchor[1];

        var coords = [0, 0];
        coords[0] = gridLeft() + time * gridWidth();
        coords[1] = pc.math.lerp(gridTop(), gridTop() + gridHeight(), (value - verticalTopValue) / (verticalBottomValue - verticalTopValue));

        return coords;
    }

    // Draws the anchors for the specified curve
    function drawCurveAnchors (curve) {
        var colorIndex = swizzle[curves.indexOf(curve) % numCurves];
        curve.keys.forEach(function (anchor) {
            if (anchor !== hoveredAnchor && anchor !== selectedAnchor) {
                var color = colors.anchors[colorIndex];
                var lineColor = colors.curves[colorIndex];
                drawAnchor(calculateAnchorCoords(anchor), color, lineColor);
            }
        });
    }

    // Draws an anchor point at the specified coordinates
    function drawAnchor (coords, fillColor, lineColor) {
        context.beginPath();
        context.arc(coords[0], coords[1], anchorRadius, 0, 2 * Math.PI, false);
        context.fillStyle = fillColor;
        context.fill();
        var lineWidth = context.lineWidth;
        context.lineWidth = 2;
        context.strokeStyle = lineColor;
        context.stroke();
        context.lineWidth = lineWidth;
    }

    function renderHighlightedAnchors() {
        // draw highlighted anchors on top of the others
        if (hoveredAnchor) {
            drawAnchor(
                calculateAnchorCoords(hoveredAnchor),
                colors.anchors[curves.indexOf(hoveredCurve) % numCurves],
                colors.highlightedLine
            );
        }

        if (selectedAnchor && selectedAnchor !== hoveredAnchor) {
            drawAnchor(
                calculateAnchorCoords(selectedAnchor),
                colors.anchors[curves.indexOf(selectedCurve) % numCurves],
                colors.highlightedLine
            );
        }
    }

    // if we only have one curve then
    // use 'swizzle' - an array of indexes
    // that remaps other arrays to different colors
    var getColorSwizzle = function () {
        var result = [0, 1, 2, 3];
        if (gradient && curves.length === 1) {
            if (curveNames[0] === 'g') {
                result = [1, 0, 2, 3];
            } else if (curveNames[0] === 'b') {
                result = [2, 1, 0, 3];
            } else if (curveNames[0] === 'a') {
                result = [3, 1, 2, 0];
            }
        }

        return result;
    };

    // Draws color gradient for a set of curves
    function renderColorGradient () {
        var ctx = gradientCanvas.element.getContext('2d');
        var t;
        var rgb = [];
        var precision = 2;

        var keys = [];
        for (var i = 0; i < curves.length; i++) {
            var k = curves[i].keys;
            var ka = [];
            for (var j = 0, len = k.length; j < len; j++ ) {
                ka.push(k[j][0], k[j][1]);
            }
            keys.push(ka);
        }

        var curveset = new pc.CurveSet(keys);
        curveset.type = curveType;

        ctx.fillStyle = checkerboardPattern;
        ctx.fillRect(0, 0, gradientCanvas.width, gradientCanvas.height);

        var gradient = ctx.createLinearGradient(0, 0, gradientCanvas.width, gradientCanvas.height);

        for (t = 0; t <= gradientCanvas.width; t += precision) {

            curveset.value(t / gradientCanvas.width, rgb);
            var rgba = Math.round((rgb[swizzle[0]] || 0) * 255) + ',' +
                       Math.round((rgb[swizzle[1]] || 0) * 255) + ',' +
                       Math.round((rgb[swizzle[2]] || 0) * 255) + ',' +
                       (isNaN(rgb[swizzle[3]]) ? 1 : rgb[swizzle[3]]);

            gradient.addColorStop(t / gradientCanvas.width, 'rgba(' + rgba + ')');
        }

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, gradientCanvas.width, gradientCanvas.height);
    }

    // Calculate the anchor value based on the specified coordinates
    function calculateAnchorValue (coords) {
        var top = gridTop();
        var height = gridHeight();

        return pc.math.lerp(verticalTopValue, verticalBottomValue, (coords[1] - top) / height);
    }

    // Calculate the anchor time based on the specified coordinates
    function calculateAnchorTime (coords) {
        return pc.math.clamp((coords[0] - gridLeft()) / gridWidth(), 0, 1);
    }

    function resetZoom () {
        var minMax = getCurvesMinMax(enabledCurves);

        var oldVerticalTop = verticalTopValue;
        var oldVerticalBottom = verticalBottomValue;

        var maxLimit = Math.ceil(2 * Math.max(Math.abs(minMax[0]), Math.abs(minMax[1])));
        if (maxLimit === 0) {
            maxLimit = verticalValue;
        }

        verticalTopValue = maxLimit;
        if (maxVertical != null) {
            verticalTopValue = Math.min(maxLimit, maxVertical);
        }

        verticalBottomValue = -verticalTopValue;
        if (minVertical != null) {
            verticalBottomValue = Math.max(minVertical, verticalBottomValue);
        }

        return oldVerticalTop != verticalTopValue || oldVerticalBottom != verticalBottomValue;
    }

    function getCurvesMinMax (curves) {
        var maxValue = -Infinity;
        var minValue = Infinity;

        curves.forEach(function (curve) {
            curve.keys.forEach(function (anchor) {
                var value = anchor[1];
                if (value > maxValue) {
                    maxValue = value;
                }

                if (value < minValue) {
                    minValue = value;
                }
            });
        });

        if (maxValue == -Infinity) {
            maxValue = maxVertical != null ? maxVertical : verticalValue;
        }

        if (minValue == Infinity) {
            minValue = minVertical != null ? minVertical : -verticalValue;
        }

        return [minValue, maxValue];
    }

    function updateFields (anchor) {
         suspendEvents = true;
         fieldTime.value = anchor ? anchor[0].toFixed(2) : 0;
         fieldValue.value = anchor ? anchor[1].toFixed(2) : 0;
         suspendEvents = false;
    }

    function getTargetCoords (e) {
        var rect = canvas.element.getBoundingClientRect();
        var left = Math.floor(rect.left);
        var top = Math.floor(rect.top);

        return [e.clientX - left, e.clientY - top];
    }

    // Returns true if the specidifed coordinates are within the grid bounds
    function areCoordsInGrid (coords) {
        return coords[0] >= gridLeft() &&
               coords[0] <= gridRight() &&
               coords[1] >= gridTop() &&
               coords[1] <= gridBottom();
    }

    function areCoordsClose (coords1, coords2, range) {
        return Math.abs(coords1[0] - coords2[0]) <= range &&
               Math.abs(coords1[1] - coords2[1]) <= range;
    }

    // If there are any anchors with the same time, collapses them to one
    function collapseAnchors () {
        var changedCurves = {};

        enabledCurves.forEach(function (curve) {
            for (var i = curve.keys.length - 1; i > 0; i--) {
                var key = curve.keys[i];
                var prevKey = curve.keys[i-1];
                if (key[0].toFixed(2) === prevKey[0].toFixed(2)) {
                    curve.keys.splice(i, 1);

                    changedCurves[i] = true;

                    if (selectedAnchor === key) {
                        setSelected(selectedCurve, prevKey);
                    }

                    if (hoveredAnchor === key) {
                        setHovered(hoveredCurve, prevKey);
                    }
                }
            }
        });


        for (var index in changedCurves) {
            var curve = curves[parseInt(index)];
            if (curve) {
                onCurveKeysChanged(curve);
            }
        }
    }

    // Creates and returns an anchor and fires change event
    function createAnchor (curve, time, value) {
        var anchor = curve.add(time, value);
        onCurveKeysChanged(curve);
        return anchor;
    }

    // Updates the time / value of an anchor and fires change event
    function updateAnchor (curve, anchor, time, value) {
        anchor[0] = time;
        anchor[1] = value;
        curve.sort();

        // reset selected anchor index because it
        // might have changed after sorting the curve keys
        if (selectedCurve === curve && selectedAnchor) {
            selectedAnchorIndex = curve.keys.indexOf(selectedAnchor);
        }

        onCurveKeysChanged(curve);
    }

    // Deletes an anchor from the curve and fires change event
    function deleteAnchor (curve, anchor) {
        var index = curve.keys.indexOf(anchor);
        if (index >= 0) {
            curve.keys.splice(index, 1);
        }

        // Have at least one key in the curve
        if (curve.keys.length === 0) {
            createAnchor(curve, 0, 0);
        } else {
            onCurveKeysChanged(curve);
        }
    }

    function getKeysPath (curve) {
        var curveIndex = curves.indexOf(curve);
        if (numCurves > 1) {
            return curveIndex >= numCurves ? '1.keys.' + (curveIndex - numCurves) : '0.keys.' + curveIndex;
        } else {
            return curveIndex === 0 ? '0.keys' : '1.keys';
        }
    }

    function serializeCurveKeys (curve) {
        var result = [];
        curve.keys.forEach(function (k) {
            result.push(k[0], k[1]);
        });
        return result;
    }

    function onCurveKeysChanged (curve) {
        editor.emit('picker:curve:change', getKeysPath(curve), serializeCurveKeys(curve));
    }

    // Make the specified curve appear in front of the others
    function sendCurveToFront (curve) {
        var index = enabledCurves.indexOf(curve);
        if (index >= 0) {
            enabledCurves.splice(index, 1);
        }

        enabledCurves.push(curve);
    }

    // Sets the hovered graph and anchor
    function setHovered (curve, anchor) {
        hoveredCurve = curve;
        hoveredAnchor = anchor;

        // Change the mouse cursor to a pointer
        if (curve || anchor) {
            canvas.element.style.cursor = 'pointer';
            updateFields(anchor);
        } else {
            canvas.element.style.cursor = 'default';
            updateFields(selectedAnchor);
        }
    }

    // Sets the selected anchor and curve
    function setSelected (curve, anchor) {
        selectedCurve = curve;
        selectedAnchor = anchor;

        updateFields(anchor);

        // make the selected curve appear in front of all the others
        if (curve) {
            // set selected curve index
            selectedCurveIndex = curves.indexOf(curve);

            // set selected anchor index
            selectedAnchorIndex = anchor ? curve.keys.indexOf(anchor) : -1;

            // render curve pair in front of the others
            var otherCurve = getOtherCurve(curve);
            if (otherCurve) {
                sendCurveToFront(otherCurve);
            }

            sendCurveToFront(curve);
        } else {
            selectedCurveIndex = -1;
            selectedAnchorIndex = -1;
        }
    }

    // Return the hovered anchor and graph
    function getHoveredAnchor (coords) {
        var x,y;

        var result = {
            graph: null,
            anchor: null
        };

        var hoveredTime = calculateAnchorTime(coords);

        // go through all the curves from front to back
        // and check if the mouse cursor is hovering on them
        for (var j = enabledCurves.length - 1; j >= 0; j--) {
            var curve = enabledCurves[j];

            if (!result.curve) {
                // get the value at the current hovered time
                var value = curve.value(hoveredTime);

                // convert hoveredTime, value to coords
                var curvePointCoords = calculateAnchorCoords([hoveredTime, value]);

                // check coords are close to a radius
                x = coords[0] - curvePointCoords[0];
                y = coords[1] - curvePointCoords[1];

                if (areCoordsClose(coords, curvePointCoords, curveHoverRadius)) {
                    result.curve = curve;
                }
            }

            for (var i = 0, imax = curve.keys.length; i < imax; i++) {
                var anchor = curve.keys[i];
                var anchorCoords = calculateAnchorCoords(anchor);

                if (areCoordsClose(coords, anchorCoords, anchorHoverRadius)) {
                    result.anchor = anchor;
                    result.curve = curve;
                    return result;
                }
            }
        }

        return result;
    }

    // Enables / disables a curve
    function toggleCurve (curve, toggle) {
        if (toggle) {
            // when we enable a curve make it the selected one
            setSelected(curve, null);
        } else {
            // remove the curve from the enabledCurves array
            var index = enabledCurves.indexOf(curve);
            if (index >= 0) {
                enabledCurves.splice(index, 1);
            }

            // remove it's matching curve too
            var otherCurve = getOtherCurve(curve);
            if (otherCurve) {
                index = enabledCurves.indexOf(otherCurve);
                if (index >= 0) {
                    enabledCurves.splice(index, 1);
                }
            }

            // if the selected curve was disabled select the next enabled one
            if (selectedCurve === curve || selectedCurve === otherCurve) {
                setSelected(null, null);

                if (enabledCurves.length) {
                    selectedCurve = enabledCurves[enabledCurves.length - 1];
                    selectedCurveIndex = curves.indexOf(selectedCurve);

                    // make sure we select the primary curve
                    if (betweenCurves && selectedCurveIndex >= numCurves) {
                        selectedCurveIndex -= numCurves;
                        selectedCurve = curves[selectedCurveIndex];
                    }
                }
            }

            if (hoveredCurve === curve || hoveredCurve === otherCurve) {
                hoveredCurve = null;
            }
        }

        if (shouldResetZoom()) {
            resetZoom();
        }

        render();
    }

    // Returns true if it would be a good idea to reset the zoom
    function shouldResetZoom () {
        var minMax = getCurvesMinMax(enabledCurves);

        // if min value is less than the bottom vertical value...
        if (minMax[0] < verticalBottomValue) {
            return true;
        }

        // ... or if max is bigger than the top vertical value...
        if (minMax[1] > verticalTopValue) {
            return true;
        }

        // // ... or if min and max are between the [25%, 75%] interval of the editor, return true
        // if (minMax[1] < Math.ceil(pc.math.lerp(verticalBottomValue, verticalTopValue, 0.75)) &&
        //     minMax[0] > Math.ceil(pc.math.lerp(verticalBottomValue, verticalTopValue, 0.25))) {
        //     return true;
        // }

        // don't reset zoom
        return false;
    }

    function toggleTextSelection (enable) {
        if (enable) {
            document.body.classList.remove('noSelect');
        } else {
            if (!document.body.classList.contains('noSelect')) {
                document.body.classList.add('noSelect');
            }
        }
    }

    // Handles mouse down
    canvas.element.addEventListener('mousedown', function (e) {
        if (e.target !== canvas.element) {
            return;
        }

        dragging = true;
        changing = true;

        toggleTextSelection(false);

        var point = getTargetCoords(e);
        var inGrid = areCoordsInGrid(point);

        editor.emit('picker:curve:change:start');

        // collapse anchors on mouse down because we might
        // have placed another anchor on top of another by directly
        // editing its time through the input fields
        collapseAnchors();

        // select or add anchor on left click
        if (e.button === 0) {
            // if we are clicking on an empty area
            if (!hoveredAnchor) {

                if (!inGrid) {
                    return;
                }

                var curve = hoveredCurve || selectedCurve;

                // create a new anchor
                if (curve) {

                    var time = calculateAnchorTime(point);
                    var value = calculateAnchorValue(point);
                    var anchor = createAnchor(curve, time, value);

                    // select the new anchor and make it hovered
                    setSelected(curve, anchor);
                    setHovered(curve, anchor);
                }
            } else {
                // if we are hovered over a graph or an anchor then select it
                setSelected(hoveredCurve, hoveredAnchor);
            }
        }
        else {
            // delete anchor on right click
            if (hoveredAnchor) {
                deleteAnchor(hoveredCurve, hoveredAnchor);

                // clean up selected anchor
                if (selectedAnchor == hoveredAnchor) {
                    setSelected(selectedCurve, null);
                }

                // clean up hovered anchor
                setHovered(null, null);
            }
        }

        render();
    });

    // Handles mouse move
    panel.addEventListener('mousemove', function (e) {
        if (dragging && e.target !== canvas.element) {
            e.preventDefault();
            return false;
        }

        var coords = getTargetCoords(e);

        // if we are dragging the selected anchor
        if (selectedAnchor && dragging) {
            // clamp coords to grid
            coords[0] = pc.math.clamp(coords[0], gridLeft(), gridRight());
            coords[1] = pc.math.clamp(coords[1], gridTop(), gridBottom());

            var time = calculateAnchorTime(coords);
            var value = calculateAnchorValue(coords);

            // if there is another point with the same time
            // then make the two points have the same values
            var keys = selectedCurve.keys;
            for (var i = 0, len = keys.length; i < len; i++) {
                if (keys[i] !== selectedAnchor && keys[i][0] === time) {
                    value = keys[i][1];
                }
            }

            updateAnchor(selectedCurve, selectedAnchor, time, value);
            updateFields(selectedAnchor);
            render();
        } else {
            // mouse is moving without selected anchors so just check for hovered anchors or hovered curves
            var hovered = getHoveredAnchor(coords);
            if (hovered.curve != hoveredCurve || hovered.anchor != hoveredAnchor) {
                setHovered(hovered.curve, hovered.anchor);
                render();
            }
        }
    });

    // Handles mouse up
    panel.addEventListener('mouseup', function (e) {
        toggleTextSelection(true);

        if (changing) {
            // collapse anchors on mouse up because we might have
            // placed an anchor on top of another one
            collapseAnchors();

            dragging = false;
            changing = false;
        }
    });

    // call picker
    editor.method('picker:curve', function (value, args) {
        // show overlay
        overlay.hidden = false;

        suspendEvents = true;
        curveToggles.forEach(function (toggle) {
            toggle.class.add('active');
        });
        suspendEvents = false;

        setValue(value, args || {});
    });

    editor.method('picker:curve:close', function () {
        overlay.hidden = true;
        cleanup();

        toggleTextSelection(true);
    });

    editor.method('picker:curve:rect', function () {
        return overlay.rect;
    });

    // position picker
    editor.method('picker:curve:position', function (x, y) {
        // limit to bottom of screen
        if (y + panel.clientHeight > window.innerHeight) {
            y = window.innerHeight - panel.clientHeight;
        }

        overlay.position(x, y);
    });

    // update value of picker
    editor.method('picker:curve:set', function (value, args) {
        if (!changing) {
            setValue(value, args || {});
        }
    });
});


/* editor/pickers/picker-entity.js */
editor.once('load', function() {
    'use strict';

    var overlay = new ui.Overlay();
    overlay.class.add('picker-entity');
    overlay.center = false;
    overlay.hidden = true;

    var root = editor.call('layout.root');
    root.append(overlay);

    // initial select state
    var currentEntity = null;
    var initialSelection = null;

    // elements
    var hierarchy = editor.call('entities:hierarchy');
    var hierarchyPanel = hierarchy.parent;
    var hierarchyFolded = false;

    // esc to close
    editor.call('hotkey:register', 'picker:entity:close', {
        key: 'esc',
        callback: function() {
            if (overlay.hidden)
                return;

            overlay.hidden = true;
        }
    });

    hierarchy.on('deselect', function (item) {
        if (overlay.hidden || !item.entity || item.entity !== currentEntity)
            return;
    });

    // picked entity
    hierarchy.on('select', function (item) {
        if (overlay.hidden || item.entity === currentEntity) {
            return;
        }

        // emit event
        if (item.entity) {
            editor.emit('picker:entity', item.entity);
        }

        // hide picker
        overlay.hidden = true;
    });


    // on close entity picker
    overlay.on('hide', function() {
        // fold back hierarchy panel if needed
        if (hierarchyFolded)
            hierarchyPanel.folded = true;

        // disable new selections
        for (var i = 0, len = hierarchy.selected.length; i < len; i++) {
            hierarchy.selected[i].selected = false;
        }

        // select what was selected
        hierarchy.selected = initialSelection;
        for (var i = 0, len = initialSelection.length; i < len; i++) {
            initialSelection[i].selected = true;
        }

        if (initialSelection.length)
            initialSelection[initialSelection.length - 1].elementTitle.focus();

        currentEntity = null;

        // enable selector
        editor.call('selector:enabled', true);

        // emit event
        editor.emit('picker:entity:close');
        // styling
        hierarchyPanel.style.zIndex = '';
        hierarchyPanel.style.overflow = '';
    });


    // open entity picker
    editor.method('picker:entity', function (resourceId) {
        // disable selector
        editor.call('selector:enabled', false);

        // get current hierarchy selection
        initialSelection = hierarchy.selected ? hierarchy.selected.slice(0) : [];
        if (initialSelection) {
            for (var i = 0, len = initialSelection.length; i < len; i++) {
                initialSelection[i].selected = false;
            }

        }


        // find current entity
        if (resourceId) {
            currentEntity = editor.call('entities:get', resourceId);
        }

        if (currentEntity) {
            var item = editor.call('entities:panel:get', resourceId);
            // select in hierarchy
            if (item) {
                hierarchy.selected = [ item ];
                item.selected = true;
            }
        } else {
            hierarchy.selected = [];
        }

        // show hierarchy panel in front
        hierarchyPanel.style.zIndex = 102;
        hierarchyPanel.style.overflow = 'visible';
        // if panel folded?
        hierarchyFolded = hierarchyPanel.folded;
        if (hierarchyFolded)
            hierarchyPanel.folded = false;

        // show overlay
        overlay.hidden = false;
        // flash entities panel
        hierarchyPanel.flash();
        // focus on panel
        setTimeout(function() {
            if (hierarchy.selected.length) {
                hierarchy.selected[0].elementTitle.focus();
            } else {
                hierarchy.element.focus();
            }
        }, 100);
    });


    // close entity picker
    editor.method('picker:entity:close', function() {
        // hide overlay
        overlay.hidden = true;
    });
});


/* editor/pickers/picker-scene.js */
editor.once('load', function() {
    'use strict';

    // overlay
    var overlay = new ui.Overlay();
    overlay.class.add('picker-scene');
    overlay.hidden = true;
    overlay.clickable = false;

    // picker panel
    var panel = document.createElement('div');
    panel.classList.add('picker-scene-panel');
    overlay.append(panel);

    if (!editor.call('permissions:write'))
        panel.classList.add('disabled');

    // header
    var header = document.createElement('div');
    header.classList.add('picker-scene-header');
    panel.appendChild(header);

    // icon
    var icon = document.createElement('span');
    icon.classList.add('picker-scene-icon', 'font-icon');
    header.appendChild(icon);

    // title
    var title = document.createElement('span');
    title.innerHTML = 'Scenes';
    title.classList.add('picker-scene-title');
    header.appendChild(title);

    // close button
    var close = document.createElement('span');
    close.classList.add('picker-scene-close', 'font-icon');
    close.addEventListener('click', function () {
        editor.call('picker:scene:close');
    });
    header.appendChild(close);

    var content = document.createElement('div');
    content.classList.add('picker-scene-content');
    panel.appendChild(content);

    var container = document.createElement('ul');
    content.appendChild(container);

    // progress bar
    var progressBar = new ui.Progress({progress: 1});
    content.appendChild(progressBar.element);
    progressBar.hidden = true;

    // dropdown menu for each scene
    var dropdownMenu = ui.Menu.fromData({
        'scene-duplicate': {
            title: 'Duplicate Scene',
            filter: function () {
                return editor.call('permissions:write');
            },
            select: function () {
                var name = dropdownScene.name;
                var regex = /^(.*?) ([0-9]+)$/;
                var numberPart = 2;
                var namePart = dropdownScene.name;
                var matches = dropdownScene.name.match(regex);
                if (matches && matches.length === 3) {
                    namePart = matches[1];
                    numberPart = parseInt(matches[2], 10);
                }

                // create duplicate scene name
                while (true)  {
                    name = namePart + ' ' + numberPart;
                    var found = true;
                    for (var i = 0; i < scenes.length; i++) {
                        if (scenes[i].name === name) {
                            numberPart++;
                            found = false;
                            break;
                        }
                    }

                    if (found)
                        break;
                }

                editor.call('scenes:duplicate', dropdownScene.id, name);
            }
        },
        'scene-delete': {
            title: 'Delete Scene',
            filter: function () {
                return editor.call('permissions:write');
            },
            select: function () {
                editor.call('picker:confirm', 'Are you sure you want to delete this Scene?');
                editor.once('picker:confirm:yes', function () {
                    var id = dropdownScene.id;
                    onSceneDeleted(id);
                    editor.call('scenes:delete', id);
                });
            }
        }
    });

    var dropdownScene = null;
    var dropdowns = {};
    var scenes = [];

    // when the menu closes remove the 'clicked' class from dropdowns
    dropdownMenu.on('open', function (open) {
        if (open) return;

        for (var id in dropdowns) {
            dropdowns[id].classList.remove('clicked');
        }
    });

    // footer
    var footer = document.createElement('div');
    footer.classList.add('picker-scene-footer');
    panel.appendChild(footer);

    // new scene button
    var newScene = document.createElement('div');
    newScene.classList.add('picker-scene-new');

    var newSceneLeft = document.createElement('span');
    newSceneLeft.innerHTML = 'NEW';
    newSceneLeft.classList.add('left');
    newScene.appendChild(newSceneLeft);

    var newSceneRight = document.createElement('span');
    newSceneRight.classList.add('right');
    newSceneRight.innerHTML = '&#57632;';
    newScene.appendChild(newSceneRight);

    footer.appendChild(newScene);

    newScene.addEventListener('click', function () {
        if (! editor.call('permissions:write'))
            return;

        editor.call('picker:scene:close');

        editor.call('scenes:new', function (scene) {
            editor.call('scene:load', scene.id, true);
        });
    });


    // add to root
    var root = editor.call('layout.root');
    root.append(overlay);
    root.append(dropdownMenu);

    // on overlay show
    overlay.on('show', function () {
        editor.emit('picker:scene:open');
        overlay.clickable = !!config.scene.id;
        if (config.scene.id) {
            close.classList.remove('hidden');
        } else {
            close.classList.add('hidden');
        }
    });

    // on overlay hide
    overlay.on('hide', function() {
        progressBar.hidden = true;
        container.innerHTML = '';
        dropdowns = {};
        scenes = [];
        editor.emit('picker:scene:close');
    });

    // create row for scene
    var createSceneEntry = function (scene) {
        var row = document.createElement('li');
        row.id = 'picker-scene-' + scene.id;
        if (config.scene.id && parseInt(scene.id, 10) === parseInt(config.scene.id, 10))
            row.classList.add('current');

        if (parseInt(scene.id, 10) === parseInt(config.project.primaryScene, 10))
            row.classList.add('primary');

        // primary scene icon
        var primary = document.createElement('span');
        primary.classList.add('scene-primary');
        primary.innerHTML = '&#57891;';
        row.appendChild(primary);
        primary.addEventListener('click', function () {
            if (!editor.call('permissions:write'))
                return;

            var prevPrimary = config.project.primaryScene;
            config.project.primaryScene = scene.id;
            onPrimarySceneChanged(scene.id, prevPrimary);
            editor.call('project:setPrimaryScene', scene.id);
        });

        // show tooltip for primary scene icon
        Tooltip.attach({
            target: primary,
            text: 'Set primary scene',
            align: 'right',
            root: root
        });

        // scene name
        var name = document.createElement('span');
        name.classList.add('scene-name');
        name.innerHTML = scene.name;

        row.appendChild(name);

        // scene date
        var date = document.createElement('div');
        date.classList.add('scene-date');
        date.innerHTML = editor.call('datetime:convert', scene.modified);
        row.appendChild(date);

        // dropdown
        var dropdown = document.createElement('span');
        dropdown.classList.add('scene-dropdown');
        row.appendChild(dropdown);
        dropdowns[scene.id] = dropdown;

        var dropdownIcon = document.createElement('div');
        dropdownIcon.classList.add('scene-dropdown-icon', 'font-icon');
        dropdown.appendChild(dropdownIcon);

        dropdown.addEventListener('click', function () {
            dropdown.classList.add('clicked');

            dropdownScene = scene;
            dropdownMenu.open = true;
            var rect = dropdown.getBoundingClientRect();
            dropdownMenu.position(rect.right - dropdownMenu.innerElement.clientWidth, rect.bottom);
        });

        row.addEventListener('click', function (e) {
            if (e.target === row || e.target === name || e.target === date) {
                if (parseInt(config.scene.id, 10) === parseInt(scene.id, 10))
                    return;

                editor.call('picker:scene:close');
                editor.call('scene:load', scene.id);
            }
        });

        return row;
    };

    var sortScenes = function (scenes) {
        scenes.sort(function (a, b) {
            var primary = parseInt(config.project.primaryScene, 10);
            if (primary === parseInt(a.id, 10)) {
                return -1;
            } else if (primary === parseInt(b.id, 10)) {
                return 1;
            } else {
                if (a.modified < b.modified) {
                    return 1;
                } else if (a.modified > b.modified) {
                    return -1;
                } else {
                    return 0;
                }
            }
        });
    };

    // call picker
    editor.method('picker:scene', function() {
        if (!overlay.hidden) return;

        progressBar.hidden = false;

        // load scenes
        editor.call('scenes:list', function (items) {
            progressBar.hidden = true;
            scenes = items;
            sortScenes(scenes);
            scenes.forEach(function (scene) {
                var row = createSceneEntry(scene);
                container.appendChild(row);
            });
        });

        // show overlay
        overlay.hidden = false;
    });

    // close picker
    editor.method('picker:scene:close', function() {
        overlay.hidden = true;
    });

    var onSceneDeleted = function (sceneId) {
        if (overlay.hidden) return;

        var row = document.getElementById('picker-scene-' + sceneId);
        if (row) {
            row.parentElement.removeChild(row);
        }

        delete dropdowns[sceneId];

        for (var i = 0; i < scenes.length; i++) {
            if (parseInt(scenes[i].id, 10) === parseInt(sceneId, 10)) {
                // close dropdown menu if current scene deleted
                if (dropdownScene === scenes[i])
                    dropdownMenu.open = false;

                scenes.splice(i, 1);
                break;
            }
        }

        // if loaded scene deleted do not allow closing popup
        if (!config.scene.id || parseInt(config.scene.id, 10) === parseInt(sceneId, 10)) {
            close.classList.add('hidden');
            overlay.clickable = false;
        }
    };

    // subscribe to messenger pack.delete
    editor.on('messenger:pack.delete', function (data) {
        onSceneDeleted(data.pack.id);
    });

    // subscribe to messenger pack.new
    editor.on('messenger:pack.new', function (data) {
        if (overlay.hidden) return;

        editor.call('scenes:get', data.pack.id, function (scene) {
            if (overlay.hidden) return; // check if hidden when Ajax returns

            scenes.push({
                id: scene.id,
                modified: scene.modified,
                name: scene.name
            });

            sortScenes(scenes);

            var row = createSceneEntry(scene);

            // put the new row at the right place
            for (var i = 0; i < scenes.length; i++) {
                if (parseInt(scenes[i].id, 10) === parseInt(data.pack.id, 10)) {
                    if (i === 0) {
                        container.insertBefore(row, container.firstChild);
                    } else {
                        var next = i == scenes.length - 1 ? null : document.getElementById('picker-scene-' + scenes[i+1].id);
                        container.insertBefore(row, next);
                    }

                    break;
                }
            }
        });
    });

    var onPrimarySceneChanged = function (newValue, oldValue) {
        if (overlay.hidden || parseInt(newValue, 10) === parseInt(oldValue, 10)) return;

        sortScenes(scenes);

        container.innerHTML = '';

        scenes.forEach(function (scene) {
            container.appendChild(createSceneEntry(scene));
        });
    };

    editor.on('project:primaryScene', onPrimarySceneChanged);

    // handle permission changes
    editor.on('permissions:set:' + config.self.id, function () {
        if (editor.call('permissions:write')) {
            panel.classList.remove('disabled');
        } else {
            panel.classList.add('disabled');
        }
    });

    // open picker if no scene is loaded
    if (!config.scene.id)
        editor.call('picker:scene');

});


/* editor/pickers/picker-node.js */
editor.once('load', function() {
    'use strict';

    var overlay = new ui.Overlay();
    overlay.class.add('picker-node');
    overlay.center = false;
    overlay.hidden = true;

    var root = editor.call('layout.root');
    root.append(overlay);

    var currentEntities = null;
    var currentAsset = null;

    // esc to close
    editor.call('hotkey:register', 'picker:node:close', {
        key: 'esc',
        callback: function() {
            if (overlay.hidden)
                return;

            overlay.hidden = true;
        }
    });

    // on close asset picker
    overlay.on('hide', function() {
        // reset root header
        var root = editor.call('attributes.rootPanel');
        root.style.zIndex = '';

        // select entities again
        editor.call('selector:history', false);
        editor.call('selector:set', 'entity', currentEntities);
        editor.once('selector:change', function () {
            editor.call('selector:history', true);
        });

        // emit event
        editor.emit('picker:node:close');

        currentEntities = null;
        currentAsset = null;
    });

    var addMapping = function (index, assetId) {
        var resourceIds = [];
        var actions = [];

        for (var i = 0, len = currentEntities.length; i < len; i++) {

            var history = currentEntities[i].history.enabled;
            currentEntities[i].history.enabled = false;

            if (! currentEntities[i].get('components.model.mapping')) {
                var mapping = {};
                mapping[index] = parseInt(assetId, 10);

                actions.push({
                    path: 'components.model.mapping',
                    undo: undefined,
                    redo: mapping
                });

                currentEntities[i].set('components.model.mapping', mapping);

                resourceIds.push(currentEntities[i].get('resource_id'));
            } else {
                if (currentEntities[i].has('components.model.mapping.' + index))
                    continue;

                var id = parseInt(assetId, 10);

                actions.push({
                    path: 'components.model.mapping.' + index,
                    undo: undefined,
                    redo: id
                });

                currentEntities[i].set('components.model.mapping.' + index, id);

                resourceIds.push(currentEntities[i].get('resource_id'));
            }

            currentEntities[i].history.enabled = history;
        }

        editor.call('history:add', {
            name: 'entities.' + (resourceIds.length > 1 ? '*' : resourceIds[0]) + '.components.model.mapping',
            undo: function() {
                for(var i = 0; i < resourceIds.length; i++) {
                    var item = editor.call('entities:get', resourceIds[i]);
                    if (! item)
                        continue;

                    var history = item.history.enabled;
                    item.history.enabled = false;

                    if (actions[i].undo === undefined)
                        item.unset(actions[i].path);
                    else
                        item.set(actions[i].path, actions[i].undo);

                    item.history.enabled = history;
                }
            },
            redo: function() {
                for(var i = 0; i < resourceIds.length; i++) {
                    var item = editor.call('entities:get', resourceIds[i]);
                    if (! item)
                        continue;

                    var history = item.history.enabled;
                    item.history.enabled = false;
                    item.set(actions[i].path, actions[i].redo);
                    item.history.enabled = history;
                }
            }
        });


    };

    var addClickEvent = function (field, index) {
        field.addEventListener('click', function () {
            addMapping(index, currentAsset.get('data.mapping.' + index + '.material'));
            overlay.hidden = true;
        });
    };

    var isAlreadyOverriden = function (index) {
        var len = currentEntities.length;
        var overrideCount = 0;
        for (var i = 0; i < len; i++) {
            if (currentEntities[i].has('components.model.mapping.' + index))
                overrideCount++;
        }

        return overrideCount && overrideCount === len;
    };


    // open asset picker
    editor.method('picker:node', function(entities) {
        // show overlay
        overlay.hidden = false;

        currentEntities = entities;

        // select model asset
        currentAsset = editor.call('assets:get', entities[0].get('components.model.asset'));
        editor.call('selector:history', false);
        editor.call('selector:set', 'asset', [currentAsset]);

        editor.once('attributes:inspect[asset]', function () {
            editor.call('selector:history', true);

            // change header name
            editor.call('attributes:header', 'Entity Materials');

            // hide asset info
            editor.emit('attributes:assets:toggleInfo', false);

            // get mesh instances panel
            var panelNodes = editor.call('attributes:asset:model:nodesPanel');
            panelNodes.style.zIndex = 102;
            panelNodes.style.overflow = 'visible';

            var root = editor.call('attributes.rootPanel');
            root.style.zIndex = 102;

            // flash panel
            panelNodes.flash();

            // add special class
            panelNodes.class.add('picker-node', 'noHeader');

            // add help
            var help = new ui.Label({
                text: '<h5>SELECT MESH INSTANCE</h5>Choose a mesh instance to customize the material for ' + (currentEntities.length > 1 ? 'these Entities.' : 'this Entity.')
            });
            help.class.add('help');
            panelNodes.prepend(help);

            // add click events for each mesh instance field
            var fields = panelNodes.element.getElementsByClassName('field-asset');
            for (var i = 0, len = fields.length; i < len; i++) {
                if (isAlreadyOverriden(i)) {
                    fields[i].classList.add('disabled');
                } else {
                    addClickEvent(fields[i], i);
                }
            }

            // focus panel
            setTimeout(function() {
                panelNodes.element.focus();
            }, 100);
        });

    });


    // close asset picker
    editor.method('picker:node:close', function() {
        // hide overlay
        overlay.hidden = true;
    });
});


/* framework/framework_grid.js */
pc.Grid = function (device, size, divisions) {
    // Create the vertex format
    var vertexFormat = new pc.gfx.VertexFormat(device, [
        { semantic: pc.gfx.SEMANTIC_POSITION, components: 3, type: pc.gfx.ELEMENTTYPE_FLOAT32 },
        { semantic: pc.gfx.SEMANTIC_COLOR, components: 4, type: pc.gfx.ELEMENTTYPE_UINT8, normalize: true }
    ]);

    var size = size || 140;
    var divisions = divisions || 14;
    var interval = size / divisions;
    var numVerts = (divisions + 1) * 4;
    var gridColor = [136, 136, 136, 255];
    var axisColor = [0, 0, 0, 255];
    var color;

    // Create a vertex buffer
    this.vertexBuffer = new pc.gfx.VertexBuffer(device, vertexFormat, numVerts);
    var vertexBuffer = this.vertexBuffer;

    // Fill the vertex buffer
    var iterator = new pc.gfx.VertexIterator(vertexBuffer);
    for (i = -(divisions / 2); i <= divisions / 2; i++) {
        color = (i === 0) ? axisColor : gridColor;
        iterator.element[pc.gfx.SEMANTIC_POSITION].set(-size/2, 0.0, i * interval);
        iterator.element[pc.gfx.SEMANTIC_COLOR].set(color[0], color[1], color[2], color[3]);
        iterator.next();
        iterator.element[pc.gfx.SEMANTIC_POSITION].set( size/2, 0.0, i * interval);
        iterator.element[pc.gfx.SEMANTIC_COLOR].set(color[0], color[1], color[2], color[3]);
        iterator.next();
        iterator.element[pc.gfx.SEMANTIC_POSITION].set(i * interval, 0.0, -size/2);
        iterator.element[pc.gfx.SEMANTIC_COLOR].set(color[0], color[1], color[2], color[3]);
        iterator.next();
        iterator.element[pc.gfx.SEMANTIC_POSITION].set(i * interval, 0.0,  size/2);
        iterator.element[pc.gfx.SEMANTIC_COLOR].set(color[0], color[1], color[2], color[3]);
        if (i !== divisions / 2) {
            iterator.next();
        }
    }
    iterator.end();

    var library = device.getProgramLibrary();
    var shader = library.getProgram("basic", { vertexColors: true, diffuseMapping: false });

    var material = new pc.scene.Material();
    material.shader = shader;

    var mesh = new pc.scene.Mesh();
    mesh.vertexBuffer = vertexBuffer;
    mesh.indexBuffer[0] = null;
    mesh.primitive[0].type = pc.gfx.PRIMITIVE_LINES;
    mesh.primitive[0].base = 0;
    mesh.primitive[0].count = vertexBuffer.getNumVertices();
    mesh.primitive[0].indexed = false;

    var node = new pc.scene.GraphNode();
    node.setName('grid');

    var meshInstance = new pc.scene.MeshInstance(node, mesh, material);

    var model = new pc.scene.Model();
    model.graph = node;
    model.meshInstances = [ meshInstance ];

    this.model = model;
};

pc.Grid.prototype = {
    destroy: function () {
        if (this.vertexBuffer) {
            this.vertexBuffer.destroy();
            this.vertexBuffer = null;
        }
    }
};


/* framework/framework_designer.js */
pc.editor = pc.editor || {};
pc.extend(pc.editor, function() {

    var time;
    var rect = new pc.Vec4(0, 0, 1, 1);

    var Designer = function (canvas, options) {
        this._inTools = true;

        var context = this;
        context.assets._prefix = '../../api/';

        this.scene = new pc.Scene();

        for (var key in context.systems) {
            if (context.systems.hasOwnProperty(key)) {
                context.systems[key]._inTools = true;
            }
        }

        this.grid = null;
        this.setDesignerSettings(options.designerSettings);

        this.picker = new pc.scene.Picker(this.graphicsDevice, 1, 1);
        this.shading = pc.RENDERSTYLE_SOLID;

        this.cameras = this._createCameras();
        this.activeCamera = null;
        this.setActiveCamera(this.cameras[0].getGuid());

        // Draw immediately
        this.redraw = true;
    };

    Designer = pc.inherits(Designer, pc.Application);

    Designer.prototype._createCameras = function () {
        // perspective
        var perspective = new pc.Entity();
        perspective.name = 'Perspective';
        perspective.addComponent('camera', {
            fov: 45,
            orthoHeight: 100,
            projection: 0,
            enabled: true,
            nearClip: 0.1,
            farClip: 10000,
            priority: 0,
            clearColorBuffer: true,
            clearDepthBuffer: true
        });
        this.root.addChild(perspective);
        perspective.setPosition(9.2, 7, 9);
        perspective.setEulerAngles(-25, 45, 0);

        // top
        var top = new pc.Entity();
        top.name = 'Top';
        top.addComponent('camera', {
            fov: 45,
            orthoHeight: 5,
            projection: 1,
            farClip: 100000,
            nearClip: 0.1,
            enabled: true,
            priority: 0,
            clearColorBuffer: true,
            clearDepthBuffer: true
        });
        this.root.addChild(top);
        top.setPosition(0, 1000, 0);
        top.setEulerAngles(-90, 0,0);
        top.enabled = false;

        // bottom
        var bottom = new pc.Entity();
        bottom.name = 'Bottom';
        bottom.addComponent('camera', {
            fov: 45,
            orthoHeight: 5,
            projection: 1,
            farClip: 100000,
            nearClip: 0.1,
            enabled: true,
            priority: 0,
            clearColorBuffer: true,
            clearDepthBuffer: true
        });
        this.root.addChild(bottom);
        bottom.setPosition(0, -1000, 0);
        bottom.setEulerAngles(90, 0,0);
        bottom.enabled = false;

        // front
        var front = new pc.Entity();
        front.name = 'Front';
        front.addComponent('camera', {
            fov: 45,
            orthoHeight: 5,
            projection: 1,
            farClip: 100000,
            nearClip: 0.1,
            enabled: true,
            priority: 0,
            clearColorBuffer: true,
            clearDepthBuffer: true
        });
        this.root.addChild(front);
        front.setPosition(0, 0, 1000);
        front.setEulerAngles(0, 0,0);
        front.enabled = false;

        // back
        var back = new pc.Entity();
        back.name = 'Back';
        back.addComponent('camera', {
            fov: 45,
            orthoHeight: 5,
            projection: 1,
            farClip: 100000,
            nearClip: 0.1,
            enabled: true,
            priority: 0,
            clearColorBuffer: true,
            clearDepthBuffer: true
        });
        this.root.addChild(back);
        back.setPosition(0, 0, -1000);
        back.setEulerAngles(-180, 0,-180);
        back.enabled = false;

        // left
        var left = new pc.Entity();
        left.name = 'Left';
        left.addComponent('camera', {
            fov: 45,
            orthoHeight: 5,
            projection: 1,
            farClip: 100000,
            nearClip: 0.1,
            enabled: true,
            priority: 0,
            clearColorBuffer: true,
            clearDepthBuffer: true
        });
        this.root.addChild(left);
        left.setPosition(-1000, 0, 0);
        left.setEulerAngles(0, -90,0);
        left.enabled = false;

        // right
        var right = new pc.Entity();
        right.name = 'Right';
        right.addComponent('camera', {
            fov: 45,
            orthoHeight: 5,
            projection: 1,
            farClip: 100000,
            nearClip: 0.1,
            enabled: true,
            priority: 0,
            clearColorBuffer: true,
            clearDepthBuffer: true
        });
        this.root.addChild(right);
        right.setPosition(1000, 0, 0);
        right.setEulerAngles(0, 90,0);
        right.enabled = false;

        return [perspective, top, bottom, front, back, left, right];
    };

    Designer.prototype._createCamera = function () {
        var camera = new pc.Entity();

        camera.addComponent('camera', {
            fov: 45,
            orthoHeight: 100,
            projection: 0,
            enabled: true,
            nearClip: 0.1,
            farClip: 10000,
            priority: 0
        });

        this.root.addChild(camera);
        camera.setPosition(100, 50, 100);
        camera.setEulerAngles(-20, 45, 0);

        return camera;
    };

    Designer.prototype.getCamera = function (pathOrGuid) {
        return this.root.findByPath(pathOrGuid) || this.root.findByGuid(pathOrGuid);
    };

    /**
     * @name pc.editor.Designer#render
     * @description Render a frame to the graphics device. For the designer this is only called when necessary, not every frame like in a game application
     */
    Designer.prototype.render = function () {
        var self = this;

        var context = this;
        var renderer = this.renderer;

        var root = context.root;
        context.root.syncHierarchy();

        this.fire('preRender', null);

        var device = this.graphicsDevice;
        var dw = device.width;
        var dh = device.height;

        // Give viewport(s) a grey border
        device.setRenderTarget(null);
        device.updateBegin();
        device.setViewport(0, 0, dw, dh);
        device.setScissor(0, 0, dw, dh);
        device.clear({
            color: [0.5, 0.5, 0.5, 1],
            flags: pc.gfx.CLEARFLAG_COLOR
        });
        device.updateEnd();

        var setRenderStyle = function (style) {
            var drawCalls = context.scene.drawCalls;
            for (var i = 0; i < drawCalls.length; i++) {
                if (!drawCalls[i].command) {
                    var meshInstance = drawCalls[i];
                    if (typeof meshInstance.mesh.primitive[style] !== 'undefined') {
                        meshInstance.renderStyle = style;
                    }
                }
            }
        };

        var cameraEntity = this.activeCamera;
        if (cameraEntity && cameraEntity.camera) {
            var cameraNode = cameraEntity.camera.camera;
            // Link the named camera to the relevant viewport
            cameraNode.setRenderTarget(null);

            // set camera properties defined in designer settings
            if (!this.isUserCamera(cameraEntity)) {
                var clearColor = this.designerSettings.camera_clear_color;
                cameraEntity.camera.clearColor = new pc.Color(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
                if (cameraEntity === this.cameras[0]) {
                    cameraEntity.camera.nearClip = this.designerSettings.camera_near_clip;
                    cameraEntity.camera.farClip = this.designerSettings.camera_far_clip;
                }
            }

            cameraEntity.camera.rect = rect;

            cameraEntity.camera.frameBegin();
            setRenderStyle(this.shading);
            renderer.render(context.scene, cameraNode);
            cameraEntity.camera.frameEnd();
        }
    };

    Designer.prototype.getDt = function () {
        var now = (window.performance && window.performance.now) ? performance.now() : Date.now();
        var dt = (now - (time || now)) / 1000.0;
        dt = pc.math.clamp(dt, 0, 0.1); // Maximum delta is 0.1s or 10 fps.
        time = now;
        return dt;
    };

    /**
     * @name pc.editor.Designer#tick
     * @description Custom tick function that constantly checks to see if the app has invalidated the 3d view.
     */
    Designer.prototype.tick = function () {
        if (this.redraw) {
            var dt = this.getDt();
            var keepRendering = editor.call('viewport:keepRendering');
            this.redraw = keepRendering;

            // Perform ComponentSystem update
            editor.emit('viewport:update', dt);
            pc.ComponentSystem.fire('toolsUpdate', dt);
            editor.emit('viewport:postUpdate', dt);
            editor.emit('viewport:gizmoUpdate', dt);

            this.render();
        }

        // Submit a request to queue up a new animation frame immediately
        requestAnimationFrame(this.tick.bind(this), this.graphicsDevice.canvas);
    };

    /**
     * @name pc.editor.Designer#resize
     * @description Resize the canvas
     */
    Designer.prototype.resize = function (w, h) {
        this.graphicsDevice.width = w;
        this.graphicsDevice.height = h;
        this.picker.resize(w, h);
        this.redraw = true;
    };

    /**
     * @name pc.editor.Designer#setActiveViewportShading
     * @description Sets the render style of the active viewport to be 'normal' or wireframe.
     */
    Designer.prototype.setActiveViewportShading = function (shading) {
        this.shading = shading;
        this.redraw = true;
    };

    Designer.prototype.setActiveCamera = function (guid) {
        var camera = this.root.findByGuid(guid);
        if (camera) {
            this._activateCamera(camera);
            this.redraw = true;
        }
    };

    Designer.prototype.isUserCamera = function (camera) {
        return this.cameras && this.cameras.indexOf(camera) < 0;
    };

    Designer.prototype._activateCamera = function (cameraEntity) {
        var prev = this.activeCamera;
        if (this.activeCamera && this.activeCamera !== cameraEntity) {
            var entity = editor.call('entities:get', this.activeCamera.getGuid());

            if (this.activeCamera.script)
                this.activeCamera.removeComponent('script');

            if (this.isUserCamera(this.activeCamera) && this.activeCamera.camera)
                this.activeCamera.enabled = entity.get('enabled');
        }

        this.activeCamera = cameraEntity;

        cameraEntity.enabled = true;

        if (cameraEntity.script)
            cameraEntity.removeComponent('script');

        cameraEntity.addComponent('script', {
            scripts: [{
                url: '/editor/scene/js/framework/camera/designer_camera.js'
            }],
            runInTools: true
        });
    };

    Designer.prototype.setDesignerSettings = function (settings) {
        this.designerSettings = settings;

        if (this.grid) {
            this.scene.removeModel(this.grid.model);
            this.grid.destroy();
        }

        settings.grid_divisions = parseInt(settings.grid_divisions, 10);
        if (settings.grid_divisions > 0) {
            this.grid = new pc.Grid(this.graphicsDevice, settings.grid_divisions * settings.grid_division_size, settings.grid_divisions);
            this.scene.addModel(this.grid.model);
        }

        this.redraw = true;
    };

    // Redraw when we set the skybox
    Designer.prototype._setSkybox = function (cubemaps) {
        Designer._super._setSkybox.call(this, cubemaps);
        this.redraw = true;
    };

    return {
        /**
        * @name pc.editor.user
        * @description Details of the currently authenticated user
        */
        user: null,
        /**
        * @name pc.editor.owner
        * @description Details of the owner of the depot that is being edited
        */
        owner: null,
        /**
        * @name pc.editor.depot
        * @description Details of the depot that is being edited
        */
        depot: null,
        Designer: Designer
    };
}());


/* editor/viewport/viewport.js */
editor.once('load', function() {
    'use strict'

    var canvas = new ui.Canvas({
        id: 'canvas-3d'
    });

    var settings = editor.call('designerSettings');

    // create designer framework
    var framework = new pc.editor.Designer(canvas.element, {
        mouse: new pc.input.Mouse(canvas.element),
        touch: !!('ontouchstart' in window) ? new pc.input.TouchDevice(canvas.element) : null,
        designerSettings: settings.json()
    });

    settings.on('*:set', function() {
        framework.setDesignerSettings(settings.json());
    });


    // add canvas
    editor.call('layout.viewport').prepend(canvas);

    var frameSelection = false;
    var flyMode = false;

    // methods

    // get canvas
    editor.method('viewport:canvas', function() {
        return canvas;
    });

    // get framework
    editor.method('viewport:framework', function() {
        return framework;
    });

    // re-render viewport
    editor.method('viewport:render', function () {
        framework.redraw = true;
    });

    editor.method('viewport:frameSelectionStart', function () {
        frameSelection = true;
    });

    editor.method('viewport:frameSelectionEnd', function () {
        frameSelection = false;
    });

    editor.method('viewport:flyModeStart', function () {
        flyMode = true;
    });

    editor.method('viewport:flyModeEnd', function () {
        flyMode = false;
    });

    // returns true if the viewport should continuously render
    editor.method('viewport:keepRendering', function () {
        return frameSelection || flyMode;
    });

    editor.method('viewport:flyMode', function () {
        return flyMode;
    });

    framework.start();
    editor.emit('viewport:load', framework);
});


/* editor/viewport/viewport-resize.js */
editor.once('load', function() {
    'use strict'

    var container = editor.call('layout.viewport');
    var canvas = editor.call('viewport:canvas');
    var framework = editor.call('viewport:framework');

    if (! canvas)
        return;


    // once canvas resized
    // notify framework
    canvas.on('resize', function(width, height) {
        framework.resize(width, height);
        editor.call('viewport:render');
        editor.emit('viewport:resize', width, height);
    });

    // handle canvas resizing
    // 20 times a second
    // if size is already same, nothing will happen
    setInterval(function() {
        var rect = container.element.getBoundingClientRect();
        canvas.resize(Math.floor(rect.width), Math.floor(rect.height));
    }, 1000 / 60);
});


/* editor/viewport/viewport-expand.js */
editor.once('load', function() {
    'use strict';

    var panels = [ ];
    panels.push(editor.call('layout.left'));
    panels.push(editor.call('layout.assets'));
    panels.push(editor.call('layout.right'));

    var expanded = false;


    editor.method('viewport:expand', function(state) {
        if (state === undefined)
            state = ! expanded;

        if (expanded === state)
            return;

        expanded = state;

        for(var i = 0; i < panels.length; i++)
            panels[i].hidden = expanded;

        editor.emit('viewport:expand', state);
    });


    editor.method('viewport:expand:state', function() {
        return expanded;
    });


    // expand hotkey
    editor.call('hotkey:register', 'viewport:expand', {
        key: 'space',
        callback: function() {
            editor.call('viewport:expand');
        }
    });
});


/* editor/viewport/viewport-entities-create.js */
editor.once('load', function() {
    'use strict';

    var framework = editor.call('viewport:framework');

    // entities indexes for parenting
    var childIndex = { };
    var entitiesIndex = { };

    // queue for hierarchy resync
    var awaitingResyncHierarchy = false;

    var resyncHierarchy = function() {
        awaitingResyncHierarchy = false;

        // sync hierarchy
        framework.context.root.syncHierarchy();

        // render
        editor.call('viewport:render');
    };

    var createEntity = function (obj) {
        var entity = new pc.Entity();

        entitiesIndex[obj.get('resource_id')] = entity;

        entity.setName(obj.get('name'));
        entity.setGuid(obj.get('resource_id'));
        entity.setLocalPosition(obj.get('position.0'), obj.get('position.1'), obj.get('position.2'));
        entity.setLocalEulerAngles(obj.get('rotation.0'), obj.get('rotation.1'), obj.get('rotation.2'));
        entity.setLocalScale(obj.get('scale.0'), obj.get('scale.1'), obj.get('scale.2'));
        entity._enabled = obj.has('enabled') ? obj.get('enabled') : true;
        entity._enabledInHierarchy = entity._enabled;

        if (obj.has('labels')) {
            obj.get('labels').forEach(function (label) {
                entity.addLabel(label);
            });
        }

        entity.template = obj.get('template');

        return entity;
    };

    var processEntity = function (obj) {
        // create entity
        var entity = obj.entity = createEntity(obj);

        // add components
        var components = obj.json().components;
        for(var key in components) {
            if (framework.context.systems[key]) {
                framework.context.systems[key].addComponent(entity, components[key]);
            } else {
                console.log('unknown component "' + key + '", in entity ' + obj.get('resource_id'));
            }
        }

        var children = obj.get('children');
        for(var i = 0; i < children.length; i++) {
            childIndex[children[i]] = entity;

            if (entitiesIndex[children[i]])
                entity.addChild(entitiesIndex[children[i]]);
        }

        // parenting
        if (! obj.get('parent')) {
            // root
            framework.context.root.addChild(entity);
        } else {
            // child
            var parent = childIndex[obj.get('resource_id')];
            if (parent)
                parent.addChild(entity);
        }

        // queue resync hierarchy
        // done on timeout to allow bulk entity creation
        // without rerender and sync after each entity
        if (! awaitingResyncHierarchy) {
            awaitingResyncHierarchy = true;
            setTimeout(resyncHierarchy, 0);
        }
    };

    var createEntities = function() {
        // new entity created
        editor.on('entities:add', function (obj) {
            processEntity(obj);
        });

        // clear entitiesIndex and childIndex
        editor.on('entities:remove', function (obj) {
            delete entitiesIndex[obj.get('resource_id')];
            var children = obj.get('children');
            for(var i = 0; i < children.length; i++) {
                delete childIndex[children[i]];
            }
        });

        var entities = editor.call('entities:list');
        entities.forEach(processEntity);
    };

    // handle synchronization - all assets must be loaded
    // before creating entities in the engine
    var assetsLoaded = false;
    var entitiesLoaded = false;

    editor.once('assets:load', function () {
        assetsLoaded = true;
        // if entities already loaded then create them
        if (entitiesLoaded)
            createEntities();
    });

    editor.once('entities:load', function() {
        entitiesLoaded = true;
        // if assets already loaded then create entities
        if (assetsLoaded)
            createEntities();
    });
});


/* editor/viewport/viewport-entities-observer-binding.js */
editor.once('load', function() {
    'use strict';

    var app = editor.call('viewport:framework');

    editor.on('entities:add', function (obj) {
        // subscribe to changes
        obj.on('*:set', function(path, value) {
            var entity = obj.entity;
            if (! entity)
                return;

            if (path === 'name') {
                entity.setName(obj.get('name'));

            } else if (path.startsWith('position')) {
                entity.setLocalPosition(new pc.Vec3(obj.get('position.0'), obj.get('position.1'), obj.get('position.2')));

            } else if (path.startsWith('rotation')) {
                entity.setLocalEulerAngles(new pc.Vec3(obj.get('rotation.0'), obj.get('rotation.1'), obj.get('rotation.2')));

            } else if (path.startsWith('scale')) {
                entity.setLocalScale(new pc.Vec3(obj.get('scale.0'), obj.get('scale.1'), obj.get('scale.2')));

            } else if (path.startsWith('enabled')) {
                entity.enabled = obj.get('enabled');

            } else if (path.startsWith('parent')) {
                var parent = editor.call('entities:get', obj.get('parent'));
                if (parent && parent.entity)
                    entity.reparent(parent.entity);
            } else if (path === 'components.model.type' && value === 'asset') {
                // WORKAROUND
                // entity deletes asset when switching to primitive, restore it
                // do this in a timeout to allow the model type to change first
                setTimeout(function () {
                    var assetId = obj.get('components.model.asset');
                    if (assetId)
                        entity.model.asset = assetId;
                });
            }

            // render
            editor.call('viewport:render');
        });

        var reparent = function (child, index) {
            var childEntity = editor.call('entities:get', child);
            if (childEntity && childEntity.entity && obj.entity) {
                childEntity.entity.reparent(obj.entity, index);
            }
        };

        obj.on('children:insert', reparent);
        obj.on('children:move', reparent);

        obj.on('destroy', function () {
            if (obj.entity) {
                obj.entity.destroy();
                editor.call('viewport:render');
            }
        });
    });

    editor.on('entities:remove', function (obj) {
        var entity = obj.entity;
        if (! entity)
            return;

        // var framework = editor.call('viewport:framework');
        // if (framework && framework.selectedEntity === entity)
        //     framework.deselectEntity();

        entity.destroy();
        obj.entity = null;
        editor.call('viewport:render');
    });
});


/* editor/viewport/viewport-entities-components-binding.js */
editor.once('load', function() {
    'use strict';

    // converts the data to runtime types
    var runtimeComponentData = function (component, data) {
        var result = {};
        for (var key in data) {
            if (data.hasOwnProperty(key)) {
                result[key] = editor.call('components:convertValue', component, key, data[key]);
            }
        }

        return result;
    };

    editor.on('entities:add', function (obj) {
        var framework;

        // subscribe to changes
        obj.on('*:set', function(path, value) {
            if (path.indexOf('components') !== 0) {
                return;
            }

            var entity = obj.entity;
            if (!entity) {
                return;
            }

            var parts = path.split('.');
            var component = parts[1];
            var property = parts[2];

            // ignore script component
            if (component === 'script' && property)
                return;

            if (!entity[component]) {
                if (!property) {
                    // add component
                    var data = runtimeComponentData(component, value);
                    framework = editor.call('viewport:framework');
                    framework.context.systems[component].addComponent(entity, data);

                    // render
                    editor.call('viewport:render');
                }
            } else if (property) {
                // edit component property
                value = obj.get('components.' + component + '.' + property);
                entity[component][property] = editor.call('components:convertValue', component, property, value);

                // render
                editor.call('viewport:render');
            }

        });

        var setComponentProperty = function (path, value) {
            if (path.indexOf('components') !== 0) {
                return;
            }

            var entity = obj.entity;
            if (!entity) {
                return;
            }

            var parts = path.split('.');
            var component = parts[1];
            var property = parts[2];

            // ignore script component
            if (component === 'script')
                return;

            if (property) {
                // edit component property
                value = obj.get('components.' + component + '.' + property);
                entity[component][property] = editor.call('components:convertValue', component, property, value);

                // render
                editor.call('viewport:render');
            }
        };

        obj.on('*:insert', setComponentProperty);
        obj.on('*:remove', setComponentProperty);

        obj.on('*:unset', function (path) {
            if (path.indexOf('components') !== 0) {
                return;
            }

            var entity = obj.entity;
            if (!entity)
                return;

            var parts = path.split('.');
            var component = parts[1];
            var property = parts[2];

            if (property) {
                // edit component property
                var value = obj.get('components.' + component + '.' + property);
                entity[component][property] = editor.call('components:convertValue', component, property, value);
            } else if (entity[component]) {
                // remove component
                var framework = editor.call('viewport:framework');
                framework.context.systems[component].removeComponent(entity);
            }

            // render
            editor.call('viewport:render');
        });

    });

});


/* editor/viewport/viewport-scene-settings.js */
editor.once('load', function() {
    'use strict';

    var sceneSettings = editor.call('sceneSettings');
    var app = editor.call('viewport:framework');
    var assetsLoaded = false;
    var sceneSettingsLoaded = false;
    var updating;

    // queue settings apply
    var queueApplySettings = function() {
        if (!sceneSettingsLoaded || updating || !assetsLoaded)
            return;

        updating = true;

        setTimeout(applySettings, 1000 / 30);
    };

    // apply settings
    var applySettings = function() {
        if (! app) return;

        updating = false;

        // apply scene settings
        app.applySceneSettings(sceneSettings.json());

        // need to update all materials on scene settings change
        for(var i = 0; i < app.assets._assets.length; i++) {
            if (app.assets._assets[i].type !== 'material' || !app.assets._assets[i].resource)
                continue;

            app.assets._assets[i].resource.update();
        }

        editor.call('viewport:render');
    };

    // on settings change
    sceneSettings.on('*:set', queueApplySettings);

    editor.on('assets:load', function () {
        assetsLoaded = true;
        queueApplySettings();
    });

    editor.on('sceneSettings:load', function () {
        sceneSettingsLoaded = true;
        queueApplySettings();
    });
});


/* editor/viewport/viewport-assets.js */
editor.once('load', function() {
    'use strict';

    var framework = editor.call('viewport:framework');
    if (! framework) return;

    var assets = framework.assets;

    editor.call('assets:registry:bind', assets);

    // add assets to asset registry
    editor.on('assets:add', function (asset) {
        // do only for target assets
        if (asset.get('source'))
            return;

        // when data is changed
        asset.on('*:set', function (path, value) {
            editor.call('viewport:render');
        });

        var assetEngine = assets.get(asset.get('id'));
        // render on asset load
        assetEngine.on('load', function() {
            editor.call('viewport:render');
        });
        // render on asset data change
        assetEngine.on('change', function() {
            editor.call('viewport:render');
        });

        // render
        editor.call('viewport:render');
    });

    // remove assets from asset registry
    editor.on('assets:remove', function (asset) {
        // re-render
        editor.call('viewport:render');
    });

    // patch update for materials to re-render the viewport
    var update = pc.PhongMaterial.prototype.update;
    pc.PhongMaterial.prototype.update = function () {
        update.call(this);
        editor.call('viewport:render');
    };
});


/* editor/viewport/viewport-drop-model.js */
editor.once('load', function() {
    'use strict';

    var canvas = editor.call('viewport:canvas');
    if (! canvas) return;

    var dropRef = editor.call('drop:target', {
        ref: canvas.element,
        type: 'asset.model',
        drop: function(type, data) {
            if (!config.scene.id)
                return;

            if (type !== 'asset.model')
                return;

            // asset
            var asset = editor.call('assets:get', parseInt(data.id, 10));
            if (! asset)
                return;

            // parent
            var parent = null;
            if (editor.call('selector:type') === 'entity')
                parent = editor.call('selector:items')[0];

            var component = editor.call('components:getDefault', 'model');
            component.type = 'asset';
            component.asset = parseInt(asset.get('id'), 10);

            // new entity
            editor.call('entities:new', {
                parent: parent,
                name: asset.get('name'),
                components: {
                    model: component
                }
            });

            setTimeout(function() {
                editor.call('viewport:focus');
            }, 0);
        }
    });
});


/* editor/viewport/viewport-drop-material.js */
editor.once('load', function() {
    'use strict';

    var app = editor.call('viewport:framework');
    if (! app) return;

    var canvas = editor.call('viewport:canvas');
    var evtPickHover = null;
    var hoverMaterial = null;
    var hoverAsset = null;
    var hoverEntity = null;
    var hoverMeshInstance = null;

    var onPickHover = function(node, picked) {
        var meshInstance = null;

        if (node && node._icon)
            node = node._getEntity();

        if (! node || ! editor.call('entities:get', node.getGuid())) {
            onHover(null);
            return;
        }

        if (picked instanceof pc.MeshInstance)
            meshInstance = picked;

        if (node.model && meshInstance && (! meshInstance.node._parent || ! meshInstance.node._parent._icon)) {
            onHover(node, meshInstance);
        } else {
            onHover(null);
        }
    };

    var onLeave = function() {
        if (! hoverEntity)
            return;

        if (hoverEntity.model.type === 'asset') {

            if (hoverAsset) {
                hoverAsset.data.mapping[hoverAsset._materialIndHover].material = hoverAsset._materialBeforeHover;
                hoverAsset.fire('change', hoverAsset, 'data', hoverAsset.data, hoverAsset.data);
                delete hoverAsset._materialBeforeHover;
            } else {
                var mapping = hoverEntity.model.mapping;
                if (hoverEntity._materialBeforeHover === undefined)
                    delete mapping[hoverEntity._materialIndHover];
                else
                    mapping[hoverEntity._materialIndHover] = hoverEntity._materialBeforeHover;
                hoverEntity.model.mapping = mapping;
            }
        } else if (hoverEntity._materialBeforeHover) {
            hoverEntity.model.material = hoverEntity._materialBeforeHover;
        }

        delete hoverEntity._materialBeforeHover;
        delete hoverEntity._materialIndHover;

        editor.call('viewport:render');
    };

    var onHover = function(entity, meshInstance) {
        if (entity === hoverEntity && meshInstance === hoverMeshInstance)
            return;

        onLeave();

        hoverAsset = null;
        hoverEntity = entity;
        hoverMeshInstance = meshInstance;

        if (hoverEntity) {
            if (hoverEntity.model.type === 'asset') {
                var ind = hoverEntity.model.model.meshInstances.indexOf(hoverMeshInstance);
                if (ind !== -1) {
                    var mapping = hoverEntity.model.mapping;
                    if (!mapping || !mapping.hasOwnProperty(ind)) {

                        hoverAsset = app.assets.get(hoverEntity.model.asset);
                        hoverAsset._materialBeforeHover = hoverAsset.data.mapping[ind].material;
                        hoverAsset._materialIndHover = ind;

                        hoverAsset.data.mapping[ind].material = hoverMaterial.id;
                        hoverAsset.fire('change', hoverAsset, 'data', hoverAsset.data, hoverAsset.data);
                    } else {
                        hoverEntity._materialBeforeHover = mapping[ind];
                        hoverEntity._materialIndHover = ind;

                        mapping[ind] = hoverMaterial.id;
                        hoverEntity.model.mapping = mapping;
                    }

                    editor.call('viewport:render');
                }
            } else {
                hoverEntity._materialBeforeHover = hoverEntity.model.material;
                hoverEntity.model.material = hoverMaterial.resource;
                editor.call('viewport:render');
            }
        }
    };

    var dropRef = editor.call('drop:target', {
        ref: canvas.element,
        type: 'asset.material',
        hole: true,
        drop: function(type, data) {
            if (! config.scene.id)
                return;

            if (evtPickHover)
                evtPickHover.unbind();

            if (! hoverEntity || ! hoverEntity.model)
                return;

            var entity = editor.call('entities:get', hoverEntity.getGuid());
            if (! entity)
                return;

            if (entity.get('components.model.type') === 'asset') {
                var ind = hoverEntity.model.model.meshInstances.indexOf(hoverMeshInstance);
                if (ind === -1)
                    return;

                // if we are setting the model asset mapping then set it and return
                if (hoverAsset) {
                    var asset = editor.call('assets:get', hoverAsset.id);
                    if (asset.has('data.mapping.' + ind + '.material'))
                        asset.set('data.mapping.' + ind + '.material', hoverMaterial.id);

                    return;
                }

                // set mapping with custom history action
                // to prevent bug where undoing will set the mapping to
                // null instead of unsetting it
                var history = entity.history.enabled;
                entity.history.enabled = false;
                var resourceId = entity.get('resource_id');

                var undo = {};
                var redo = {};

                if (!entity.get('components.model.mapping')) {
                    var mapping = {};
                    mapping[ind] = parseInt(hoverMaterial.id, 10);
                    entity.set('components.model.mapping', mapping);
                    undo.path = 'components.model.mapping';
                    undo.value = undefined;
                    redo.path = undo.path;
                    redo.value = mapping;
                } else {
                    undo.path = 'components.model.mapping.' + ind;
                    undo.value = entity.has('components.model.mapping.' + ind) ?
                                 entity.get('components.model.mapping.' + ind) :
                                 undefined;
                    redo.path = undo.path;
                    redo.value = parseInt(hoverMaterial.id, 10);

                    entity.set('components.model.mapping.' + ind, parseInt(hoverMaterial.id, 10));

                }
                entity.history.enabled = history;

                editor.call('history:add', {
                    name: 'entities.' + resourceId + '.components.model.mapping',
                    undo: function() {
                        var item = editor.call('entities:get', resourceId);
                        if (! item) return;

                        var history = item.history.enabled;
                        item.history.enabled = false;

                        if (undo.value === undefined)
                            item.unset(undo.path);
                        else
                            item.set(undo.path, undo.value);

                        item.history.enabled = history;
                    },
                    redo: function() {
                        var item = editor.call('entities:get', resourceId);
                        if (! item) return;

                        var history = item.history.enabled;
                        item.history.enabled = false;
                        if (redo.value === undefined)
                            item.unset(redo.path);
                        else
                            item.set(redo.path, redo.value);
                        item.history.enabled = history;
                    }
                });
            } else {
                // primitive model
                entity.set('components.model.materialAsset', hoverMaterial.id);
            }
        },
        over: function(type, data) {
            if (! config.scene.id)
                return;

            hoverMaterial = app.assets.get(parseInt(data.id, 10));
            if (! hoverMaterial)
                return;

            app.assets.load(hoverMaterial);

            hoverEntity = null;
            hoverMeshInstance = null;

            evtPickHover = editor.on('viewport:pick:hover', onPickHover);
        },
        leave: function() {
            if (!config.scene.id)
                return;

            if (evtPickHover) {
                evtPickHover.unbind();
                evtPickHover = null;
            }

            onLeave();
        }
    });
});


/* editor/viewport/viewport-drop-cubemap.js */
editor.once('load', function() {
    'use strict';

    var app = editor.call('viewport:framework');
    if (! app)
        return;

    var canvas = editor.call('viewport:canvas');
    var evtPickHover = null;
    var evtViewportHover = null;
    var evtOnLoad = null;
    var hoverSkybox = null;
    var hoverMaterial = null;
    var hoverCubemap = null;
    var hoverEntity = undefined;
    var hoverMeshInstance = null;
    var hoverSkyboxFields = [ 'cubeMap', 'prefilteredCubeMap128', 'prefilteredCubeMap64', 'prefilteredCubeMap32', 'prefilteredCubeMap16', 'prefilteredCubeMap8', 'prefilteredCubeMap4' ]

    var onPickHover = function(node, picked) {
        var meshInstance = null;

        if (node && node._icon)
            node = node._getEntity();

        if (! node) {
            onHover(null);
            return;
        }

        if (picked instanceof pc.MeshInstance)
            meshInstance = picked;

        if (node.model && meshInstance && (! meshInstance.node._parent || ! meshInstance.node._parent._icon)) {
            onHover(node, meshInstance);
        } else {
            onHover(null);
        }
    };

    var onLeave = function() {
        if (hoverSkybox) {
            app.scene.setSkybox(hoverSkybox);
            hoverSkybox = null;
            editor.call('viewport:render');
        }

        if (hoverMaterial) {
            for(var i = 0; i < hoverSkyboxFields.length; i++)
                hoverMaterial[hoverSkyboxFields[i]] = hoverMaterial._hoverCubeMap[hoverSkyboxFields[i]];
            hoverMaterial.update();
            delete hoverMaterial._hoverCubeMap;
            hoverMaterial = null;

            editor.call('viewport:render');
        }
    };

    var onCubemapLoad = function() {
        setCubemap();
    };

    var setCubemap = function() {
        if (hoverEntity) {
            hoverMaterial = hoverMeshInstance.material;

            if (hoverMaterial) {
                if (! hoverMaterial._hoverCubeMap) {
                    hoverMaterial._hoverCubeMap = { };
                    for(var i = 0; i < hoverSkyboxFields.length; i++)
                        hoverMaterial._hoverCubeMap[hoverSkyboxFields[i]] = hoverMaterial[hoverSkyboxFields[i]];
                }

                for(var i = 0; i < hoverSkyboxFields.length; i++)
                    hoverMaterial[hoverSkyboxFields[i]] = hoverCubemap.resources[i];

                hoverMaterial.update();

                editor.call('viewport:render');
            }
        } else {
            if (! hoverSkybox) {
                hoverSkybox = [ null, null, null, null, null, null ];
                var id = editor.call('sceneSettings').get('render.skybox');
                if (id) {
                    var engineCubemap = app.assets.get(id);
                    if (engineCubemap)
                        hoverSkybox = engineCubemap.resources;
                }
            }

            if (hoverCubemap)
                app.scene.setSkybox(hoverCubemap.resources);

            editor.call('viewport:render');
        }
    };

    var onHover = function(entity, meshInstance) {
        if (entity === hoverEntity && meshInstance === hoverMeshInstance)
            return;

        onLeave();

        hoverEntity = entity;
        hoverMeshInstance = meshInstance;

        setCubemap();
    };

    var dropRef = editor.call('drop:target', {
        ref: canvas.element,
        type: 'asset.cubemap',
        hole: true,
        drop: function(type, data) {
            if (!config.scene.id)
                return;

            if (evtPickHover) {
                evtPickHover.unbind();
                evtPickHover = null;
            }

            hoverCubemap.off('load', onCubemapLoad);

            onLeave();

            if (hoverEntity) {
                var materialId;
                if (hoverEntity.model.type === 'asset') {
                    var ind = hoverEntity.model.model.meshInstances.indexOf(hoverMeshInstance);

                    if (hoverEntity.model.mapping && hoverEntity.model.mapping[ind]) {
                        materialId = hoverEntity.model.mapping[ind];
                    } else if (hoverEntity.model.asset) {
                        var modelAsset = editor.call('assets:get', hoverEntity.model.asset);

                        if (modelAsset && ind !== -1)
                            materialId = modelAsset.get('data.mapping.' + ind + '.material');
                    }
                } else if (hoverEntity.model.materialAsset) {
                    materialId = hoverEntity.model.materialAsset.id;
                }

                if (materialId) {
                    var materialAsset = editor.call('assets:get', materialId);
                    if (materialAsset)
                        materialAsset.set('data.cubeMap', hoverCubemap.id);
                }
                editor.call('viewport:render');
            } else {
                editor.call('sceneSettings').set('render.skybox', hoverCubemap.id);
                app.scene.setSkybox(hoverCubemap.resources);
                editor.call('viewport:render');
            }
        },
        over: function(type, data) {
            if (!config.scene.id)
                return;

            hoverCubemap = app.assets.get(parseInt(data.id, 10));
            if (! hoverCubemap)
                return;

            hoverCubemap.loadFaces = true;
            app.assets.load(hoverCubemap);
            hoverCubemap.on('load', onCubemapLoad);

            hoverEntity = undefined;
            hoverMeshInstance = null;

            evtPickHover = editor.on('viewport:pick:hover', onPickHover);
            onHover(null, null);
        },
        leave: function() {
            if (!config.scene.id)
                return;

            if (evtPickHover) {
                evtPickHover.unbind();
                evtPickHover = null;
            }

            hoverCubemap.off('load', onCubemapLoad);

            onLeave();
        }
    });
});


/* editor/viewport/viewport-userdata.js */
editor.once('load', function() {
    'use strict';

    var framework = editor.call('viewport:framework');

    editor.on('userdata:load', function (userdata) {
        if (! editor.call('permissions:read'))
            return;

        var cameras = framework ? framework.cameras : null;
        // get framework cameras and restore transforms and camera data
        // from userdata
        if (! cameras || ! cameras.length)
            return;

        cameras.forEach(function (camera) {
            var name = camera.getName().toLowerCase();
            if (! userdata.get('cameras.' + name))
                return;

            var pos = userdata.get('cameras.' + name + '.position');
            if (pos)
                camera.setPosition(pos[0], pos[1], pos[2]);

            var rot = userdata.get('cameras.' + name + '.rotation');
            if (rot)
                camera.setEulerAngles(rot[0], rot[1], rot[2]);

            if (camera.camera.projection === 1)
                camera.camera.orthoHeight = Number(userdata.get('cameras.' + name + '.orthoHeight'));

            var focus = userdata.get('cameras.' + name + '.focus');
            // store focus on entity where designer_camera script can pick it up
            // when it initializes
            if (focus)
                camera.focus = new pc.Vec3(focus[0], focus[1], focus[2]);

            // if we already have a designer_camera script initialized then re-set the focus
            if (camera.script && camera.script.designer_camera && camera.focus)
                camera.script.designer_camera.focus.copy(camera.focus);
        });

        editor.call('viewport:render');
    });
});


/* editor/viewport/viewport-user-cameras.js */
editor.once('load', function() {
    'use strict';

    var app = editor.call('viewport:framework');
    var container = new pc.Entity(app);
    app.root.addChild(container);

    var cameraModel = null;
    var cameras = { };
    var userdata = { };


    // material default
    var materialDefault = new pc.BasicMaterial();
    materialDefault.color = new pc.Color(1, 1, 1, 1);
    materialDefault.update();
    // material quad
    var materialQuad = new pc.BasicMaterial();
    materialQuad.color = new pc.Color(1, 1, 1, .25);
    materialQuad.cull = pc.CULLFACE_NONE;
    materialQuad.blend = true;
    materialQuad.blendSrc = pc.BLENDMODE_SRC_ALPHA;
    materialQuad.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
    materialQuad.update();
    // material behind
    var materialBehind = new pc.BasicMaterial();
    materialBehind.color = new pc.Color(1, 1, 1, .15);
    materialBehind.blend = true;
    materialBehind.blendSrc = pc.BLENDMODE_SRC_ALPHA;
    materialBehind.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
    materialBehind.depthTest = false;
    materialBehind.update();


    // Subscribes to user data of specified user
    var addUser = function (userId) {
        editor.once('userdata:' + userId + ':raw', function (data) {
            loadUserData(userId, data);
        });

        userdata[userId] = editor.call('realtime:subscribe:userdata', config.scene.id, userId);
    };

    // Removes user camera and unsubscribes from userdata
    var removeUser = function (userId) {
        if (userId === config.self.id) return;

        // unsubscribe from realtime userdata
        if (userdata[userId]) {
            userdata[userId].destroy();
            delete userdata[userId];
            editor.unbind('realtime:userdata:' + userId + ':op:cameras');
        }

        // remove user camera
        if (cameras[userId]) {
            cameras[userId].destroy();
            delete cameras[userId];
            editor.call('viewport:render');
        }
    };

    var close = .25;
    var far = .5;
    var horiz = .5;
    var vert = .375;

    var createCameraModel = function() {
        var vertexFormat = new pc.gfx.VertexFormat(app.graphicsDevice, [
            { semantic: pc.gfx.SEMANTIC_POSITION, components: 3, type: pc.gfx.ELEMENTTYPE_FLOAT32 }
        ]);
        // box
        var buffer = new pc.gfx.VertexBuffer(app.graphicsDevice, vertexFormat, 12 * 2);
        var iterator = new pc.gfx.VertexIterator(buffer);

        // top
        iterator.element[pc.SEMANTIC_POSITION].set(close * horiz, close * vert, 0);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(horiz, vert, -far);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(horiz, vert, -far);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-horiz, vert, -far);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-horiz, vert, -far);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-close * horiz, close * vert, 0);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-close * horiz, close * vert, 0);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(close * horiz, close * vert, 0);
        iterator.next();
        // bottom
        iterator.element[pc.SEMANTIC_POSITION].set(close * horiz, -close * vert, 0);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(horiz, -vert, -far);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(horiz, -vert, -far);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-horiz, -vert, -far);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-horiz, -vert, -far);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-close * horiz, -close * vert, 0);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-close * horiz, -close * vert, 0);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(close * horiz, -close * vert, 0);
        iterator.next();
        // sides
        iterator.element[pc.SEMANTIC_POSITION].set(close * horiz, -close * vert, 0);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(close * horiz, close * vert, 0);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(horiz, -vert, -far);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(horiz, vert, -far);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-horiz, -vert, -far);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-horiz, vert, -far);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-close * horiz, -close * vert, 0);
        iterator.next();
        iterator.element[pc.SEMANTIC_POSITION].set(-close * horiz, close * vert, 0);
        iterator.next();
        iterator.end();
        // node
        var node = new pc.GraphNode();
        // mesh
        var mesh = new pc.Mesh();
        mesh.vertexBuffer = buffer;
        mesh.indexBuffer[0] = null;
        mesh.primitive[0].type = pc.PRIMITIVE_LINES;
        mesh.primitive[0].base = 0;
        mesh.primitive[0].count = buffer.getNumVertices();
        mesh.primitive[0].indexed = false;
        // meshInstance
        var meshInstance = new pc.MeshInstance(node, mesh, materialDefault);
        meshInstance.updateKey();
        // model
        cameraModel = new pc.Model();
        cameraModel.graph = node;
        cameraModel.meshInstances = [ meshInstance ];
    };

    // Creates user camera and binds to real time events
    var loadUserData = function (userId, data) {
        if (! cameraModel)
            createCameraModel();

        // add user camera
        var camera = cameras[userId] = new pc.Entity(app);
        camera.addComponent('model');
        camera.model.model = cameraModel.clone();
        container.addChild(camera);

        var cameraInner = new pc.Entity(app);
        cameraInner.addComponent('model');
        cameraInner.model.model = cameraModel.clone();
        cameraInner.model.model.meshInstances[0].material = materialBehind;
        camera.addChild(cameraInner);

        var cameraQuad = new pc.Entity(app);
        cameraQuad._userCamera = userId;
        cameraQuad.addComponent('model', { type: 'plane' });
        cameraQuad.model.material = materialQuad;
        cameraQuad.rotate(90, 0, 0);
        cameraQuad.setLocalScale(close * horiz * 2, 1, close * vert * 2);
        camera.addChild(cameraQuad);

        var pos = data.cameras.perspective.position || [ 0, 0, 0 ];
        camera.setPosition(pos[0], pos[1], pos[2]);

        var rot = data.cameras.perspective.rotation || [ 0, 0, 0 ];
        camera.setEulerAngles(rot[0], rot[1], rot[2]);

        camera.pos = camera.getPosition().clone();
        camera.rot = camera.getRotation().clone();

        editor.call('viewport:render');

        // server > client
        var evt = editor.on('realtime:userdata:' + userId + ':op:cameras', function(op) {
            if (op.p.length !== 3 || ! op.oi || op.p[1] !== 'perspective')
                return;

            if (op.p[2] === 'position') {
                camera.pos.set(op.oi[0], op.oi[1], op.oi[2]);
                editor.call('viewport:render');
            } else if (op.p[2] === 'rotation') {
                camera.rot.setFromEulerAngles(op.oi[0], op.oi[1], op.oi[2]);
                editor.call('viewport:render');
            }
        });

        var unload = function () {
            if (evt) {
                evt.unbind();
                evt = null;
            }

            removeUser(userId);
        };

        editor.once('scene:unload', unload);
        editor.once('realtime:disconnected', unload);

    };

    // Add user who comes online
    editor.on('whoisonline:add', function (userId) {
        // ignore the logged in user
        if (userId === config.self.id) return;

        var add = function () {
            // do not add users without read access
            if (editor.call('permissions:read', userId))
                addUser(userId);

            // subscribe to project permission changes
            editor.on('permissions:set:' + userId, function () {
                if (editor.call('permissions:read', userId)) {
                    if (! userdata[userId]) {
                        // WORKAROUND
                        // wait a bit before adding, for userdata to be created at sharejs
                        setTimeout(function () {
                            addUser(userId);
                        }, 500);
                    }
                } else {
                    removeUser(userId);
                }
            });
        };

        if (!config.scene.id) {
            editor.once('scene:raw', add);
        } else {
            add();
        }

    });

    // Remove user who goes offline
    editor.on('whoisonline:remove', function (userId) {
        if (userId === config.self.id) return;

        removeUser(userId);
        editor.unbind('permissions:set:' + userId);
    });

    var vecA = new pc.Vec3();
    var vecB = new pc.Vec3();
    var quat = new pc.Quat();

    editor.on('viewport:update', function(dt) {
        var render = false;

        for(var id in cameras) {
            var camera = cameras[id];

            if (vecA.copy(camera.getPosition()).sub(camera.pos).length() > 0.01) {
                vecA.lerp(camera.getPosition(), camera.pos, 4 * dt);
                camera.setPosition(vecA);
                render = true;
            } else {
                camera.setPosition(camera.pos);
            }

            vecA.set(0, 0, -1);
            vecB.set(0, 0, -1);
            camera.getRotation().transformVector(vecA, vecA);
            camera.rot.transformVector(vecB, vecB);

            if (vecA.dot(vecB) < 0.999) {
                quat = camera.getRotation().slerp(camera.getRotation(), camera.rot, 8 * dt);
                camera.setRotation(quat);
                render = true;
            } else {
                camera.setRotation(camera.rot);
            }
        }

        if (render)
            editor.call('viewport:render');
    });
});


/* editor/viewport/viewport-context-menu.js */
editor.once('load', function() {
    'use strict';

    var currentEntity = null;
    var root = editor.call('layout.root');

    // create data for entity menu
    var menu;

    // wait until all entities are loaded
    // before creating the menu to make sure
    // that the menu data for entities have been created
    editor.once('entities:load', function () {
        var menuData = { };
        var entityMenuData = editor.call('menu:get', 'entity');
        if (entityMenuData) {
            for (var key in entityMenuData.items) {
                menuData[key] = entityMenuData.items[key];
            }
        }

        // TODO
        // menuData['enable'] = {
        //     title: 'Enable',
        //     icon: '&#58421;',
        //     hide: function () {
        //         return currentEntity.get('enabled');
        //     },
        //     select: function() {
        //         currentEntity.set('enabled', true);
        //     }
        // };

        // menuData['disable'] = {
        //     title: 'Disable',
        //     icon: '&#58422;',
        //     hide: function () {
        //         return !currentEntity.get('enabled');
        //     },
        //     select: function() {
        //         currentEntity.set('enabled', false);
        //     }
        // };

        // menuData['copy'] = {
        //     title: 'Copy',
        //     icon: '&#57891;',
        //     select: function() {
        //         editor.call('entities:copy', currentEntity);
        //     }
        // };

        // menuData['paste'] = {
        //     title: 'Paste',
        //     icon: '&#57892;',
        //     filter: function () {
        //         return !editor.call('entities:clipboard:empty');
        //     },
        //     select: function() {
        //         editor.call('entities:paste', currentEntity);
        //     }
        // };

        // menuData['duplicate'] = {
        //     title: 'Duplicate',
        //     icon: '&#57908;',
        //     filter: function () {
        //         return currentEntity !== editor.call('entities:root');
        //     },
        //     select: function() {
        //         editor.call('entities:duplicate', currentEntity);
        //     }
        // };

        // menuData['delete'] = {
        //     title: 'Delete',
        //     icon: '&#58657;',
        //     filter: function () {
        //         return currentEntity !== editor.call('entities:root');
        //     },
        //     select: function() {
        //         editor.call('entities:delete', currentEntity);
        //     }
        // };


        // menu
        menu = ui.Menu.fromData(menuData);
        root.append(menu);
    });

    editor.method('viewport:contextmenu', function (x, y, entity) {
        if (! editor.call('permissions:write'))
            return;

        currentEntity = entity;
        menu.open = true;
        menu.position(x + 1, y);
    });
});


/* editor/viewport/viewport-tap.js */
editor.once('load', function() {
    'use strict';

    var canvas = editor.call('viewport:canvas');
    if (! canvas) return;

    function Tap(evt, rect) {
        this.x = this.lx = this.sx = evt.clientX - rect.left;
        this.y = this.ly = this.sy = evt.clientY - rect.top;
        this.nx = 0;
        this.ny = 0;
        this.move = false;
        this.down = false;
    };
    Tap.prototype.update = function(evt, rect) {
        var x = evt.clientX - rect.left;
        var y = evt.clientY - rect.top;

        // if it's moved
        if (this.down && ! this.move && (Math.abs(this.sx - x) + Math.abs(this.sy - y)) > 8)
            this.move = true;

        // moving
        if (this.move) {
            this.nx = x - this.lx;
            this.ny = y - this.ly;
            this.lx = this.x;
            this.ly = this.y;
        }

        // coords
        this.x = x;
        this.y = y;
    };

    var taps = [ ];
    var tapMouse = new Tap({ clientX: 0, clientY: 0 }, { left: 0, top: 0 });
    var inViewport = false;


    var evtMouseMove = function(evt) {
        var rect = canvas.element.getBoundingClientRect();
        tapMouse.update(evt, rect);
        editor.emit('viewport:tap:move', tapMouse, evt);

        // render if mouse moved within viewport
        if (evt.clientX >= rect.left && evt.clientX <= rect.right && evt.clientY >= rect.top && evt.clientY <= rect.bottom) {
            if (! inViewport) {
                inViewport = true;
                editor.emit('viewport:hover', true);
            }
            editor.call('viewport:render');
        } else if (inViewport) {
            inViewport = false;
            editor.emit('viewport:hover', false);
        }
    };

    var evtMouseUp = function(evt) {
        if (evt.button !== 0)
            return;

        if (tapMouse.down) {
            tapMouse.down = false;
            tapMouse.update(evt, canvas.element.getBoundingClientRect());
            editor.emit('viewport:tap:end', tapMouse, evt);

            if (! tapMouse.move)
                editor.emit('viewport:tap:click', tapMouse, evt);

            var ind = taps.indexOf(tapMouse);
            if (ind !== -1)
                taps.splice(ind, 1);
        }
    };

    canvas.element.addEventListener('mousedown', function(evt) {
        if (evt.button !== 0)
            return;

        var rect = canvas.element.getBoundingClientRect();

        tapMouse.move = false;
        tapMouse.down = true;
        tapMouse.sx = evt.clientX - rect.left;
        tapMouse.sy = evt.clientY - rect.top;
        taps.push(tapMouse);

        editor.emit('viewport:tap:start', tapMouse, evt);

        if (document.activeElement && document.activeElement.tagName.toLowerCase() === 'input')
            document.activeElement.blur();

        evt.preventDefault();
    }, false);

    canvas.element.addEventListener('mouseover', function() {
        editor.emit('viewport:hover', true);
    }, false);

    canvas.element.addEventListener('mouseleave', function(evt) {
        // ignore tooltip
        var target = evt.toElement || evt.relatedTarget;
        if (target && target.classList.contains('cursor-tooltip'))
            return;

        editor.emit('viewport:hover', false);
    }, false);

    window.addEventListener('mousemove', evtMouseMove, false);
    window.addEventListener('dragover', evtMouseMove, false);
    window.addEventListener('mouseup', evtMouseUp, false);
});


/* editor/viewport/viewport-pick.js */
editor.once('load', function() {
    'use strict';

    var app = editor.call('viewport:framework');
    var picker = new pc.scene.Picker(app.graphicsDevice, 1, 1);
    var pickedData = {
        node: null,
        picked: null
    };
    var mouseTap = null;
    var inViewport = false;

    editor.on('viewport:update', function() {
        if (! inViewport && pickedData.node) {
            pickedData.node = null;
            pickedData.picked = null;
            editor.emit('viewport:pick:hover', null, null);
        }

        if (! inViewport || ! mouseTap || mouseTap.down)
            return;

        // pick
        editor.call('viewport:pick', mouseTap.x, mouseTap.y, function(node, picked) {
            if (pickedData.node !== node || pickedData.picked !== picked) {
                pickedData.node = node;
                pickedData.picked = picked;

                editor.emit('viewport:pick:hover', pickedData.node, pickedData.picked);
            }
        });
    });

    editor.on('viewport:hover', function(hover) {
        inViewport = hover;
    });

    editor.on('viewport:resize', function(width, height) {
        picker.resize(width, height);
    });

    editor.method('viewport:pick', function(x, y, fn) {
        // prepare picker
        picker.prepare(app.activeCamera.camera.camera, app.scene);

        // pick node
        var picked = picker.getSelection({
            x: x,
            y: app.graphicsDevice.canvas.height - y
        });

        if (! picked.length || ! picked[0]) {
            fn(null, null);
        } else {
            var node = picked[0].node;

            // traverse to pc.Entity
            while (! (node instanceof pc.Entity) && node && node.getParent) {
                node = node.getParent();
            }
            if (! node) return;

            fn(node, picked[0]);
        }
    });

    editor.on('viewport:tap:move', function(tap) {
        mouseTap = tap;
    });

    editor.on('viewport:tap:click', function(tap) {
        if (! inViewport)
            return;

        if (pickedData.node) {
            editor.emit('viewport:pick:node', pickedData.node, pickedData.picked);
        } else {
            editor.call('viewport:pick', tap.x, tap.y, function(node, picked) {
                if (pickedData.node !== node || pickedData.picked !== picked) {
                    pickedData.node = node;
                    pickedData.picked = picked;
                }

                if (pickedData.node) {
                    editor.emit('viewport:pick:node', pickedData.node, pickedData.picked);
                } else {
                    editor.emit('viewport:pick:clear');
                }
            });
        }
    });
});


/* editor/viewport/viewport-cursor.js */
editor.once('load', function() {
    'use strict';

    var state = false;
    var inViewport = false;

    // mouse hovering state on viewport
    editor.on('viewport:hover', function(hover) {
        if (inViewport === hover)
            return;

        inViewport = hover;

        if (! inViewport) {
            state = false;

            if (! editor.call('drop:active'))
                editor.call('cursor:set', '');
        }
    });

    var checkPicked = function(node, picked) {
        var hover = false;

        // if mouse in viewport && entity model has an asset
        // then set cursor to 'crosshair' to indicate
        // that next click will select node in model asset
        if (inViewport && node && node.model && node.model.asset && node.model.model) {
            if (editor.call('selector:type') === 'entity' &&
                editor.call('selector:count') === 1 &&
                editor.call('selector:items')[0].entity === node) {

                hover = true;
            }
        }

        // change cursor if needed
        if (state !== hover) {
            state = hover;
            editor.call('cursor:set', state ? 'crosshair' : '');
        }
    }

    editor.on('viewport:pick:node', checkPicked)
    editor.on('viewport:pick:hover', checkPicked);
});


/* editor/viewport/viewport-tooltips.js */
editor.once('load', function() {
    'use strict';

    var inViewport = false;
    var nameLast = '';
    var timeout = null;
    var pickedLast = null;
    var nodeLast = null;
    var delay = 500;

    editor.on('viewport:hover', function(state) {
        inViewport = state;

        if (! inViewport) {
            nameLast = '';
            pickedLast = null;
            nodeLast = null;
            editor.call('cursor:text', '');
            clearTimeout(timeout);
        }
    });

    var showTooltip = function() {
        editor.call('cursor:text', nameLast);
    };

    var checkPicked = function(node, picked) {
        var name = '';

        if (inViewport && node) {
            if (node._icon) {
                // icon
                var entity = node._getEntity && node._getEntity();
                if (entity)
                    name = entity.name;
            } else if (node._userCamera) {
                name = '@';
                editor.call('users:loadOne', node._userCamera, function(data) {
                    name = '@' + (data && data.username || 'anonymous');
                });
            } else if (node.model && node.model.asset && node.model.model && picked && picked.node) {
                // entity model meshInstance
                name = node.name + ' &#8594; ' + picked.node.name;
            } else {
                // normal entity
                if (editor.call('entities:get', node.getGuid()))
                    name = node.name;
            }
        }

        if (nodeLast !== node || pickedLast !== picked || nameLast !== name) {
            editor.call('cursor:text', '');
            clearTimeout(timeout);
            if (nameLast || name)
                timeout = setTimeout(showTooltip, delay);
        }

        if (nameLast !== name)
            nameLast = name;

        if (pickedLast !== picked)
            pickedLast = picked;

        if (nodeLast !== node)
            nodeLast = node;
    };

    editor.on('viewport:pick:node', checkPicked)
    editor.on('viewport:pick:hover', checkPicked);
});


/* editor/viewport/viewport-focus.js */
editor.once('load', function() {
    'use strict';

    var app = editor.call('viewport:framework');
    var defaultSize = new pc.Vec3(1, 1, 1);
    var defaultSizeSmall = new pc.Vec3(.2, .2, .2);
    var aabb = new pc.shape.Aabb();
    var aabbA = new pc.shape.Aabb();
    var aabbB = new pc.shape.Aabb();
    var aabbC = new pc.shape.Aabb();

    var calculateChildAABB = function(entity) {
        aabbB.center.copy(entity.getPosition());
        aabbB.halfExtents.copy(defaultSizeSmall);
        aabbA.add(aabbB);

        if (entity.model && entity.model.model && entity.model.model.meshInstances.length) {
            var meshes = entity.model.model.meshInstances;
            for(var i = 0; i < meshes.length; i++) {
                meshes[i].node.getWorldTransform();
                aabbA.add(meshes[i].aabb);
            }
        } else if (entity.collision) {
            switch(entity.collision.type) {
                case 'box':
                    aabbC.halfExtents.copy(entity.collision.halfExtents);
                    aabbB.setFromTransformedAabb(aabbC, entity.getWorldTransform());
                    aabbA.add(aabbB);
                    break;
                case 'sphere':
                    aabbB.center.copy(entity.getPosition());
                    aabbB.halfExtents.set(entity.collision.radius, entity.collision.radius, entity.collision.radius);
                    aabbA.add(aabbB);
                    break;
                case 'capsule':
                case 'cylinder':
                    aabbC.halfExtents.set(entity.collision.radius, entity.collision.radius, entity.collision.radius);
                    aabbC.halfExtents.data[entity.collision.axis] = entity.collision.height;
                    aabbB.setFromTransformedAabb(aabbC, entity.getWorldTransform());
                    aabbA.add(aabbB);
                    break;
            }
        } else {
            aabbB.center.copy(entity.getPosition());
            aabbB.halfExtents.copy(defaultSize);
            aabbA.add(aabbB);
        }

        var children = entity.getChildren();
        for(var i = 0; i < children.length; i++) {
            if (! (children[i] instanceof pc.Entity))
                continue;

            calculateChildAABB(children[i]);
        }
    };

    editor.method('selection:aabb', function() {
        if (editor.call('selector:type') !== 'entity')
            return null;

        var items = editor.call('selector:items');

        // calculate aabb for selected entities
        for(var i = 0; i < items.length; i++) {
            var entity = items[i].entity;

            if (! entity)
                continue;

            aabbA.center.copy(entity.getPosition());
            aabbA.halfExtents.copy(defaultSizeSmall);
            calculateChildAABB(entity)

            if (i === 0) {
                aabb.copy(aabbA);
            } else {
                aabb.add(aabbA);
            }
        }

        return aabb;
    });

    editor.method('viewport:focus', function() {
        var selection = editor.call('selection:aabb');

        if (! selection)
            return;

        // camera
        var camera = app.activeCamera;
        // get tranform
        var camWtm = camera.getWorldTransform();
        // looking vector
        var camPos = camWtm.getZ();
        // calculate offset distance
        var averageExtent = (selection.halfExtents.x + selection.halfExtents.y + selection.halfExtents.z) / 3;
        var offset = averageExtent / Math.tan(0.5 * camera.camera.fov * Math.PI / 180.0);
        // get camera position
        camPos.normalize().scale(offset * 1.5).add(selection.center);

        var transition = camera.script.designer_camera.transition;
        // set transition information
        transition.eyeStart.copy(camera.getPosition());
        transition.eyeEnd.copy(camPos);
        transition.focusStart.copy(transition.focusEnd);
        transition.focusEnd.copy(aabb.center);
        transition.startTime = pc.time.now();
        transition.active = true;

        editor.call('viewport:frameSelectionStart');
        editor.call('viewport:render');
    });
});


/* editor/help/controls.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');

    var overlay = new ui.Overlay();
    overlay.class.add('help-controls');
    overlay.style.zIndex = 203;
    overlay.center = true;
    overlay.hidden = true;

    // header
    var header = new ui.Label();
    header.text = '<span class="icon">&#57654;</span>Controls';
    header.class.add('header');
    overlay.append(header);

    // close
    var btnClose = new ui.Button();
    btnClose.class.add('close');
    btnClose.text = '&#57650;';
    btnClose.on('click', function() {
        overlay.hidden = true;
    });
    header.element.appendChild(btnClose.element);

    // top image
    var imgTop = new Image();
    imgTop.src = 'https://s3-eu-west-1.amazonaws.com/static.playcanvas.com/images/help-controls.png';
    imgTop.classList.add('top');
    imgTop.draggable = false;
    overlay.append(imgTop);

    var items = [
        {
            buttons: [ 'Ctrl', '$+', 'N' ],
            title: 'New Entity',
            icons: [ '&#57632;' ]
        }, {
            buttons: [ 'Ctrl', '$+', 'C' ],
            title: 'Copy Entity',
            icons: [ '&#58193;' ]
        }, {
            buttons: [ 'Ctrl', '$+', 'V' ],
            title: 'Paste Entity',
            icons: [ '&#58184;' ]
        }, {
            buttons: [ 'Ctrl', '$+', 'D' ],
            title: 'Duplicate Entity',
            icons: [ '&#57638;' ]
        }, {
            buttons: [ 'Ctrl', '$+', 'Z' ],
            title: 'Undo',
            icons: [ '&#57620;' ]
        }, {
            buttons: [ 'Ctrl', '$+', 'Y' ],
            title: 'Redo',
            icons: [ '&#57621;' ]
        }, {
            buttons: [ 'Ctrl', '$+', 'Enter' ],
            title: 'Launch Game',
            icons: [ '&#57649;' ]
        }, {
            buttons: [ 'Space' ],
            title: 'Hide Panels',
            icons: [ '&#57639;' ]
        }, {
            buttons: [ '1', '2', '3' ],
            title: 'Translate / Rotate / Scale Gizmo',
            icons: [ '&#57618;', '&#57619;', '&#57617;' ]
        }, {
            buttons: ['Shift', '$+', '?'],
            title: 'Controls',
            icons: [ '&#57654;']
        }, {
            buttons: ['Ctrl', '$+', 'Space'],
            title: 'How do I...?',
            icons: [ '&#57656;']
        }
    ];

    for(var i = 0; i < items.length; i++) {
        var row = document.createElement('div');
        row.classList.add('row');

        var buttons = document.createElement('div');
        buttons.classList.add('buttons');
        row.appendChild(buttons);

        for(var n = 0; n < items[i].buttons.length; n++) {
            var button = document.createElement('div');
            button.classList.add(items[i].buttons[n] === '$+' ? 'divider': 'button');
            button.textContent = items[i].buttons[n] === '$+' ? '+': items[i].buttons[n];
            buttons.appendChild(button);
        }

        var title = document.createElement('div');
        title.classList.add('title');
        title.textContent = items[i].title;
        row.appendChild(title);

        for(var n = 0; n < items[i].icons.length; n++) {
            var icon = document.createElement('div');
            icon.classList.add('icon');
            icon.innerHTML = items[i].icons[n];
            title.appendChild(icon);
        }

        overlay.append(row);
    }

    root.append(overlay);


    editor.method('help:controls', function() {
        overlay.hidden = false;
    });

    overlay.on('show', function () {
        editor.emit('help:controls:open');
        window.addEventListener('keydown', onKey);
    });

    overlay.on('hide', function () {
        editor.emit('help:controls:close');
        window.removeEventListener('keydown', onKey);
    });

    var onKey = function (e) {
        if (e.keyCode === 27) {
            overlay.hidden = true;
        }
    };

    // hotkey
    editor.call('hotkey:register', 'help:controls', {
        key: 'forward slash',
        shift: true,
        callback: function() {
            editor.call('help:controls');
        }
    });

});


/* editor/help/howdoi.js */
editor.once('load', function () {
    'use strict';

    var viewport = editor.call('layout.viewport');
    var designerSettings = editor.call('designerSettings');
    var focusedMenuItem = null;

    // create main panel
    var panel = new ui.Panel();
    panel.class.add('help-howdoi');
    viewport.append(panel);
    panel.hidden = true;

    var tipsLoaded = false;
    editor.once('help:howdoi:load', function () {
        tipsLoaded = true;
        checkShow();
    });

    var settingsLoaded = false;

    var checkShow = function () {
        if (tipsLoaded && settingsLoaded) {
            panel.hidden = !designerSettings.get('help');
        }
    };

    // hide / show panel based on designer settings
    editor.once('designerSettings:load', function () {
        settingsLoaded = true;
        checkShow();
    });

    // events when panel is shown
    panel.on('show', function () {
        editor.emit('help:howdoi:open');

        var history = designerSettings.history;
        designerSettings.history = false;
        designerSettings.set('help', true);
        designerSettings.history = history;

        editor.on('scene:name', positionWidget);
        editor.on('viewport:resize', positionWidget);
        positionWidget();
    });

    // events when panel is hidden
    panel.on('hide', function () {
        editor.emit('help:howdoi:close');

        var history = designerSettings.history;
        designerSettings.history = false;
        designerSettings.set('help', false);
        designerSettings.history = history;

        editor.unbind('scene:name', positionWidget);
        editor.unbind('viewport:resize', positionWidget);

        if (!config.self.tips['howdoi'])
            editor.call('guide:bubble:show', 'howdoi', bubble, 200, true);
    });

    // bubble that appears after closing the widget for the first time
    var bubble = function () {
        var bubble = editor.call(
            'guide:bubble',
            'Get more help when you need it',
            "Click here to bring back the help widget whenever you want.",
            40,
            '',
            'bottom',
            editor.call('layout.toolbar')
        );

        bubble.element.style.top = '';
        bubble.element.style.bottom = '118px';
        return bubble;
    };

    // open / close panel depending on designer settings
    designerSettings.on('help:set', function (value) {
        panel.hidden = !value;
    });

    // input field
    var input = new ui.TextField();
    input.renderChanges = false;
    input.keyChange = true;
    input.elementInput.placeholder = 'How do I...?';
    panel.append(input);

    // close button
    var close = new ui.Button({
        text: 'Hide <span class="font-icon" style="position: absolute; top: 0">&#57650;</span>'
    });
    close.class.add('close');
    panel.append(close);

    close.on('click', function () {
        panel.hidden = true;
    });

    // menu with all the suggestions
    var menu = new ui.Menu();
    menu.open = false;
    panel.append(menu);
    menu.elementOverlay.parentElement.removeChild(menu.elementOverlay);

    var suggestions = [];

    // method to register new suggestions
    editor.method('help:howdoi:register', function (data) {

        // create new menu item
        var menuItem = new ui.MenuItem({
            text: data.title
        });

        menu.append(menuItem);

        // add suggestion
        suggestions.push({
            data: data,
            menuItem: menuItem
        });

        // method that opens the popup for this menu item
        var openPopup = function () {
            // store popup event
            storeEvent(input.value, data.title);

            // open popup
            editor.call('help:howdoi:popup', data);
            // reset input value and blur field
            input.value = '';
            input.elementInput.blur();
            // hide menu
            menu.open = false;
        };

        // open popup on mousedown instead of 'click' because
        // for some reason the 'click' event doesn't always work here
        menuItem.element.addEventListener('mousedown', function (e) {
            e.stopPropagation() ;
            openPopup();
        });

        // focus element on mouse enter
        var mouseEnter = function () {
            if (focusedMenuItem && focusedMenuItem !== menuItem.element)
                focusedMenuItem.classList.remove('focused');

            focusedMenuItem = menuItem.element;
            focusedMenuItem.classList.add('focused');

            // remove mouseenter listener until mouseleave fires to prevent
            // an issue with Firefox
            menuItem.element.removeEventListener('mouseenter', mouseEnter);
        };

        menuItem.element.addEventListener('mouseenter', mouseEnter);

        // unfocus element on mouse leave
        var mouseLeave = function () {
            if (focusedMenuItem && focusedMenuItem === menuItem.element) {
                focusedMenuItem.classList.remove('focused');
                focusedMenuItem = null;
            }

            menuItem.element.addEventListener('mouseenter', mouseEnter);
        };

        menuItem.element.addEventListener('mouseleave', mouseLeave);


        // on enter open the popup
        input.elementInput.addEventListener('keydown', function (e) {
            if (e.keyCode === 13) {
                if (focusedMenuItem === menuItem.element) {
                    e.preventDefault();
                    e.stopPropagation();

                    openPopup();
                }
            }
        });

    });

    // on esc delete the input text or hide the widget if no text is there
    input.elementInput.addEventListener('keydown', function (e) {
        if (e.keyCode === 27) {
            if (input.value) {
                storeEvent(input.value);
                input.value = '';
                input.elementInput.focus();
            } else {
                menu.open = false;
            }
        }
    });

    var blurTimeout;

    // on focus open the menu and then refocus the input field
    input.elementInput.addEventListener('focus', function () {
        menu.open = true;
        input.elementInput.focus();

        if (blurTimeout) {
            clearTimeout(blurTimeout);
            blurTimeout = null;
        }

    });

    // on blur hide the menu
    input.elementInput.addEventListener('blur', function () {
        if (menu.open) {
            if (blurTimeout)
                clearTimeout(blurTimeout);

            // timeout necessary because when we focus the field and open the
            // menu the input field gets blurred
            blurTimeout = setTimeout(function () {
                menu.open = false;
                blurTimeout = null;
            });
        }
    });

    // Store event for when viewing (or not viewing) a topic
    var storeEvent = function (search, topic) {
        Ajax.post('/editor/scene/{{scene.id}}/events', {
            name: 'editor:help',
            title: topic,
            text: search
        });
    };

    // filter suggestions as the user types
    input.on('change', function (value) {
        filterSuggestions(value);
    });

    var filterSuggestions = function (text) {
        var valid;

        // sort suggestions by title first
        suggestions.sort(function (a, b) {
            if (a.data.title < b.data.title)
                return -1;

            if (a.data.title > b.data.title)
                return 1;

            if (a.data.title === b.data.title)
                return 0;
        });

        if (text) {
            var query = [];

            // turn each word in a regex
            var words = text.split(' ');
            words.forEach(function (word) {
                word = word.replace(/[^\w]/g, ''); // remove invalid chars
                if (! word.length) return;

                query.push(new RegExp('(^|\\s)' + word.replace(/[^\w]/, ''), 'i'));
            });


            suggestions.forEach(function (suggestion) {
                suggestion.score = 0;
            });

            var matched = suggestions.slice();
            var foundSomeMatches = false;

            // Score suggestions for each word in the text
            // Each word filters the results more and more
            query.forEach(function (q, index) {
                var stageMatches = [];

                matched.forEach(function (suggestion) {
                    // reset score and make menu item hidden
                    if (index === 0) {
                        suggestion.score = 0;
                        suggestion.menuItem.class.add('hidden');
                    }

                    var title = suggestion.data.title;
                    var keywords = suggestion.data.keywords;

                    var score = 0;

                    // match the title and increase score
                    // if match is closer to the start the score is bigger
                    var match = q.exec(title);
                    if (match) {
                        score += 1 / (match.index || 0.1);
                    }

                    // add to the score for each matched keyword
                    for (var i = 0, len = keywords.length; i < len; i++) {
                        match = q.exec(keywords[i]);
                        if (match) {
                            score++;
                        }
                    }

                    // add suggestion to this stage's matches
                    // each subsequent stage has less and less matches
                    if (score) {
                        suggestion.score += score;
                        stageMatches.push(suggestion);
                    }
                });

                if (stageMatches.length === 0) {
                    // if the first few words have no matches then
                    // skip them until we find some matches first
                    if (foundSomeMatches)
                        matched = stageMatches;
                } else {
                    foundSomeMatches = true;
                    matched = stageMatches;
                }
            });

            // sort matches by score
            matched.sort(function (a, b) {
                return b.score - a.score;
            });

            // show matches
            for (i = matched.length - 1; i >= 0; i--) {
                matched[i].menuItem.class.remove('hidden');
                menu.innerElement.insertBefore(matched[i].menuItem.element, menu.innerElement.firstChild);
            }
        } else {
            // show all suggestions
            for (i = suggestions.length - 1; i >= 0; i--) {
                suggestions[i].menuItem.class.remove('hidden');
                menu.innerElement.insertBefore(suggestions[i].menuItem.element, menu.innerElement.firstChild);
            }

        }

    };


    // handle clicking outside menu in order to close it
    var click = function (e) {
        var parent = e.target;
        while (parent) {
            if (parent === panel.innerElement) {
                input.elementInput.focus();
                return;
            }

            parent = parent.parentElement;
        }

        menu.open = false;
    };

    // handle arrow keys to focus next / previous suggestion
    var key = function (e) {
        var result;

        // up arrow
        if (e.keyCode === 38) {
            result = focusNextSuggestion(false);
        }
        // down arrow
        else if (e.keyCode === 40) {
            result = focusNextSuggestion(true);
        }

        if (result) {
            e.preventDefault();
            e.stopPropagation();
        }
    };

    // Focus next or previous suggestion
    var focusNextSuggestion = function (forward) {
        var next = forward ? menu.innerElement.firstChild : menu.innerElement.lastChild;
        if (focusedMenuItem) {
            focusedMenuItem.classList.remove('focused');

            if (forward) {
                if (focusedMenuItem.nextSibling)
                    next = focusedMenuItem.nextSibling;
            } else {
                if (focusedMenuItem.previousSibling)
                    next = focusedMenuItem.previousSibling;
            }
        }

        var valueBeforeLoop = next;

        while (next.classList.contains('hidden')) {
            if (forward) {
                next = next.nextSibling || menu.innerElement.firstChild;
            } else {
                next =  next.previousSibling || menu.innerElement.lastChild;
            }

            if (next === valueBeforeLoop) // avoid infinite loop
                return;
        }

        focusedMenuItem = next;
        focusedMenuItem.classList.add('focused');

        // scroll into view if needed
        var focusedRect = focusedMenuItem.getBoundingClientRect();
        var menuRect = menu.innerElement.getBoundingClientRect();

        if (focusedRect.bottom > menuRect.bottom)
            menu.innerElement.scrollTop += focusedRect.bottom - menuRect.bottom;
        else if (focusedRect.top < menuRect.top) {
            menu.innerElement.scrollTop -= menuRect.top - focusedRect.top;
        }

        return true;
    };

    // handle open event
    menu.on('open', function (open) {
        if (open) {
            window.addEventListener('click', click);
            window.addEventListener('keydown', key);
            input.class.add('focus');
            menu.innerElement.scrollTop = 0;
            close.hidden = true;

            filterSuggestions();
        }
        else {
            window.removeEventListener('click', click);
            window.removeEventListener('keydown', key);
            input.class.remove('focus');
            if (focusedMenuItem) {
                focusedMenuItem.classList.remove('focused');
                focusedMenuItem = null;
            }
            close.hidden = false;

            if (input.value)
                storeEvent(input.value);

            input.value = '';
        }

    });

    var toggleWidget = function (toggle) {
        panel.hidden = !toggle;
        if (toggle) {
            setTimeout(function () {
                input.elementInput.focus();
            });
        }
    };

    // method to show the widget
    editor.method('help:howdoi', function () {
        toggleWidget(true);
    });

    // method to toggle the widget
    editor.method('help:howdoi:toggle', function () {
        toggleWidget(panel.hidden);
    });

    // hotkey
    editor.call('hotkey:register', 'help:howdoi', {
        key: 'space',
        ctrl: true,
        callback: function() {
            editor.call('help:howdoi');
        }
    });

    // position widget between top elements in viewport
    var positionWidget = function () {
        var canvas = editor.call('viewport:canvas');
        if (! canvas) return;

        var canvasRect = canvas.element.getBoundingClientRect();

        var titleWidget = document.querySelector('.widget-title');
        var titleWidgetRect = titleWidget ? titleWidget.getBoundingClientRect() : null;

        var topLeftWidth = titleWidgetRect ? titleWidgetRect.right - canvasRect.left : 0;

        var topControls = document.querySelector('.viewport-camera');
        var topControlsRect = topControls ? topControls.getBoundingClientRect() : null;

        var topRightWidth = topControlsRect ? canvasRect.left + canvasRect.width - topControlsRect.left : 0;

        var width = canvasRect.width - topLeftWidth - topRightWidth - 20;
        if (width < 150) {
            panel.class.add('hidden');
        } else {
            panel.class.remove('hidden');

            if (width > 400)
                width = 400;
        }


        panel.style.width = width + 'px';
        panel.style.left = (topLeftWidth + (((topControlsRect.left - titleWidgetRect.right) - width) / 2)) + 'px';
    };

});

/* editor/help/howdoi-popup.js */
editor.once('load', function () {
    'use strict';

    var root = editor.call('layout.root');
    var overlay = new ui.Overlay();
    overlay.class.add('help-howdoi');
    overlay.hidden = true;
    overlay.clickable = true;
    root.append(overlay);

    var panel = new ui.Panel();
    overlay.append(panel);

    var content = new ui.Label();
    content.renderChanges = false;
    panel.append(content);

    var docs = new ui.Button({
        text: 'View Docs'
    });
    docs.class.add('docs');
    panel.append(docs);
    docs.hidden = true;

    var key = function (e) {
        // close on esc
        if (e.keyCode === 27) {
            overlay.hidden = true;
        }
    };

    overlay.on('show', function () {
        editor.emit('help:howdoi:popup:open');
        window.addEventListener('keydown', key);
    });

    overlay.on('hide', function () {
        window.removeEventListener('keydown', key);
        editor.emit('help:howdoi:popup:close');
    });


    editor.method('help:howdoi:popup', function (data) {
        overlay.hidden = false;
        content.text = data.text;

        setTimeout(function () {
            var closeButton = panel.innerElement.querySelector('.close');
            if (closeButton)
                closeButton.addEventListener('click', function () {
                    overlay.hidden = true;
                });
        });
    });

});

/* editor/help/howdoi-load.js */
editor.once('load', function () {
    var data = {
        url: config.url.howdoi,
        method: 'GET'
    };

    Ajax(data)
    .on('load', function(status, data) {
        if (! data || !data.length)
            return;

        data.forEach(function (tip) {
            editor.call('help:howdoi:register', {
                title: tip.title,
                text: tip.html,
                keywords: tip.keywords
            });
        });

        editor.emit('help:howdoi:load');
    })
    .on('error', function(status, data) {
        console.error(status);
    });
});

/* editor/demo_project.js */
editor.once('load', function() {
    'use strict';

    if (config.self.openedEditor)
        return;

    if (config.project.name !== 'My First Project')
        return;

    var root = editor.call('layout.root');

    // overlay
    var overlay = new ui.Overlay();
    overlay.hidden = true;
    overlay.clickable = true;
    overlay.class.add('demo');
    root.append(overlay);

    // panel
    var panel = new ui.Panel();
    overlay.append(panel);

    // contents
    var header = new ui.Label({
        text: "Editor Intro"
    });
    header.class.add('header');
    panel.append(header);

    var main = new ui.Label({
        text: "To help you learn PlayCanvas we've created your first project. It's a simple ball rolling game. Complete the design of the level by adding an extra platform, then design your own levels.<br/><br/>We'll pop up some tips to help you along the way."
    });
    main.class.add('main');
    panel.append(main);

    var close = new ui.Button({
        text: "LET'S GO"
    });
    close.class.add('close');
    panel.append(close);
    close.on('click', function () {
        overlay.hidden = true;
    });

    editor.once('scene:raw', function() {
        overlay.hidden = false;
    });

    overlay.on('show', function () {
        editor.emit('help:demo:show');
    });

    overlay.on('hide', function () {
        editor.emit('help:demo:close');
    });
});


/* editor/guides/guide-bubbles.js */
editor.once('load', function() {
    'use strict';

    var root = editor.call('layout.root');

    var overlay = new ui.Overlay();
    overlay.clickable = true;
    overlay.hidden = true;
    overlay.class.add('bubble');
    root.append(overlay);

    var panel = new ui.Panel();
    overlay.append(panel);

    var label = new ui.Label();
    panel.append(label);

    var btn = new ui.Button({
        text: 'GOT IT'
    });
    btn.class.add('next');
    btn.on('click', function() {
        overlay.hidden = true;
    });
    overlay.append(btn);

    editor.method('guide:bubble', function (title, text, x, y, align, parent) {
        var bubble = new ui.Bubble();

        if (!parent)
            parent = root;

        if (parent instanceof Node) {
            parent.appendChild(bubble.element);
        } else {
            parent.append(bubble.element);
        }

        bubble.position(x, y);

        var evt;

        bubble.on('activate', function () {
            var rect = bubble.element.getBoundingClientRect();

            panel.header = title;
            label.text = text;
            overlay.hidden = false;

            overlay.innerElement.style.top = rect.top + 'px';
            overlay.innerElement.style.left = rect.left + 'px';

            overlay.class.add('arrow-' + align);

            if (/^bottom/.test(align)) {
                var overlayRect = overlay.innerElement.getBoundingClientRect();
                overlay.innerElement.style.marginTop = (-40 - overlayRect.height) + 'px';
            }

            evt = overlay.once('hide', function () {
                bubble.deactivate();
            });
        });

        bubble.on('deactivate', function () {
            bubble.destroy();
            overlay.hidden = true;
            if (evt) {
                evt.unbind();
                evt = null;
            }
        });

        return bubble;
    });

    overlay.on('show', function () {
        overlay.class.remove('arrow-left');
        overlay.class.remove('arrow-top');
        overlay.class.remove('arrow-top-right');
        overlay.class.remove('arrow-right');
        overlay.class.remove('arrow-bottom');
        overlay.class.remove('arrow-bottom-right');
        overlay.innerElement.style.marginTop = '';
    });
});


/* editor/guides/guide-intro.js */
editor.once('load', function () {
    'use strict';

    var nextDelay = 500;

    var bubbles = [];

    var timeouts = {};

    var bubbleDemo1 = function () {
        var bubble = editor.call(
            'guide:bubble',
            'Complete this level (1 / 4)',
            "Let's duplicate one of those platforms. Click on a platform in the 3D view to select it.",
            '50%',
            '50%',
            'left',
            editor.call('layout.viewport')
        );


        return bubble;
    };

    var bubbleDemo2 = function () {
        var bubble = editor.call(
            'guide:bubble',
            'Complete this level (2 / 4)',
            'Hit Ctrl+D or click the <span class="font-icon">&#57638;</span> button to duplicate the selected platform.',
            '50%',
            '50%',
            'left',
            editor.call('layout.viewport')
        );


        return bubble;
    };

    var bubbleDemo3 = function () {
        var bubble = editor.call(
            'guide:bubble',
            'Complete this level (3 / 4)',
            "Use the arrows of the Translate tool to move the platform. Try to fill that gap so that the ball can safely reach the rightmost platform.",
            '50%',
            '50%',
            'left',
            editor.call('layout.viewport')
        );

        return bubble;
    };

    var bubbleDemo4 = function () {
        return editor.call(
            'guide:bubble',
            'Complete this level (4 / 4)',
            "Click <span class='font-icon'>&#57649;</span> <strong>Launch</strong> to play the game. Use the arrow keys to move the ball. The game will open in a new tab so just switch back to the Editor tab when you're done.<br/><br/>Any changes you make to the scene will automatically update the launched game.",
            46,
            29,
            'top-right',
            editor.call('layout.toolbar.launch')
        );
    };

    var bubbleHierarchy = function () {
        return editor.call(
            'guide:bubble',
            'Scene Hierarchy',
            'This is your <strong>Scene Hierarchy</strong> made up of <strong>Entities</strong>, which can be given new behaviours by adding Components.<br/><br/> <span class="font-icon">&#57632;</span> Add, <span class="font-icon">&#57638;</span> Duplicate and <span class="font-icon">&#57636;</span> Delete Entities using the controls in this panel.',
            360,
            60,
            'left'
        );
    };

    var bubbleLaunch = function () {
        return editor.call(
            'guide:bubble',
            'Launch Preview',
            'Click <span class="font-icon">&#57649;</span> <strong>Launch</strong> to preview your scene. Any changes you make to your scene while in the Editor will automatically update the launched scene.',
            46,
            29,
            'top-right',
            editor.call('layout.toolbar.launch')
        );
    };

    var bubbleDashboard = function () {
        return editor.call(
            'guide:bubble',
            'Dashboard',
            'This is the name of your <strong>Project</strong>. Click here to go to the <strong>Project Dashboard</strong>.<br/><br/>Visit your <strong>Dashboard</strong> to create a new <strong>Project</strong>.',
            55,
            28,
            'top',
            editor.call('layout.toolbar.scene')
        );
    };

    var bubbleAssets = function () {
        return editor.call(
            'guide:bubble',
            'Assets',
            '<strong>Drag`n`Drop</strong> files from your computer to upload assets or use the <span class="font-icon">&#57632;</span> Add button to create new assets.<br/><br/>You can filter and <span class="font-icon">&#57641;</span> search your assets using the controls at the top.',
            54,
            -39,
            'bottom',
            editor.call('layout.assets').element
        );
    };

    var bubbleStore = function () {
        var bubble = editor.call(
            'guide:bubble',
            'Asset Library',
            '<img width="424" height="133" src="https://s3-eu-west-1.amazonaws.com/static.playcanvas.com/instructions/asset_library.jpg"/><br/><br/>Click the <strong>Library</strong> button to open the Asset Library. Add free 3D models and assets from the library into your scene with a single click.',
            560,
            -36,
            'bottom-right',
            editor.call('layout.assets').element
        );

        bubble.style.zIndex = 'initial';
        return bubble;
    };

    var bubbleMenu = function () {
        return editor.call(
            'guide:bubble',
            'Main Menu',
            'The <span style="display:inline-block;background-image:url(\'https://s3-eu-west-1.amazonaws.com/static.playcanvas.com/images/editor_logo.png\');width:18px;height:18px;background-size:36px 18px;background-position:-18px 0;vertical-align:text-bottom;"></span> main menu and toolbar has every command available in the Editor. If you cant find a button or remember a hot key, you will always find the command in the menu.',
            18,
            40,
            'top'
        );
    };

    var bubbleControls = function () {
        var bubble = editor.call(
            'guide:bubble',
            'Controls',
            'Click here to see <strong>controls</strong> and <strong>shortcuts</strong> for the Editor.',
            41,
            0,
            'bottom',
            editor.call('layout.toolbar')
        );

        bubble.element.style.top = '';
        bubble.element.style.bottom = '72px';
        return bubble;
    };

    var bubbleEntity = function () {
        var bubble = editor.call(
            'guide:bubble',
            'Entity Inspector',
            'This is the <strong>Entity Inspector</strong>. Here you can enable or disable an Entity, edit its name or its position / rotation and scale. <br/><br/>If you want to add behaviours to your Entity click on Add Component.',
            0,
            100,
            'right',
            editor.call('layout.viewport')
        );

        bubble.element.style.left = '';
        bubble.element.style.right = '6px';

        return bubble;
    };

    var showBubble = function (name, bubbleFn, delay, force, callback) {
        if (!force && config.self.tips[name] !== false) return false;

        if (timeouts[name])
            clearTimeout(timeouts[name]);

        timeouts[name] = setTimeout(function () {
            delete timeouts[name];

            var bubble = bubbleFn();
            bubbles.push(bubble);

            bubble.on('deactivate', function () {
                config.self.tips[name] = true;
                Ajax.post('/editor/scene/{{scene.id}}/tips/' + name, {});

                if (callback)
                    callback();
            });
        }, delay);

        return true;
    };

    editor.method('guide:bubble:show', function (name, bubbleFn, delay, force, callback) {
        showBubble(name, bubbleFn, delay, force, callback);
    });

    var showEntityBubbleOnSelect = function () {
        if (config.self.tips.entityInspector === false) {
            var evtEntitySelect = editor.on('selector:change', function (type, items) {
                if (type !== 'entity') return;

                evtEntitySelect.unbind();

                showBubble('entityInspector', bubbleEntity, nextDelay);
            });
        }
    };


    var showBubbles = function (initialDelay) {
        var delay = initialDelay;

        if (showBubble('mainMenu', bubbleMenu, delay))
            delay += nextDelay;

        if (showBubble('hierarchy', bubbleHierarchy, delay))
            delay += nextDelay;

        if (showBubble('dashboard', bubbleDashboard, delay))
            delay += nextDelay;

        if (showBubble('launch', bubbleLaunch, delay))
            delay += nextDelay;

        if (showBubble('assets', bubbleAssets, delay))
            delay += nextDelay;

        // show store bubble for existing users as well
        if (!config.self.tips.store && showBubble('store', bubbleStore, delay, true))
            delay += nextDelay;

        if (showBubble('controls', bubbleControls, delay))
            delay += nextDelay;

        showEntityBubbleOnSelect();
    };

    editor.method('editor:tips:reset', function () {
        // destroy existing bubbles
        bubbles.forEach(function (bubble) {
            bubble.destroy();
        });

        bubbles.length = 0;

        Ajax.post('/editor/scene/{{scene.id}}/tips/reset', {});

        ['hierarchy',
         'assets',
         'store',
         'dashboard',
         'entityInspector',
         'mainMenu',
         'controls',
         'launch',
         'howdoi'].forEach(function (tip) {
            config.self.tips[tip] = false;
         });

         showBubbles(100);
    });

    var openedDemo = false;

    editor.once('help:demo:show', function () {
        openedDemo = true;

        editor.once('help:demo:close', function () {
            Ajax.post('/editor/scene/{{scene.id}}/opened', { });

            // show some demo specific bubbles first
            setTimeout(function () {
                bubbleDemo1().on('deactivate', function () {
                    setTimeout(function () {
                        bubbleDemo2().on('deactivate', function () {
                            setTimeout(function () {
                                bubbleDemo3().on('deactivate', function () {
                                    setTimeout(function () {
                                        bubbleDemo4().on('deactivate', function () {
                                            setTimeout(function () {
                                                showBubbles(0);
                                            }, 3000);
                                        });
                                    }, 2000);
                                });
                            }, 2000);
                        });
                    }, 2000);
                });
            }, 1000);
        });
    });

    editor.once('scene:raw', function () {
        // If the demo popup has opened show bubbles after it
        // otherwise show them right away
        setTimeout(function () {
            if (!openedDemo)
                showBubbles(0);
        }, 3000);
    });
});


